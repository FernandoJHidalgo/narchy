package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
package RED;

import java.io.*;
import java.util.*;
import RED.*;
import RED.lineTree.*;

/**
 * @invariant length() == asString().length()
 * @invariant testClassInvariant()
 * @invariant testClassInvariantStyle()
 */
public class REDText 
{
	/** create and a load a text
	 * @param filename if this parameter is != "", then the text is loaded from disk. This may throw a REDException
	 * @pre filename != null
	 */
	public REDText(String filename) throws REDException {
		fFilename = filename;
		if (fFilename != "") {
			load();
		}
	}
	
	/** return text as string 
	 * @return the text as string
	 * @post return != null
	 * @post return.length() == length()
	 */
	public String asString() {
		StringBuffer buf = new StringBuffer((int) length());
		REDRun cur = fHead;
		while (cur != null) {
			buf.append(cur.asString());
			cur = cur.fNext;
		}
		return new String(buf);
	}
	
	/** return part of the text as string 
	 * from and to are normalized to be in range: [0, fLength] 
	 * @post return != null
	 */
	public String asString(int from, int to) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return "";
		}
		
		int length = (int) (to - from);
		StringBuffer buf = new StringBuffer((int) (to-from));
		REDRunSpec spec = findPrevRun(from);
		buf.append(spec.fRun.asString().substring((int) spec.fOff));
		REDRun cur = spec.fRun.fNext;
		while (buf.length() < length) {
			buf.append(cur.asString());
		}
		return buf.substring(0, length);
	}

	/** return part of the text as byte - array 
	  * may return null (if no text between from and to)
	  * @param arr if this parameter != null, try to reuse the passed array
	  */
	public byte[] asBytes(int from, int to, byte[] arr) {
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (from >= to) {
			return null;
		}
		int size = to - from;
		if (arr == null || arr.length < size) {
			arr = new byte[size];
		}
		REDRunSpec spec = findPrevRun(from);
		int done = spec.fRun.copyInto(arr, 0, size, spec.fOff);
		while (done < size) {
			spec.fRun = spec.fRun.fNext;
			done += spec.fRun.copyInto(arr, done, size, 0);
		}
		return arr;
	}
	
	/** replace text by string 
	 * This method deletes the stretch [from, to[ and inserts String s at from.
	 * from and to are normalized to be in range: [0, fLength] and to is normalized to be >= from
	 * @param from Position to replace from
	 * @param to Position to replace to
	 */
	public void replace(int from, int to, String s) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to > from) {
			delete(from, to);
		}
		if (s == "") {
			return;
		}
		
		to = from + s.length();
		callListeners(LI_BEFOREINSERT, from, to);				
		REDRunPair split = splitRun(from);
		REDStyle style;
		if (split.fBefore != null) {
			style = split.fBefore.fStyle;
		}
		else if (split.fAfter != null) {
			style = split.fAfter.fStyle;
		}
		else {
			style = getDefaultStyle();
		}
		REDRun r = null;
		try {
			r = new REDRun(fScratchFile, s, style);
			fLength += r.length();
		}
		catch (IOException ioe) {
			// TBD
			System.err.println("Cannot write to scratch file. Aborting");
			System.exit(-1);
		}
		if (split.fBefore != null) {
			split.fBefore.fNext = r;
		}
		else {
			fHead = r;
		}
		if (split.fAfter != null) {
			r.fNext = split.fAfter;
		}
		if (split.fBefore != null) {
			mergeRuns(split.fBefore, split.fAfter);
		}
		else {
			mergeRuns(r, split.fAfter);
		}
		fLineTree.notifyInsert(from, s.length(), tokenize(from, to));
//		fLineTree.notifyInsert(from, s.length(), tokenize(s));
		callListeners(LI_AFTERINSERT, from, to);				
	}
	
	/** set style for a stretch of the text. from and to have gap semantics, i.e. to set the style for the first character of a text you
	 * have to call setStyle(0, 1, style)
	 * from and to are normalized to be in range: [0, fLength] 	
	 * @param from startposition of stretch to set style for
	 * @param to endposition of stretch to set style for
	 * @param style to set
	 * @pre style != null
	 * @post forall int x in from .. to-1 | getStyle(x) == style
	 */
	public void setStyle(int from, int to, REDStyle style) {
		// parameter normalization
		from = Math.max(from, 0); from = Math.min(from, fLength);
		to = Math.max(to, 0); to = Math.min(to, fLength); to = Math.max(to, from);
		if (to <= from) {
			return;
		}
		callListeners(LI_BEFORESTYLECHANGE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		REDRun cur = start.fAfter;
		while (cur != end.fAfter) {
			cur.fStyle = style;
			cur = cur.fNext;
		}
		REDRun s, e;
		s = start.fBefore;
		if (s == null) {
			s = start.fAfter;
		}
		e = end.fAfter;
		if (e == null) {
			e = end.fBefore;
		}
		REDAssert.assert(s != null && e != null);
		mergeRuns(s, e);
		callListeners(LI_AFTERSTYLECHANGE, from, to);				
	}

	/** get style for text position 
	 * pos is normalized to be in range: [0, fLength] 	
	 * if pos lies between two runs the style of the first run is returned
	 * @param pos position to get style for
	 * @return style at given position 
	 * @post return != null
	 */
	REDStyle getStyle(int pos) {
		pos = Math.max(pos, 0); pos = Math.min(pos, fLength);
		REDRunSpec r = findPrevRun(pos);
		return r.fRun.fStyle;
	}

	public int length() {
		return fLength;
	}
	
	/** load file from disk 
	 */
	public void load() throws REDException {
		// this routine could be much faster (O(1)), if only windows hadn't such a $&@! locking semantics
		callListeners(LI_BEFORELOAD);				
		try {
			copyFile(new RandomAccessFile(fFilename, "r"), fScratchFile);
			fLength = (int) fScratchFile.length();
			fHead = new REDRun(fScratchFile, 0, fLength, getDefaultStyle());
			fLineTree.notifyInsert(0, fLength, tokenize(0, fLength));
		}
		catch (IOException ioe) {
			fLength = 0;
			fHead = null;
			fScratchFile = REDTextServer.getUniqueTmpFile();
			throw new REDException("Unable to load " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERLOAD);				
	}
	
	public void save() throws REDException {
		callListeners(LI_BEFORESAVE);				
		try {
			RandomAccessFile sf = new RandomAccessFile(fFilename, "rw");
			sf.setLength(0);
			REDRun cur = fHead;
			while (cur != null) {
				cur.copyInto(sf);
				cur = cur.fNext;
			}
		}
		catch (IOException ioe) {
			throw new REDException("Unable to save " + fFilename + ". Reason: " + ioe);
		}
		callListeners(LI_AFTERSAVE);				
	}
	
	public REDStyle getDefaultStyle() {
		return fDefaultStyle;
	}
	
	public void setDefaultStyle(REDStyle style) {
		fDefaultStyle = style;
	}
	
	/** return start of line 
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @return the start position of the line
	 * @post return >= 0 && return <= length()
	 */
	public int getLineStart(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		if (lineNr >= getNrOfLines()) {
			return length();
		}
		return fLineTree.getLineStart(lineNr);
	}
	
	/** return end of line without linebreak character(s)
	  * lineNr is normalized to be in range: [0, nrLines] 
 	  * @param lineNr Number of line to get end position for. First line has number 0.
	  * @return the end position of the line
	  * @post return >= 0 && return <= length()
	  */
	public int getLineEnd(int lineNr) {
		if (lineNr < 0) lineNr = 0;
		int retVal = getLineStart(lineNr+1);
		if (retVal > 1 && asString(retVal-2, retVal).equals("\r\n")) {
			retVal -= 2;
		}
		else if (retVal > 0 && asString(retVal-1, retVal).equals("\r") || asString(retVal-1, retVal).equals("\n")) {
			retVal--;
		}
		return retVal;
	}
	
	/** return length of line
	 * lineNr is normalized to be in range: [0, nrLines] 
	 * @param lineNr Number of line to get start position for. First line has number 0.
	 * @param includingLinebreak true: return length including linebreak characters; false: return length without linebreak characters
	 * @return the length of the line
	 * @post return >= 0
	 */
	public int getLineLength(int lineNr, boolean includingLinebreak) {
		if (lineNr < 0) lineNr = 0;
		int retVal;
		if (includingLinebreak) {
			retVal = getLineStart(lineNr+1) - getLineStart(lineNr);
		}
		else {
			retVal = getLineEnd(lineNr) - getLineStart(lineNr);
		}
		return retVal;
	}

	
	
	/** add a listener to this text 
	  * @param listener The listener to be added to the text
	  * @return true if successful, false otherwise	
	  * @pre listener != null
	  */
	public boolean addListener(REDTextEventListener listener) {
		if (!fListeners.contains(listener)) {
			return fListeners.add(listener);
		}
		return false;
	}
	
	/** remove a listener from this text 
	  * @param listener The listener to be removed from the text
	  * @return true if successful, false otherwise
	  * @pre listener != null
	  */
	public boolean removeListener(REDTextEventListener listener) {
		return fListeners.remove(listener);
	}
	
	/** return nr of lines in text
	  * @return nr of lines in text; an empty text has 1 line.
	  * @post return >= 1
	  */
	public int getNrOfLines() {
		return fLineTree.getNrNodes();
	}
	
	/** get view stretch 
	  * @param from start of stretch
	  * @param stretch if this parameter != null then the passed stretch object is reused
	  * @return a view stretch
	  * @pre pos >= 0
	  * @pre pos <= length()
	  * @post return != null
	  * @post stretch != null implies return == stretch
	  */
	public REDViewStretch getViewStretch(int pos, REDViewStretch stretch) {
		if (stretch == null) {
			stretch = new REDViewStretch();
		}
		if (pos >= length()) {
			stretch.fType = REDViewStretch.EOF;
			stretch.fStyle = null;
			stretch.fLength = 0;
			return stretch;
		}
		REDRunSpec runSpec = findNextRun(pos);
		runSpec.fOff--;
		stretch.fStyle = runSpec.fRun.fStyle;
		stretch.fLength = 0;
		byte c = runSpec.fRun.getCharAt(runSpec.fOff);
		if (c == '\t') {
			stretch.fType = REDViewStretch.TAB;
			while (c == '\t' && runSpec.fOff < runSpec.fRun.fLength) {
				runSpec.fOff++; stretch.fLength++;
				if (runSpec.fOff < runSpec.fRun.fLength) {
					c = runSpec.fRun.getCharAt(runSpec.fOff);
				}
			}
		}
		else if (c == '\r' || c == '\n') {
			stretch.fType = REDViewStretch.LINEBREAK;
			stretch.fLength = 1;
			if (c == 'r' && runSpec.fOff < runSpec.fRun.fLength && runSpec.fRun.getCharAt(runSpec.fOff+1) == '\n') {
				stretch.fLength++;
			}
		}
		else {
			stretch.fType = REDViewStretch.TEXT;
			stretch.fLength = runSpec.fRun.findTabOrLinebreak(runSpec.fOff) - runSpec.fOff;
		}
		return stretch;
	}
		
	// *******************************************************************************************************************************************************
	// P R I V A T E - L I N E
	// *******************************************************************************************************************************************************
	/** copy file -- there is no API routine for that in Java :-(
	 * @pre src != null
	 * @pre dest != null
	 */
	private void copyFile (RandomAccessFile src, RandomAccessFile dest) throws IOException {
		dest.setLength(0);
		byte buf[] = new byte[16000];
		
		int len = src.read(buf);
		while (len != -1) {
			dest.write(buf, 0, len);
			len = src.read(buf);
		}
	}
	
	private static final int LI_BEFOREDELETE = 0;
	private static final int LI_AFTERDELETE = 1;
	private static final int LI_BEFOREINSERT = 2;
	private static final int LI_AFTERINSERT = 3;
	private static final int LI_BEFORESTYLECHANGE = 4;
	private static final int LI_AFTERSTYLECHANGE = 5;
	private static final int LI_BEFORELOAD = 6;
	private static final int LI_AFTERLOAD = 7;
	private static final int LI_BEFORESAVE = 8;
	private static final int LI_AFTERSAVE = 9;
	
	private void callListeners(int op, int from, int to) {
		callListeners(op, from, to, null);
	}

	private void callListeners(int op) {
		callListeners(op, 0, 0, null);
	}

	private void callListeners(int op, int from, int to, REDStyle style) {
		for (int i = REDTextEventListener.RLL_VIEW; i <= REDTextEventListener.RLL_LATE; i++) {
			for (int j = 0; j < fListeners.size(); j++) {
				REDTextEventListener listener = (REDTextEventListener) fListeners.elementAt(j);
				if (listener.getListenerLevel() == i) {
					switch (op) {
						case LI_BEFOREDELETE:
							listener.beforeDelete(from, to);
						break;
						case LI_AFTERDELETE:
							listener.afterDelete(from, to);
						break;
						case LI_BEFOREINSERT:
							listener.beforeInsert(from, to);
						break;
						case LI_AFTERINSERT:
							listener.afterInsert(from, to);
						break;
						case LI_BEFORESTYLECHANGE:
							listener.beforeStyleChange(from, to, style);
						break;
						case LI_AFTERSTYLECHANGE:
							listener.afterStyleChange(from, to, style);
						break;
						case LI_BEFORELOAD:
							listener.beforeLoad();
						break;
						case LI_AFTERLOAD:
							listener.afterLoad();
						break;
						case LI_BEFORESAVE:
							listener.beforeSave();
						break;
						case LI_AFTERSAVE:
							listener.afterSave();
						break;
					}
				}
			}
		}
	}
	

	private void delete(int from, int to) {
		callListeners(LI_BEFOREDELETE, from, to);				
		REDRunPair start = splitRun(from);
		REDRunPair end = splitRun(to);
		if (start.fBefore != null) {
			start.fBefore.fNext = end.fAfter;
		}
		else {
			fHead = end.fAfter;
		}
		fLength = fLength - to + from;
		if (fLength == 0) {
			try {
				fScratchFile.setLength(0);
			}
			catch (IOException ioe) {	// TBD
				throw new Error("Cannot reset scratch file. Aborting");
			}
		}
		fLineTree.notifyDelete(from, to);
		callListeners(LI_AFTERDELETE, from, to);				
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, a is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff > 0 || pos == 0
	 * @post return.fOff <= return.fRun.fLength
	 */
	private REDRunSpec findPrevRun(int pos) {
		// TBD: optimize 
		REDRun cur = fHead;
		int curPos = 0;
		while (cur != null && curPos + cur.length() < pos) {
			curPos += cur.length();
			cur = cur.fNext;
		}
			
		REDRunSpec retVal = new REDRunSpec();
		if (cur != null) {
			retVal.fRun = cur;
			retVal.fOrg = curPos;
			retVal.fOff = pos - curPos;
			REDAssert.assert(retVal.fOff >= 0);
			REDAssert.assert(retVal.fOrg >= 0);
		}
	
		return retVal;	
	}
	
	/** find the run which contains given position 
	 * caveat: if the given position lies between run a and b, b is returned
	 * @param pos The position to find the run for
	 * @return A run specification representing the found run. May be invalid (if given position was larger than text)
	 * @pre pos >= 0
	 * @pre pos <= length()
	 * @post return != null
	 * @post return.fOff >= 0
	 * @post return.fOff < return.fRun.fLength
	*/
	private REDRunSpec findNextRun(int pos) {
		REDRunSpec spec = null;
		if (pos < fLength) {
			spec = findPrevRun(pos+1);
			spec.fOff--;
		}
		else {
			spec = findPrevRun(pos);
		}
		return spec;
	}

	/** split run at pos and return pair of runs */
	private REDRunPair splitRun(int pos) {
		REDRunPair p = new REDRunPair();
		if (pos == 0) {
			p.fBefore = null;
			p.fAfter = fHead;
		}
		else {
			REDRunSpec spec = findPrevRun(pos); REDAssert.assert(spec.isValid());
			p.fBefore = spec.fRun;
			int len = spec.fRun.length();
			if (spec.fOff != len) { // need to split
				p.fAfter = new REDRun(p.fBefore.fBuffer, p.fBefore.fOrg + spec.fOff, p.fBefore.fLength - spec.fOff, p.fBefore.fStyle);
				p.fBefore.fLength = spec.fOff;
				p.fAfter.fNext = p.fBefore.fNext;
				p.fBefore.fNext = p.fAfter;
			}
			else { // we already have a split
				p.fAfter = p.fBefore.fNext;
			}
		}
		return p;
	}
	
	/** merge all runs between start and end where possible 
	  * @pre start != null
	  */
	private void mergeRuns(REDRun start, REDRun end) {
		REDRun cur = start;
		REDRun next = cur.fNext;
		
		while (cur != end && next != null) {
			if (cur.isMergeableWith(next)) {
				cur.fLength += next.fLength;
				cur.fNext = next.fNext;
			}
			if (next == end) {
				next = null;
			}
			else {
				cur = cur.fNext;
				if (cur != null) {
					next = cur.fNext;
				}
				else {
					next = null;
				}
			}
		}
	}
	
	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  * @deprecated use tokenize(int, int) instead, it is _much_ faster
	  */
	protected Vector tokenize(String str) {
		int len = str.length();
		int lastPos = 0;
		int x = 0;
		char c;
		Vector retVal = new Vector();
		
		while (x < len) {
			c = str.charAt(x);
			if (c == '\r' && x+1 < len && str.charAt(x+1) == '\n') {
				x++;
			}
			if (c == '\r' || c == '\n') {
				retVal.add(new Integer(x-lastPos + 1));
				lastPos = x+1;
			}
			x++;
		}			
		retVal.add(new Integer(len - lastPos)); 
		return retVal;
	}

	/** split String into lines including linebreak character
	  * StringTokenizer wont cut it: It cannot use \r\n as delimiter :-(
	  */
	protected Vector tokenize(int from, int to) {
		int nextLineStart = 0;
		Vector retVal = new Vector();
		while (from < to) {
			REDRunSpec runSpec = findNextRun(from);
			nextLineStart = runSpec.fRun.findNextLine(runSpec.fOff) - runSpec.fOff;

			retVal.add(new Integer(Math.min(nextLineStart, to - from)));
			from += nextLineStart;
		}
		String lastChar = asString(to-1, to);
		if (lastChar.equals("\n") || lastChar.equals("\r")) { // TBD: somebody find a way to make this more elegant!
			retVal.add(new Integer(0));
		}
		return retVal;
	}

	
	/** used for testing the class invariant 
	 * @return true, if invariant is ok, false otherwise.
	 */
	private boolean testClassInvariant() {
		int actLen = 0; 
		REDRun cur = fHead;
		while (cur != null) {
			actLen += cur.length();
			if (cur.length() <= 0) {
				return false;
			}
			if (cur.length() != cur.asString().length()) {
				return false;
			}
			cur = cur.fNext;
		}	
		return actLen == length();
	}
	
	private boolean testClassInvariantStyle() {
		REDRun cur = fHead;
		while (cur != null) {
			if (cur.fStyle == null) {
				return false;
			}
			cur = cur.fNext;
		}
		return true;
	}

	void dumpStructure() {
		REDRun cur = fHead;
		while (cur != null) {
			System.out.println("Run: " + cur.asString() + "->");
			cur = cur.fNext;
		}
		System.out.println("null");
	}
	
	private class REDRunSpec {
		public REDRun fRun;
		public int fOrg;
		public int fOff;
		{
			fRun = null;
			fOrg = -1;
			fOff = -1;
		}
		public boolean isValid() {
			return fRun != null;
		}
	}
	
	private REDRun fHead;
	private int fLength;
	private RandomAccessFile fScratchFile;
	private String fFilename;
	private REDStyle fDefaultStyle;
	protected REDLineTree fLineTree;	// TBD make me private again.
	private Vector fListeners;
	{
		fHead = null;
		fScratchFile = REDTextServer.getUniqueTmpFile();
		fDefaultStyle = REDStyleManager.getDefaultStyle();
		fLineTree = new REDLineTree();
		fListeners = new Vector(2);	// we usually have two observers: REDEditor and REDView
	}
}
