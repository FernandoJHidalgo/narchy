package jhelp.engine.util;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;








/**
 * Utilities for Input/Output streams
 * 
 * @author JHelp
 */
public final class UtilIO
{
   /** "Home" directory */
   private static File        homeDirectory;
   /** Directory external of the code */
   private static File        outsideDirectory;
   /** Temporary directory */
   private static File        temporaryDirectory;
   /** Buffer size */
   public static final int    BUFFER_SIZE        = 4 * UtilIO.MEGA_BYTES;
   /** Path that represents the current directory */
   public static final String CURRENT_DIRECTORY  = ".";
   /** Size of a file header */
   public static final int    HEADER_SIZE        = UtilIO.KILO_BYTES;
   /** One kilo-byte in bytes */
   public static final int    KILO_BYTES         = 1024;
   /** One mega-byte in bytes */
   public static final int    MEGA_BYTES         = 1024 * UtilIO.KILO_BYTES;
   /** Path separator used in URL, ZIP, JAR */
   public static final char   PATH_SEPARATOR     = '/';

   /** Path the represents the parent directory */
   public static final String PREVIOUS_DIRECTORY = "..";

   /**
    * Create a double from a byte array.<br>
    * Work good with byte array generated with {@link #doubleToByteArray(double)}
    * 
    * @param array
    *           Array to convert
    * @return Double obtain
    */
   public static double byteArrayToDouble(final byte[] array)
   {
      return Double.longBitsToDouble(UtilIO.byteArrayToLong(array));
   }

   /**
    * Create a long from a byte array.<br>
    * Work good with byte array generated with {@link #longToByteArray(long)}
    * 
    * @param array
    *           Array to convert
    * @return Long obtain
    */
   public static long byteArrayToLong(final byte[] array)
   {
      return ((long) (array[0] & 0xFF) << 56L) | ((long) (array[1] & 0xFF) << 48L) | ((long) (array[2] & 0xFF) << 40L) | ((long) (array[3] & 0xFF) << 32L)
            | ((long) (array[4] & 0xFF) << 24L) | ((long) (array[5] & 0xFF) << 16L) | ((long) (array[6] & 0xFF) << 8L) | (array[7] & 0xFF);
   }

   /**
    * Compute the SHA code of a stream
    * 
    * @param inputStream
    *           Stream to read
    * @return SHA code
    * @throws NoSuchAlgorithmException
    *            If SHA not implemented (Should never append, its java base algorithm)
    * @throws IOException
    *            On reading issue
    */
   public static BigInteger computeBigIntegerSHA(InputStream inputStream) throws NoSuchAlgorithmException, IOException
   {
      final MessageDigest sha = MessageDigest.getInstance("SHA");
      byte[] temp = new byte[4096];

      int read = inputStream.read(temp);
      while(read >= 0)
      {
         sha.update(temp, 0, read);

         read = inputStream.read(temp);
      }

      inputStream.close();
      inputStream = null;

      temp = sha.digest();

      BigInteger bigInteger = BigInteger.ZERO;

      for(final byte b : temp)
      {
         bigInteger = bigInteger.shiftLeft(8).add(BigInteger.valueOf((b & 0xFF)));
      }

      return bigInteger;
   }

   /**
    * Compute SHA for a stream
    * 
    * @param inputStream
    *           Stream to read
    * @return MD5 of the stream
    * @throws NoSuchAlgorithmException
    *            If system not support SHA
    * @throws IOException
    *            On reading stream issue
    */
   public static byte[] computeByteArraySHA(final InputStream inputStream) throws NoSuchAlgorithmException, IOException
   {
      final MessageDigest sha = MessageDigest.getInstance("SHA");
      final byte[] temp = new byte[4096];

      int read = inputStream.read(temp);
      while(read >= 0)
      {
         sha.update(temp, 0, read);

         read = inputStream.read(temp);
      }

      return sha.digest();
   }














































































   /**
    * Compute MD5 for a stream
    * 
    * @param inputStream
    *           Stream to read
    * @return MD5 of the stream
    * @throws NoSuchAlgorithmException
    *            If system not support MD5
    * @throws IOException
    *            On reading stream issue
    */
   public static String computeMD5(InputStream inputStream) throws NoSuchAlgorithmException, IOException
   {
      final MessageDigest md5 = MessageDigest.getInstance("MD5");
      byte[] temp = new byte[4096];

      int read = inputStream.read(temp);
      while(read >= 0)
      {
         md5.update(temp, 0, read);

         read = inputStream.read(temp);
      }

      inputStream.close();
      inputStream = null;

      temp = md5.digest();
      final StringBuffer stringBuffer = new StringBuffer();
      for(final byte b : temp)
      {
         read = b & 0xFF;
         stringBuffer.append(Integer.toHexString((read >> 4) & 0xF));
         stringBuffer.append(Integer.toHexString(read & 0xF));
      }
      temp = null;

      return stringBuffer.toString();
   }
























































































































































































































































































































































































































































































































































































































































































































































































































































































































   public static float readFloat(final InputStream inputStream) throws IOException
   {
      return Float.intBitsToFloat(UtilIO.readInteger(inputStream));
   }





































   public static int readInteger(final InputStream inputStream) throws IOException
   {
      return (inputStream.read() << 24) | (inputStream.read() << 16) | (inputStream.read() << 8) | inputStream.read();
   }



































































































































































































































































































































































































































































































































































































































































































































































































































































}