// Pei Wang's "Non-Axiomatic Logic" specified with a math. notation inspired DSL with given intiutive explainations:

//The rules of NAL, can be interpreted by considering the intiution behind the following two relations:
// Statement:                 (A --> B):               A can stand for B
// Statement about Statement: (A --> B) ==> (X --> Y): If A is true, so is/will be B
// --> is a relation in meaning of terms, while ==> is a relation of truth between statements.

//Similarity to Inheritance

    (S --> P), (S <-> P), task("?") |- (S --> P), (Belief:StructuralIntersection, Punctuation:Belief)


//desire spreading by similarity
     S, (S <-> P), task("!") |- P, (Desire:Intersection)



//Set Definition Similarity to Inheritance

    ({S} <-> {P}), {S} |- ({S} --> {P}), (Belief:Identity, Desire:Identity, Derive:AllowBackward)
    ([S] <-> [P]), [S] |- ([S] --> [P]), (Belief:Identity, Desire:Identity, Derive:AllowBackward)


//Set Definition Unwrap

    ({S} <-> {P}), {S} |- (S <-> P), (Belief:Identity, Desire:Identity, Derive:AllowBackward)
    ([S] <-> [P]), [S] |- (S <-> P), (Belief:Identity, Desire:Identity, Derive:AllowBackward)

//Nothing is more specific than a instance, so its similar

    (S --> {P}),  S  |- (S <-> {P}), (Belief:Identity, Desire:Identity, Derive:AllowBackward)
    (S --> {P}), {P} |- (S <-> {P}), (Belief:Identity, Desire:Identity, Derive:AllowBackward)

//nothing is more general than a property, so its similar

    ([S] --> P), [S] |- ([S] <-> P), (Belief:Identity, Desire:Identity, Derive:AllowBackward)
    ([S] --> P),  P  |- ([S] <-> P), (Belief:Identity, Desire:Identity, Derive:AllowBackward)


//Inheritance to Similarity

    (S <-> P), (S --> P), task("?") |- (S <-> P), (Belief:StructuralAbduction, Punctuation:Belief, Derive:NoSwap)

//If S can stand for P, P can to a certain low degree also represent the class S
//If after S usually P happens, then it might be a good guess that usually before P happens, S happens.

    (P --> S), (S --> P), task("?") |- (P --> S), (Belief:Conversion, Punctuation:Belief, Derive:NoSwap)
    (P ==> S), (S ==> P), task("?") |- (P ==> S), (Belief:Conversion, Punctuation:Belief, Derive:NoSwap)

// "If not smoking lets you be healthy, being not healthy may be the result of smoking"
//    ( --S ==> P),   P, time(dtTask) |- ( --P ==> S), (Belief:Contraposition, Derive:AllowBackward)
//    ( --S ==> P), --S, time(dtTask) |- ( --P ==> S), (Belief:Contraposition, Derive:AllowBackward)



//// inheritance-based syllogism ////////////////////////////////////////////////////////////////////////////////////
//       (A --> B) ------- (B --> C)
//            \               /
//             \             /
//              \           /
//               \         /
//                (A --> C)
//If A is a special case of B, and B is a special case of C, so is A a special case of C (strong), the other variations are hypotheses (weak)

(A --> B), (B --> C), neq(A,C) |- (A --> C), (Belief:Deduction, Desire:Strong, Derive:AllowBackward, Derive:NoSwap)
(A --> B), (A --> C), neq(B,C) |- (C --> B), (Belief:Abduction, Desire:Weak, Derive:AllowBackward, Derive:NoSwap)
(A --> C), (B --> C), neq(A,B) |- (A --> B), (Belief:Induction, Desire:Weak, Derive:AllowBackward, Derive:NoSwap)
(A --> B), (B --> C), neq(C,A) |- (C --> A), (Belief:Exemplification, Desire:Weak, Derive:AllowBackward, Derive:NoSwap)

//// similarity from inheritance ////////////////////////////////////////////////////////////////////////////////////
//If S is a special case of P, and P is a special case of S, then S and P are similar

    (S --> P), (P --> S) |- (S <-> P), (Belief:Intersection, Desire:Strong, Derive:AllowBackward, Derive:NoSwap)

//// inheritance from similarty <- todo check why this one was missing ////////////////////////////////////////////////////////////////////////////////////

    (S <-> P), (P --> S) |- (S --> P), (Belief:ReduceConjunction, Desire:Strong, Derive:AllowBackward, Derive:NoSwap)

//// similarity-based syllogism ////////////////////////////////////////////////////////////////////////////////////
//If P and S are a special case of M, then they might be similar (weak),
//also if P and S are a general case of M

    (P --> M), (S --> M), neq(S,P) |- (S <-> P), (Belief:Comparison, Desire:Weak, Derive:AllowBackward, Derive:NoSwap)
    (M --> P), (M --> S), neq(S,P) |- (S <-> P), (Belief:Comparison, Desire:Weak, Derive:AllowBackward, Derive:NoSwap)

//If M is a special case of P and S and M are similar, then S is also a special case of P (strong)

    (M --> P), (S <-> M), neq(S,P) |- (S --> P), (Belief:Analogy, Desire:Strong, Derive:AllowBackward, Derive:NoSwap)
    (P --> M), (S <-> M), neq(S,P) |- (P --> S), (Belief:Analogy, Desire:Strong, Derive:AllowBackward, Derive:NoSwap)
    (M <-> P), (S <-> M), neq(S,P) |- (S <-> P), (Belief:Resemblance, Desire:Strong, Derive:AllowBackward, Derive:NoSwap)

//// inheritance composition ////////////////////////////////////////////////////////////////////////////////////
//If P and S are in the intension/extension of M, then union/difference and intersection can be built:

    (P --> M), (S --> M), notSet(S), notSet(P), neq(S,P), no_common_subterm(S,P) |- ((S | P) --> M), (Belief:Intersection, Derive:NoSwap)
    (P --> M), (S --> M), notSet(S), notSet(P), neq(S,P), no_common_subterm(S,P) |- ((S & P) --> M), (Belief:Union, Derive:NoSwap)
    (P --> M), (S --> M), notSet(S), notSet(P), neq(S,P), no_common_subterm(S,P) |- ((P ~ S) --> M), (Belief:Difference, Derive:NoSwap)

    (M --> P), (M --> S), notSet(S), notSet(P), neq(S,P), no_common_subterm(S,P) |- (M --> (P & S)), (Belief:Intersection, Derive:NoSwap)
    (M --> P), (M --> S), notSet(S), notSet(P), neq(S,P), no_common_subterm(S,P) |- (M --> (P | S)), (Belief:Union, Derive:NoSwap)
    (M --> P), (M --> S), notSet(S), notSet(P), neq(S,P), no_common_subterm(S,P) |- (M --> (P - S)), (Belief:Difference, Derive:NoSwap)

//// inheritance decomposition ////////////////////////////////////////////////////////////////////////////////////
//if (S --> M) is the case, and ((|,S,A..+) --> M) is not the case, then ((|,A..+) --> M) is not the case, hence Belief:DecomposePositiveNegativeNegative

         (S --> M), ((|,S,A..+) --> M) |- ((|,A..+) --> M), (Belief:DecomposePositiveNegativeNegative)
         (S --> M), ((&,S,A..+) --> M) |- ((&,A..+) --> M), (Belief:DecomposeNegativePositivePositive)

         (M --> S), (M --> (&,S,A..+)) |- (M --> (&,A..+)), (Belief:DecomposePositiveNegativeNegative)
         (M --> S), (M --> (|,S,A..+)) |- (M --> (|,A..+)), (Belief:DecomposeNegativePositivePositive)

         (S --> M), ((S ~ P) --> M) |- (P --> M), (Belief:DecomposePositiveNegativePositive)
         (S --> M), ((P ~ S) --> M) |- (P --> M), (Belief:DecomposeNegativeNegativeNegative)

         (M --> S), (M --> (S - P)) |- (M --> P), (Belief:DecomposePositiveNegativePositive)
         (M --> S), (M --> (P - S)) |- (M --> P), (Belief:DecomposeNegativeNegativeNegative)


//Set comprehension:






//(C --> A), (C --> B), set_ext(A), union(A,B,R) |- (C --> R), (Truth:Union)
//(C --> A), (C --> B), set_ext(A), intersection(A,B,R) |- (C --> R), (Truth:Intersection)
    (C --> A), (C --> B), setext(A,B) |- (C --> union(A,B)), (Belief:Union, Derive:NoSwap)
    (C --> A), (C --> B), setext(A,B) |- (C --> intersect(A,B)), (Belief:Intersection, Derive:NoSwap)
    (C --> A), (C --> B), setext(A,B) |- (C --> differ(A,B)), (Belief:Difference, Derive:NoSwap)

//(C --> A), (C --> B), set_int(A), union(A,B,R) |- (C --> R), (Truth:Intersection)
//(C --> A), (C --> B), set_int(A), intersection(A,B,R) |- (C --> R), (Truth:Union)
    (C --> A), (C --> B), setint(A,B) |- (C --> union(A,B)), (Belief:Intersection, Derive:NoSwap)
    (C --> A), (C --> B), setint(A,B) |- (C --> intersect(A,B)), (Belief:Union, Derive:NoSwap)
    (C --> A), (C --> B), setint(A,B) |- (C --> differ(A,B)), (Belief:Difference, Derive:NoSwap)

//(A --> C), (B --> C), set_ext(A), union(A,B,R) |- (R --> C), (Truth:Intersection)
//(A --> C), (B --> C), set_ext(A), intersection(A,B,R) |- (R --> C), (Truth:Union)
    (A --> C), (B --> C), setext(A,B) |- (intersect(A,B) --> C), (Belief:Union, Derive:NoSwap)
    (A --> C), (B --> C), setext(A,B) |- (union(A,B) --> C), (Belief:Intersection, Derive:NoSwap)
    (A --> C), (B --> C), setext(A,B) |- (differ(A,B) --> C), (Belief:Difference, Derive:NoSwap)

//(A --> C), (B --> C), set_int(A), union(A,B,R) |- (R --> C), (Truth:Union)
//(A --> C), (B --> C), set_int(A), intersection(A,B,R) |- (R --> C), (Truth:Intersection)
    (A --> C), (B --> C), setint(A,B) |- (union(A,B) --> C), (Belief:Union, Derive:NoSwap)
    (A --> C), (B --> C), setint(A,B) |- (intersect(A,B) --> C), (Belief:Intersection, Derive:NoSwap)
    (A --> C), (B --> C), setint(A,B) |- (differ(A,B) --> C), (Belief:Difference, Derive:NoSwap)

//Set element takeout:

//    (C --> {X,A..+}), C |- (C --> {X}), (Belief:StructuralDeduction)
//    (C --> [X,A..+]), C |- (C --> [X]), (Belief:StructuralDeduction)
//    ({X,A..+} --> C), C |- ({X} --> C), (Belief:StructuralDeduction)
//    ([X,A..+] --> C), C |- ([X] --> C), (Belief:StructuralDeduction)
    (C --> {X,A..+}), {X,A..+}, no_common_subterm(X,C) |- (C --> {X}), (Belief:StructuralDeduction, Desire:StructuralDeduction)
    (C --> [X,A..+]), [X,A..+], no_common_subterm(X,C) |- (C --> [X]), (Belief:StructuralDeduction, Desire:StructuralDeduction)
    ({X,A..+} --> C), {X,A..+}, no_common_subterm(X,C) |- ({X} --> C), (Belief:StructuralDeduction, Desire:StructuralDeduction)
    ([X,A..+] --> C), [X,A..+], no_common_subterm(X,C) |- ([X] --> C), (Belief:StructuralDeduction, Desire:StructuralDeduction)

//NAL3 single premise inference

    ((|,X,A..+) --> M), (|,X,A..+), no_common_subterm(X,M) |- (X --> M), (Belief:StructuralDeduction, Desire:StructuralDeduction)
    (M --> (&,X,A..+)), (&,X,A..+), no_common_subterm(X,M) |- (M --> X), (Belief:StructuralDeduction, Desire:StructuralDeduction)

    ((B ~ G) --> S), S, no_common_subterm(S,B) |- (B --> S), (Belief:StructuralDeduction, Desire:StructuralDeduction)
    (R --> (B - S)), R, no_common_subterm(S,B) |- (R --> B), (Belief:StructuralDeduction, Desire:StructuralDeduction)

//// implication-based syllogism ////////////////////////////////////////////////////////////////////////////////////
//       (A ==> B) ------- (B ==> C)
//            \               /
//             \             /
//              \           /
//               \         /
//                (A ==> C)
//If after S M happens, and after M P happens, so P happens after S

    (M ==> P), (S ==> M), neq(S,P), time(dtUnionReverse) |- (S ==> P), (Belief:Deduction, Derive:AllowBackward)

//"Please note that the temporal order in the conclusion of a weak rule is
//not necessarily the same as the order in the premises, given the hypothetical
//nature of such a rule."

    (P ==> M), (S ==> M), neq(S,P), time(dtBminT) |- (S ==> P), (Belief:Induction, Derive:AllowBackward)

    (M ==> P), (M ==> S), neq(S,P), time(dtTminB) |- (S ==> P), (Belief:Abduction, Derive:AllowBackward)

    (P ==> M), (M ==> S), neq(S,P), time(dtUnion) |- (S ==> P), (Belief:Exemplification, Derive:AllowBackward)

//// implication to equivalence ////////////////////////////////////////////////////////////////////////////////////
//If when S happens, P happens, and before P happens, S has happened, then they are truth-related equivalent

    (S ==> P), (P ==> S), neq(S,P), time(dtCombine) |- (S <=> P), (Belief:Intersection, Derive:AllowBackward)

//// equivalence-based syllogism ////////////////////////////////////////////////////////////////////////////////////
//Same as for inheritance again

    (P ==> M), (S ==> M), neq(S,P), time(dtTminB) |- (S <=> P), (Belief:Comparison, Derive:AllowBackward)

    (M ==> P), (M ==> S), neq(S,P), time(dtTminB) |- (S <=> P), (Belief:Comparison, Derive:AllowBackward)

    (M ==> P), (S <=> M), neq(S,P), time(dtTminB) |- (S ==> P), (Belief:Analogy, Derive:AllowBackward)

    (P ==> M), (S <=> M), neq(S,P), time(dtTminB) |- (P ==> S), (Belief:Analogy, Derive:AllowBackward)

    (M <=> P), (S <=> M), neq(S,P), time(dtCombine) |- (S <=> P), (Belief:Resemblance, Derive:AllowBackward)

//// implication-based composition ////////////////////////////////////////////////////////////////////////////////////
//Same as for inheritance again


    (P ==> M), (S ==> M), neq(S,P), time(dtCombine) |- ((P && S) ==> M), (Belief:Union)
    (%P ==> %M), (%S ==> %M), neq(%S,%P), time(dtCombine) |- ((%P || %S) ==> %M), (Belief:Intersection)

    (M ==> P), (M ==> S), neq(S,P), time(dtCombine) |- (M ==> (P && S)), (Belief:Intersection)
    (%M ==> %P), (%M ==> %S), neq(%S,%P), time(dtCombine) |- (%M ==> (%P || %S)), (Belief:Union)

//    (D =/> R), (D =\> K), neq(R,K) |- (K =/> R), (Belief:Abduction),
//                                      (R =\> K), (Belief:Induction),
//                                      (K </> R), (Belief:Comparison)

//// implication-based decomposition ////////////////////////////////////////////////////////////////////////////////////
//Same as for inheritance again

    //TODO versions with negated S subterms

    (S ==> M), ((&&,S,A..+) ==> M), time(dtCombine) |- ((&&,A..+) ==> M), (Belief:DecomposeNegativePositivePositive)
        //(%S ==> %M), ((||,%S,A..+) ==> M), time(dtCombine) |- ((||,A..+) ==> %M), (Belief:DecomposePositiveNegativeNegative)

    (M ==> S), (M ==> (&&,S,A..+)), time(dtCombine) |- (M ==> (&&,A..+)), (Belief:DecomposePositiveNegativeNegative)
        //(%M ==> %S), (%M ==> (||,%S,A..+)), time(dtCombine) |- (%M ==> (||,A..+)), (Belief:DecomposeNegativePositivePositive)

//// conditional syllogism ////////////////////////////////////////////////////////////////////////////////////
//      + Indep variable elimination
//If after M, P usually happens, and M happens, it means P is expected to happen

//      //NAL7 specific inference ////////////////////////////////////////////////////////////////////////////////////
//      Reasoning about temporal statements. those are using the ==> relation because relation in time is a relation of the truth between statements.

    B, (A ==> C), time(decomposeBelief) |- substituteIfUnifiesIndep(C,A,B), (Belief:Deduction, Desire:Induction, Event:Anticipate)
        B, ((--,%A) ==> C), time(decomposeBelief) |- substituteIfUnifiesIndep((--,%C),A,B), (Belief:Deduction, Desire:Induction, Event:Anticipate)
    B, (C ==> A), time(decomposeBelief) |- substituteIfUnifiesIndep(C,A,B), (Belief:Abduction, Desire:Deduction)
        B, (C ==> (--,%A)), time(decomposeBelief) |- substituteIfUnifiesIndep((--,%C),A,B), (Belief:Abduction, Desire:Deduction)
    B, (A <=> C), time(decomposeBelief) |- substituteIfUnifiesIndep(C,A,B), (Belief:Analogy, Desire:Strong)
        B, ((--,%A) <=> C), time(decomposeBelief) |- substituteIfUnifiesIndep((--,%C),A,B), (Belief:Analogy, Desire:Strong)

    B, (C && A), time(decomposeBelief) |- substituteIfUnifiesIndep(C,A,B), (Desire:Strong)
        B, (C && (--,%A)), time(decomposeBelief) |- substituteIfUnifiesIndep((--,%C),A,B), (Desire:Strong)

//    M, (M ==> P), shift_occurrence_forward(unused,"==>") |- P, (Truth:Deduction, Desire:Induction, Order:ForAllSame)
//    B, (A ==> C), substitute_if_unifies("$",A,B), shift_occurrence_forward(unused,"==>") |- C, (Truth:Deduction, Order:ForAllSame)
//    X, (XI ==> B), substitute_if_unifies("$",XI,(&/,X,/0)), shift_occurrence_forward(XI,"==>") |- B, (Truth:Deduction, Desire:Induction, Order:ForAllSame)
//    (A ==> C), B, time(decomposeTask) |- substituteIfUnifiesIndep(C,A,B), (Belief:Deduction, Desire:Induction, Event:Anticipate)

//    M, (P ==> M), shift_occurrence_backward(unused,"==>") |- P, (Truth:Abduction, Desire:Deduction, Order:ForAllSame)
//    B, (C ==> A), substitute_if_unifies("$",A,B), shift_occurrence_backward(unused,"==>") |- C, (Truth:Abduction, Order:ForAllSame)
//    X, (BI ==> Y), substitute_if_unifies("$",Y,X), shift_occurrence_backward(BI,"==>") |- BI, (Truth:Abduction, Desire:Deduction, Order:ForAllSame)
    //(C ==> A), B, time(decomposeTask) |- substituteIfUnifiesIndep(C,A,B), (Belief:Abduction, Desire:Deduction)

//    M, (S <=> M), shift_occurrence_backward(unused,"<=>") |- S, (Truth:Analogy, Desire:Strong, Order:ForAllSame)
//      ?? B, (A <=> C), substitute_if_unifies("$",A,B), shift_occurrence_backward(unused,"<=>") |- C, (Truth:Deduction, Order:ForAllSame)
//      ?? B, (C <=> A), substitute_if_unifies("$",A,B), shift_occurrence_forward(unused,"<=>") |- C, (Truth:Deduction, Order:ForAllSame)
    //(A <=> C), B, time(decomposeBelief) |- substituteIfUnifiesIndep(C,A,B), (Belief:Analogy, Desire:Strong)



//// conditional composition: ////////////////////////////////////////////////////////////////////////////////////
//They are let out for AGI purpose, don't let the system generate conjunctions or useless <=> and ==> statements
//For this there needs to be a semantic dependence between both, either by the predicate or by the subject,
//or a temporal dependence which acts as special case of semantic dependence
//These cases are handled by "Variable Introduction" and "Temporal Induction"

//   P, S, no_common_subterm(S,P) |- (S ==> P), (Belief:Induction)
//   P, S, no_common_subterm(S,P) |- (S <=> P), (Belief:Comparison)
//   P, S, no_common_subterm(S,P) |- (P && S), (Belief:Intersection)
//   %P, %S, no_common_subterm(S,P) |- (%P || %S), (Belief:Union)



//// conjunction decompose AND dependent variable elimination - decomposition with elimination of a variable

     //decompose any event in a conjunction belief
     (&&,X,A..+), X, time(decomposeTaskIfTemporal) |- X, (Belief:StructuralDeduction)
        (&&,(--,%X),A..+), X, time(decomposeTaskIfTemporal) |- (--,%X), (Belief:StructuralDeduction)
     (&&,X,A..+), X, time(decomposeTaskIfTemporal) |- (&&,A..+), (Belief:StructuralDeduction)
        (&&,(--,%X),A..+), X, time(decomposeTaskIfTemporal) |- (&&,A..+), (Belief:StructuralDeduction)
     (&&,X,A..+), B, time(decomposeTask) |- substituteOnlyIfUnifiesDep((&&,A..+),X,B), (Belief:AnonymousAnalogy, Desire:Strong)
        //TODO as above

    //decompose (only) the leading event in a conjunction goal
    (&&,X,A), X, time(decomposeTaskIfTermLinkBefore), task("!") |- X, (Desire:StructuralStrong)
        (&&,(--,%X),A), X, time(decomposeTaskIfTermLinkBefore), task("!") |- (--,%X), (Desire:StructuralStrong)
    (&&,X,A), X, time(decomposeTaskIfBeliefBefore), task("!") |- A, (Desire:StructuralStrong)
        (&&,(--,%X),A), X, time(decomposeTaskIfTermLinkBefore), task("!") |- A, (Desire:StructuralStrong)
    (&&,X,A), B, time(decomposeTask), task("!")            |- substituteOnlyIfUnifiesDep(A,X,B), (Desire:Deduction)
        //TODO as above


        //TODO use ellipsis here?


//// propositional decomposition ////////////////////////////////////////////////////////////////////////////////////
//If S is the case, and (&&,S,A..+) is not the case, it can't be that (&&,A..+) is the case

    S, (&&,S,A..+), time(decomposeBelief) |- (&&,A..+), (Belief:DecomposePositiveNegativeNegative)
        //%S, (||,%S,A..+)                        |- (||,A..+), (Belief:DecomposeNegativePositivePositive)

//Additional for negation: https://groups.google.com/forum/#!topic/open-nars/g-7r0jjq2Vc

    S, (&&,(--,%S),A..+), time(decomposeBelief) |- (&&,A..+), (Belief:DecomposeNegativeNegativeNegative)
        //%S, (||,(--,%S),A..+)                        |- (||,A..+), (Belief:DecomposePositivePositivePositive)

//// multi-conditional syllogism ////////////////////////////////////////////////////////////////////////////////////
//Inference about the pre/postconditions

    Y, ((&&,X,A..+) ==> B), time(dtBeliefExact) |- substituteIfUnifiesIndep(((&&,A..+) ==> B),X,Y), (Belief:Deduction)

//conditional abduction
    ((&&,M,A..+) ==> C), ((&&,A..+) ==> C) |- M, (Belief:Abduction)
    ((&&,M,N) ==> C), (N ==> C) |- M, (Belief:Abduction)
        //TODO modify ellipsis to allow these two rules to be expressed as one:
        // ((&&,M,A..+) ==> C), (A..+ ==> C) |- M, (Belief:Abduction)
        //  which will match A..+ to a Conjunction


//Can be derived by NAL7 rules so this won't be necessary there (Order:ForAllSame left out here)

//the first rule does not have Order:ForAllSame because it would be invalid, see: https://groups.google.com/forum/#!topic/open-nars/r5UJo64Qhrk
    ((&&,A..+) ==> C), M, time(dtTask) notImplicationOrEquivalence(M) |- ((&&,M,A..+) ==> C), (Belief:Induction)

    ((&&,M,A..+) ==> C), (B ==> M), time(dtUnion) |- ((&&,B,A..+) ==> C), (Belief:Deduction)
    ((&&,B,A..+) ==> C), (B ==> M), time(dtTminB) |- ((&&,M,A..+) ==> C), (Belief:Abduction)
    ((&&,M,A..+) ==> C), ((&&,B,A..+) ==> C), time(dtBminT) |- (B ==> M), (Belief:Induction)

//// variable introduction ////////////////////////////////////////////////////////////////////////////////////
//Introduce variables by common subject or predicate

    (S --> M), (P --> M), neq(S,P), time(dtAfterOrEternalReverse) |- ((P --> $X) ==> (S --> $X)), (Belief:Abduction)
        //(S --> M), (P --> M), task(negative), neq(S,P), time(dtAfterOrEternalReverse) |- ((P --> $X) ==> (--,(S --> $X))), (Belief:AbductionN)
    (S --> M), (P --> M), neq(S,P), time(dtAfterOrEternal) |- ((S --> $X) ==> (P --> $X)), (Belief:Induction)
        //(S --> M), (P --> M), task(negative), neq(S,P), time(dtAfterOrEternal) |- ((--,(S --> $X)) ==> (P --> $X)), (Belief:InductionN)
    (S --> M), (P --> M), neq(S,P), time(dtAfterOrEternalReverse) |- ((P --> $X) <=> (S --> $X)), (Belief:Comparison)
        //(S --> M), (P --> M), task(negative), neq(S,P), time(dtAfterOrEternalReverse) |- ((P --> $X) <=> (--,(S --> $X))), (Belief:ComparisonN)
    (S --> M), (P --> M), neq(S,P), time(dtAfterOrEternal) |- (&&, (S --> #Y), (P --> #Y)), (Belief:Intersection)
        //(S --> M), (P --> M), task(negative), neq(S,P), time(dtAfterOrEternal) |- (&&, (--,(S --> #Y)), (P --> #Y)), (Belief:IntersectionN)

    (M --> S), (M --> P), neq(S,P), time(dtAfterOrEternal) |- (($X --> S) ==> ($X --> P)), (Belief:Induction)
        //(M --> S), (M --> P), task(negative), neq(S,P), time(dtAfterOrEternal) |- ((--,($X --> S)) ==> ($X --> P)), (Belief:InductionN)
    (M --> S), (M --> P), neq(S,P), time(dtAfterOrEternalReverse) |- (($X --> P) ==> ($X --> S)), (Belief:Abduction)
        //(M --> S), (M --> P), task(negative), neq(S,P), time(dtAfterOrEternalReverse) |- (($X --> P) ==> (--,($X --> S))), (Belief:AbductionN)
    (M --> S), (M --> P), neq(S,P), time(dtAfterOrEternal) |- (($X --> S) <=> ($X --> P)), (Belief:Comparison)
        //(M --> S), (M --> P), task(negative), neq(S,P), time(dtAfterOrEternal) |- ((--,($X --> S)) <=> ($X --> P)), (Belief:ComparisonN)
    (M --> S), (M --> P), neq(S,P), time(dtAfterOrEternal) |- (&&, (#Y --> P), (#Y --> S)), (Belief:Intersection)
        //(M --> S), (M --> P), task(negative), neq(S,P), time(dtAfterOrEternal) |- (&&, (#Y --> P), (--,(#Y --> S))), (Belief:IntersectionN)

////Temporal induction: ////////////////////////////////////////////////////////////////////////////////////
//When P and then S happened according to an observation, by induction (weak) it may be that alyways after P, usually S happens.

    A, B, task("."), time(dtAfter), neq(A,B), notImplicationOrEquivalence(A), notImplicationOrEquivalence(B) |- (A ==> B), (Belief:Induction)

    A, B, task("."), time(dtAfter), neq(A,B), notImplicationOrEquivalence(A), notImplicationOrEquivalence(B) |- (A <=> B), (Belief:Comparison)

    A, B, task("."), time(dtAfterReverse), neq(A,B), notImplicationOrEquivalence(A), notImplicationOrEquivalence(B) |- (B ==> A), (Belief:Abduction)

    A, B, task("."), time(dtAfter), neq(A,B), notImplicationEquivalenceOrConjunction(A), notImplicationEquivalenceOrConjunction(B) |- (A && B), (Belief:Intersection)

    //A, B,   time(dtBefore), neq(A,B), notImplicationOrEquivalence(A), notImplicationOrEquivalence(B) |- (B && A), (Desire:Intersection)



//// 2nd variable introduction ////////////////////////////////////////////////////////////////////////////////////
//, not_equal(A, (M --> S))
    (A ==> (M --> P)), (M --> S), neq(S,P), neq(A, (M --> S)), time(dtTaskExact) |- ((&&,A,($X --> S)) ==> ($X --> P)), (Belief:Induction)
    (A ==> (M --> P)), (M --> S), neq(S,P), neq(A, (M --> S)), time(dtTaskExact) |- (&&,(A ==> (#Y --> P)), (#Y --> S)), (Belief:Intersection)

    (&&,(M --> P), A..+), (M --> S), neq(S,P), time(dtTaskExact) |- (($Y --> S) ==> (&&,($Y --> P), A..+)), (Belief:Induction)
    (&&,(M --> P), A..+), (M --> S), neq(S,P), time(dtTaskExact) |- (&&,(#Y --> S), (#Y --> P), A..+), (Belief:Intersection)

    (A ==> (P --> M)), (S --> M), neq(S,P), neq(A, (S --> M)), time(dtTaskExact) |- ((&&,A,(P --> $X)) ==> (S --> $X)), (Belief:Abduction)
    (A ==> (P --> M)), (S --> M), neq(S,P), neq(A, (S --> M)), time(dtTaskExact) |- (&&,(A ==> (P --> #Y)), (S --> #Y)), (Belief:Intersection)

    (&&,(P --> M), A..+), (S --> M), neq(S,P), time(dtTaskExact) |- ((S --> $Y) ==> (&&,(P --> $Y), A..+)), (Belief:Abduction)
    (&&,(P --> M), A..+), (S --> M), neq(S,P), time(dtTaskExact) |- (&&, (S --> #Y), (P --> #Y), A..+), (Belief:Intersection)


//conditional abduction by dependent variable

    ((X --> R) ==> Z), ((&&,(#Y --> B),(#Y --> R),A..*) ==> Z), time(dtTask) |- (X --> B), (Belief:Abduction)

// conditional deduction "An inverse inference has been implemented as a form of deduction" https://code.google.com/p/open-nars/issues/detail?id=40&can=1

    (U --> L), ((&&,A..*,(#X --> L),(#X --> R)) ==> Z), time(dtBeliefExact) |- substitute(((&&,A..*,(U --> R)) ==> Z),#X,U), (Belief:Deduction)



//// second level variable handling rules ////////////////////////////////////////////////////////////////////////////////////
//second level variable elimination (termlink level2 growth needed in order for these rules to work)

    (B --> K), (&&,(#X --> L),(($Y --> K) ==> A)), time(dtBeliefExact) |- substitute((&&, (#X --> L), A), $Y,B), (Belief:Deduction)
    (B --> K), (&&,(#X --> L),(($Y --> K) ==> (&&,A..+))), time(dtBeliefExact) |- substitute((&&,(#X --> L),A..+),$Y,B), (Belief:Deduction)

    (B --> K), (($X --> L) ==> (&&,(#Y --> K),A..+)), time(dtBeliefExact) |- substitute((($X --> L) ==> (&&,A..+)),#Y,B), (Belief:AnonymousAnalogy)
    (B --> K), (($X --> L) ==> (&&,(#Y --> K),A)), time(dtBeliefExact) |- substitute((($X --> L) ==> A),#Y,B), (Belief:AnonymousAnalogy)



//precondition combiner inference rule (variable_unification6):

    ((&&,C,A..+) ==> Z), ((&&,C,B..+) ==> Z), time(dtCombine) |- ((&&,A..+) ==> (&&,B..+)), (Belief:Induction)
    ((&&,C,A..+) ==> Z), ((&&,C,B..+) ==> Z), time(dtCombine) |- ((&&,B..+) ==> (&&,A..+)), (Belief:Induction)
    (Z ==> (&&,C,A..+)), (Z ==> (&&,C,B..+)), time(dtCombine) |- ((&&,A..+) ==> (&&,B..+)), (Belief:Abduction)
    (Z ==> (&&,C,A..+)), (Z ==> (&&,C,B..+)), time(dtCombine) |- ((&&,B..+) ==> (&&,A..+)), (Belief:Abduction)


//second level variable introduction

    (Y --> L), ((Y --> S) ==> R), neq(L,S), time(dtBeliefExact) |- substitute(((&&,(#X --> L),(#X --> S)) ==> R),Y,#X), (Belief:Induction)
    (Y --> L), ((&&,(Y --> S),A..+) ==> R), neq(L,S), time(dtBeliefExact) |- substitute(((&&,(#X --> L),(#X --> S),A..+) ==> R),Y,#X), (Belief:Intersection)







//    A, B, after(_), neq(A,B), notConjunction(A), notConjunction(B),  notImplicationOrEquivalence(A), notImplicationOrEquivalence(B) |- (B && A), (Belief:Intersection)


//    P, S, after(Task,Belief), measure_time(I), notImplicationOrEquivalence(P), notImplicationOrEquivalence(S) |- ((&/,S,I) =/> P), (Belief:Induction, Eternalize:Immediate),
//                                                                                                                       (P =\> (&/,S,I)), (Belief:Abduction),
//                                                                                                                       ((&/,S,I) </> P), (Belief:Comparison)

//    P, S, after(Task,Belief), notConjunction(P), notConjunction(S),  measure_time(I), notImplicationOrEquivalence(P), notImplicationOrEquivalence(S) |- (&/,S,I,P), (Belief:Intersection)

//    P, S, concurrent(Task,Belief), notImplicationOrEquivalence(P), notImplicationOrEquivalence(S) |- (S =|> P), (Belief:Induction, Eternalize:Immediate),
//                                                                                                          (P =|> S), (Belief:Induction),
//                                                                                                           (S <|> P), (Belief:Comparison)

//    P, S, concurrent(Task,Belief), notConjunction(P), notConjunction(S), notImplicationOrEquivalence(P), notImplicationOrEquivalence(S) |- (&|,S,P), (Belief:Intersection)

////backward inference is mostly handled by the rule transformation:

//    T, B |- C, [post] =>
//          C, B, task("?") |- T, [post]
//          C, T, task("?") |- B, [post]

//here now are the backward inference rules which should really only work on backward inference:

    (A --> S), (B --> S), neq(A,B), task("?") |- (A --> B), (Punctuation:Question),
                                                 (B --> A), (Punctuation:Question)

//and the backward inference driven forward inference:

//NAL2:

    ([A] <-> [B]), (A <-> B), task("?") |- ([A] <-> [B]), (Belief:BeliefIdentity, Punctuation:Belief)
    ({A} <-> {B}), (A <-> B), task("?") |- ({A} <-> {B}), (Belief:BeliefIdentity, Punctuation:Belief)

    ([A] --> [B]), (A <-> B), task("?") |- ([A] --> [B]), (Belief:BeliefIdentity, Punctuation:Belief)
    ({A} --> {B}), (A <-> B), task("?") |- ({A} --> {B}), (Belief:BeliefIdentity, Punctuation:Belief)

//experimental:
//    ([A] <-> {B}), (A <-> B), task("?") |- ([A] <-> {B}), (Belief:BeliefIdentity, Punctuation:Belief)
//    ({A} <-> [B]), (A <-> B), task("?") |- ({A} <-> [B]), (Belief:BeliefIdentity, Punctuation:Belief)
//    ([A] --> {B}), (A <-> B), task("?") |- ([A] --> {B}), (Belief:BeliefIdentity, Punctuation:Belief)
//    ({A} --> [B]), (A <-> B), task("?") |- ({A} --> [B]), (Belief:BeliefIdentity, Punctuation:Belief)


//NAL3:

////composition on both sides of a statement:

    ((&,B,A..+) --> (&,X,A..+)), (B --> X), task("?") |- ((&,B,A..+) --> (&,X,A..+)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)
    ((|,B,A..+) --> (|,X,A..+)), (B --> X), task("?") |- ((|,B,A..+) --> (|,X,A..+)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)

    ((-,S,A) --> (-,S,B)), (B --> A), task("?") |- ((-,S,A) --> (-,S,B)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)
    ((~,S,A) --> (~,S,B)), (B --> A), task("?") |- ((~,S,A) --> (~,S,B)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)

////composition on one side of a statement:

    (W --> (|,B,A..+)), (W --> B), task("?") |- (W --> (|,B,A..+)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)
    ((&,B,A..+) --> W), (B --> W), task("?") |- ((&,B,A..+) --> W), (Belief:BeliefStructuralDeduction, Punctuation:Belief)

    (W --> (-,S,B)), (W --> B), task("?") |- (W --> (-,S,B)), (Belief:BeliefStructuralDifference, Punctuation:Belief, Derive:NoSwap)
    ((~,S,B) --> W), (B --> W), task("?") |- ((~,S,B) --> W), (Belief:BeliefStructuralDifference, Punctuation:Belief, Derive:NoSwap)

////// NAL4 - Transformations between products and images: ////////////////////////////////////////////////////////////////////////////////////
//Relations and transforming them into different representations so that arguments and the relation itself can become the subject or predicate

    (B --> (/,M, A.._=B..+, _)), M |- ((A.._=B..+) --> M), (Belief:Identity, Desire:Identity)

    ((A..B=_..+) --> M), B |- (B --> (/, M, A..B=_..+, _ )), (Belief:Identity, Desire:Identity)

    (M --> (A..B=_..+)), B |- ((\, M, A..B=_..+, _ ) --> B), (Belief:Identity, Desire:Identity)

    ((\, M, A.._=B..+, _ ) --> B), M |- (M --> (A.._=B..+)), (Belief:Identity, Desire:Identity)

//Recursion Force - TODO use varargs

  //2
//    ((A,B) --> Y), A |- ((A,B)-->((/,Y,_,B), B)), (Belief:StructuralDeduction, Desire:StructuralDeduction)
//    ((A,B) --> Y), B |- ((A,B)-->(A, (/,Y,A,_))), (Belief:StructuralDeduction, Desire:StructuralDeduction)
  //3
//    ((A,B,C) --> Y), A |- ((A,B,C)-->((/,Y, _, B, C), B, C)), (Belief:StructuralDeduction, Desire:StructuralDeduction)
//    ((A,B,C) --> Y), B |- ((A,B,C)-->(A, (/,Y, A, _, C), C)), (Belief:StructuralDeduction, Desire:StructuralDeduction)
//    ((A,B,C) --> Y), C |- ((A,B,C)-->(A, B, (/,Y, A, B, _))), (Belief:StructuralDeduction, Desire:StructuralDeduction)



////composition on both sides of a statement:

    ((B,P) <-> Z) ,(B <-> A), task("?") |- ((B,P) <-> (A,P)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)
    ((P,B) <-> Z) ,(B <-> A), task("?") |- ((P,B) <-> (P,A)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)

    ((B,P) --> Z) ,(B --> A), task("?") |- ((B,P) --> (A,P)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)
    ((P,B) --> Z) ,(B --> A), task("?") |- ((P,B) --> (P,A)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)



    ((/,N,_,A) --> Z), (B --> A), task("?") |- ((/,N,_,A) --> (/,N,_,B)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)
    ((\,N,A,_) --> Z), (N --> R), task("?") |- ((\,N,A,_) --> (\,R,A,_)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)





//Relation introduction (wastepaper experimental)
//   (A --> C), (B --> D) |- ((A,B) --> (C,D)), (Belief:Intersection)
//   (A --> C), (A --> D) |- ((A,A) --> {C,D}), (Belief:Intersection)
//   (C --> A), (D --> A) |- ({C,D} --> (A,A)), (Belief:Intersection)

//          #_#R[(A --> C) (B --> D) |- ((* A B) --> (* C D)) :post (:t/intersection)] //            ;this one cant be allowed due to control reasons:
//          #R[(A --> C) (A --> D) |- ((* A A) --> (* C D)) :post (:t/intersection)]
//         #R[(A --> C) (B --> C) |- ((* A B) --> (* C C)) :post (:t/intersection)]
//         #R[({A} --> C) (A --> D) |- ((* {A} A) --> (* C D)) :post (:t/intersection)]
//          #R[(A --> C) ({A} --> D) |- ((* A {A}) --> (* C D)) :post (:t/intersection)]
//         #R[(A --> [C]) (B --> C) |- ((* A B) --> (* [C] C)) :post (:t/intersection)]
//         #R[(A --> C) (B --> [C]) |- ((* A B) --> (* C [C])) :post (:t/intersection)]


//compound composition one premise

    (||,%B,A..+), %B, task("?") |- (||,%B,A..+), (Belief:BeliefStructuralDeduction, Punctuation:Belief)


//TODO for desire

//query-variable queston answering HACK currently this is done better in PremiseGeneration, not here. but this sort of works
//  A, B, task("?") |- substituteIfUnifiesQuery(B, A, B), (Belief:BeliefIdentity, Punctuation:Belief)



//WASTEPAPER ===

//Single product variations
//    (S), (P), neq(S,P), no_common_subterm(S,P) |- (S | P), (Belief:Union),
//                                                  (S & P), (Belief:Intersection),
//                                                  (P ~ S), (Belief:Difference)


//DeMorgan's Law - currently implemented as a reduction but possibly should be a structural rule
    //<sseehh__> it becomes more helpful when there are >2 terms, ex: (&&, --(x), --(y), --(z))
    //<sseehh__> then it can replace N negations with one
    //<sseehh__> then the compound and its opposite resolve to the same compound
    //<patham9> if then I would add it as structural rule
    //<patham9> not as "reduction"
    //<patham9> meaning the system has free choice about the representation
    //<patham9> should have
    //<sseehh__> thats possible
    //<patham9> and I wouldnt apply StructuralDeduction as truth
