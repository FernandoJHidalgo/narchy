
//// Revision ////////////////////////////////////////////////////////////////////////////////////
// When a given belief is challenged by new experience, a new belief2 with same content (and disjoint evidental base),
// a new revised task, which sums up the evidence of both belief and belief2 is derived:

//   A, A |- A, (Belief:Revision) (Commented out because it is already handled by belief management in java)


//// Immediate Inference ////////////////////////////////////////////////////////////////////////////////////

//  --A,   A, task("?") |- --A, (Belief:BeliefNegation, Punctuation:Judgment)
//    A, --A, task("?") |-   A, (Belief:BeliefNegation, Punctuation:Judgment)

//A belief b <f,c> is equal to --b <1-f,c>, which is the negation rule:

//    A, A, task(negative) |- --A, (Belief:Negation, Desire:Negation)
//    --A, A, task(positive) |- A, (Belief:Negation, Desire:Negation)

//    (A-->B), (A-->B), task(negative) |- (--,(A --> B)), (Belief:Negation, Desire:Negation)
//    (A --> B), A, task(negative) |- --(A --> B), (Belief:Negation, Desire:Negation, Derive:AllowBackward)
//    (A --> B), B, task(negative) |- --(A --> B), (Belief:Negation, Desire:Negation, Derive:AllowBackward)

//  --(A --> B), A |-   (A --> B), (Belief:Negation, Desire:Negation, Derive:AllowBackward)
//  --(A --> B), B |-   (A --> B), (Belief:Negation, Desire:Negation, Derive:AllowBackward)

//    (A <-> B), A, task(negative) |- --(A <-> B), (Belief:Negation, Desire:Negation, Derive:AllowBackward)
// --(A <-> B), A |-   (A <-> B), (Belief:Negation, Desire:Negation, Derive:AllowBackward)


//Product negation TODO use var arg:
//    (A), A, task(negative) |- (--, (A)), (Belief:Negation, Desire:Negation, Derive:AllowBackward)
//    (--, (A)), A |- (A), (Belief:Negation, Desire:Negation, Derive:AllowBackward)
