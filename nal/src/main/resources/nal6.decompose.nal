//conjunction/disjunction structural decomposition

  //Conjunction structural decompose: C = (&&,a,b,..)
    C, X, eventOf(C,X)                        |-   conjWithout(C,X), (Belief:StructuralDeduction)
//    C, X, eventOf(C,X)                        |-   X, (Belief:StructuralDeduction, Time:TaskSubEvent)
    C, X, eventOfNeg(C,X)                     |-   conjWithout(C,--X), (Belief:StructuralDeduction)
//    C, X, eventOfNeg(C,X)                     |- --X, (Belief:StructuralDeduction, Time:TaskSubEvent)

      C, X, eventFirstOf(C,X)    |-   X, (  Goal:StructuralDeduction)
       D, X, eventOfNeg(C,X), conjParallel(D)   |-   --conjWithout(D,--X), (  Goal:StructuralDeductionN)
        //C, X, eventOf(C,X), conjParallel(C)                  |-   conjWithout(C,X), (  Goal:StructuralDeduction)
      C, X, eventFirstOfNeg(C,X)    |- --X, (  Goal:StructuralDeduction)
       D, X, eventOf(C,X), conjParallel(D)      |-   --conjWithout(D,X), (  Goal:StructuralDeductionN)
        //C, X, eventOfNeg(C,X), conjParallel(C)               |-   conjWithout(C,--X), (  Goal:StructuralDeduction)



//// propositional decomposition ////////////////////////////////////////////////////////////////////////////////////
//If S is the case, and (&&,S,A..+) is not the case, it can't be that (&&,A..+) is the case

    //CONJ
    S, C, eventOf(C,S), conjParallel(C)    |-   conjWithout(C,  S), (Belief:DecomposePP)
    S, C, eventOfNeg(C,S), conjParallel(C) |-   conjWithout(C,--S), (Belief:DecomposeNP)

    //DISJ
    S, D, eventOfNeg(D,S), conjParallel(D) |-   --conjWithout(D,--S), (Belief:DecomposeNN)
    S, D, eventOf(D,S), conjParallel(D)    |-   --conjWithout(D,  S), (Belief:DecomposePN)

    //conditional disjunction goal decompose (alternate suppress by belief)
    D, X, eventOf(D,X), conjParallel(D)      |- --conjWithout(D,  X), (Goal:DesireNP)
    D, X, eventOfNeg(D,X), conjParallel(D)   |- --conjWithout(D,--X), (Goal:DesireNN)

    //conditional goal disjunction decompose (alternate suppress by goal)
    G, D, eventOf(D,G), conjParallel(D)      |- --conjWithout(D,  G), (Goal:DesireWeakPN)
    G, D, eventOfNeg(D,G), conjParallel(D)   |- --conjWithout(D,--G), (Goal:DesireWeakNN)



//    //goal/antigoal in sequence
//    X, C, eventOf(C,X), --eventOfNeg(C,X)   |- C, (Goal:DesireWeak, Time:BeliefAtTask)
//      //X, C, eventOfNeg(C,X), --eventOf(C,X)   |- --C, (Goal:Deduction, Time:BeliefAtTask)
//    X, C, eventOfNeg(C,X), --eventOf(C,X)   |- C, (Goal:DesireWeakN, Time:BeliefAtTask)
//      //X, C, eventOf(C,X), --eventOfNeg(C,X)   |- --C, (Goal:DeductionN, Time:BeliefAtTask)

    //X, C, eventOfNeg(C,X) |- --conjWithout(C,--X), (Goal:DesireWeak, Time:BeliefSubSequence)
    //X, C, eventOf(C,X)    |- --conjWithout(C,X), (Goal:DesireWeakN, Time:BeliefSubSequence)


    //see: https://en.wikipedia.org/wiki/Imperative_logic#Ross.27_Paradox


    //X is the desired event suffix (outcome).
    //C is a sequence ending in it.  this forms a goal of the sequence minus the trailing
    //TODO X, C    |- conjDropIfLatestUnifies(C,  X), (Goal:Deduction,..
    X, C, eventLastOf(C,X), --eventOfNeg(C,X)       |-   conjDropIfLatest(C,X),     (Goal:Desire)
    //G, C                                            |-   unify

      //even though it has the opposite goal earlier in the seq, but desire weakly:
      X, C, eventLastOf(C,X), eventOfNeg(C,X)       |-   conjDropIfLatest(C,X),     (Goal:DesireWeak)

//    //probably redundant, unless Deduction is used instead of Desire due to polarity balance
//      //X, C, eventLastOfNeg(C,X),--eventOf(C,X)      |-   --negateEvents(conjDropIfLatest(C,--X)), (Goal:DesireWeak,Time:TaskLastInBeliefNeg)
//      X, C, eventLastOfNeg(C,X),--eventOf(C,X)      |- --conjDropIfLatest(C,--X), (Goal:DesireWeak)
//      X, C, eventLastOfNeg(C,X),--eventOf(C,X)      |- --C, (Goal:DesireWeak)

    X, C, eventLastOfNeg(C,X), --eventOf(C,X)       |-   conjDropIfLatest(C,--X),   (Goal:DesireN)

      //even though it has the opposite goal earlier in the seq, but desire weakly:
      X, C, eventLastOfNeg(C,X), eventOf(C,X)       |-   conjDropIfLatest(C,--X),   (Goal:DesireWeakN)

//    //probably redundant, unless Deduction is used instead of Desire due to polarity balance
//      //X, C, eventLastOf(C,X), --eventOfNeg(C,X)     |-   --negateEvents(conjDropIfLatest(C,X)), (Goal:DesireWeak, Time:TaskLastInBeliefNeg)
//      X, C, eventLastOf(C,X), --eventOfNeg(C,X)      |- --conjDropIfLatest(C,X),   (Goal:DesireWeakN)
//      X, C, eventLastOf(C,X), --eventOfNeg(C,X)      |- --C, (Goal:DesireWeakN)

    //negate events of anti-conj goal
    //C, X, eventOf(C,X) |- negateEvents(conjWithoutAll(C, X)), (Goal: StructuralDeductionN)

    //  filters to prevent deriving anti-goal if it appears in the precondition, was called: "conjDropIfLatestFiltered"
    //X, C, eventLastOf(C,X)    |- conjWithoutAll(C,  X), (Goal:Deduction,Time:TaskLastInBeliefPos)


    //TODO conjunction sequence suffix
    //TODO nal3 shortcut - decompose trailing intersection/union event

    //TODO conjunction sequence prefix

    C, X, eventFirstOf(C,X)      |- conjDropIfEarliest(C,  X), (Belief:Deduction,Goal:Deduction)
    C, X, eventFirstOfNeg(C,X)   |- conjDropIfEarliest(C,--X), (Belief:DeductionPN,Goal:DeductionPN)








//Anonymous Deduction and Abduction
    X, (V ==> X), task("?"), is(V,"#"), --isVar(X)      |- X, (Belief:BeliefStructuralReduction)
    X, (--V ==> X), task("?"), is(V,"#"), --isVar(X)    |- X, (Belief:BeliefStructuralReduction)

        X, (X ==> V), task("?"), is(V,"#"), --isVar(X)      |- X,   (Belief:BeliefStructuralAbduction)
        X, (--X ==> V), task("?"), is(V,"#"), --isVar(X)    |- --X, (Belief:BeliefStructuralAbduction)


//// implication-based decomposition ////////////////////////////////////////////////////////////////////////////////////

// Original:
//    (S ==> M), ((&&,S,A_1..n) ==> M) |- ((&&,A_1..n) ==> M), (Truth:DecomposeNegativePositivePositive, Order:ForAllSame, SequenceIntervals:FromBelief)
//    (S ==> M), ((||,S,A_1..n) ==> M) |- ((||,A_1..n) ==> M), (Truth:DecomposePositiveNegativeNegative, Order:ForAllSame)
//    (M ==> S), (M ==> (&&,S,A_1..n)) |- (M ==> (&&,A_1..n)), (Truth:DecomposePositiveNegativeNegative, Order:ForAllSame, SequenceIntervals:FromBelief)
//    (M ==> S), (M ==> (||,S,A_1..n)) |- (M ==> (||,A_1..n)), (Truth:DecomposeNegativePositivePositive, Order:ForAllSame)

//conditional implication decomposition
    (  S ==> M), (C ==> M), eventsOf(C,S) |- (conjWithoutAll(C,  S) ==> M), (Belief:DecomposeNP)
    (--S ==> M), (C ==> M), eventOfNeg(C,S) |- (conjWithout(C,--S) ==> M), (Belief:DecomposeNP)
        //TODO disj

    (M ==> S), (M ==> C), eventsOf(C,S)    |-   (M ==> conjWithoutAll(C,S)),   (Belief:DecomposePN)
    (M ==> S), (M ==> C), eventOfNeg(C,S) |-   (M ==> conjWithout(C,--S)), (Belief:DecomposeNN)
        //TODO disj

//free implication question decomposition
  (A ==> C), A, task("?"), is(C,"&&"), --isVar(A)       |- (A ==> dropAnyEvent(C)), (Punctuation:Question)
  (C ==> A), A, task("?"), isUnneg(C,"&&"), --isVar(A)  |- (dropAnyEvent(C) ==> A), (Punctuation:Question)
    //not needed: (--C ==>A) since dropAnyEvent handles --C

//free implication belief decomposition
    //pred
    (A ==> C), X, eventOf(C,X), is(C,"&&"), --isVar(A)      |- (A ==> without(C,  X)), (Belief:StructuralReduction)
    (A ==> C), X, eventOfNeg(C,X), is(C,"&&"), --isVar(A)   |- (A ==> without(C,--X)), (Belief:StructuralReduction)

    //disj subj ONLY:
    //(--C ==> A), A, is(C,"&&"), --isVar(A)    |- (--dropAnyEvent(C) ==> A), (Belief:StructuralReduction)

//dangerous?
//(C ==> A), A, isUnneg(C,"&&"), --isVar(A) |- (dropAnyEvent(C) ==> A), (Belief:StructuralReduction)
  //not needed: (--C ==>A) since dropAnyEvent handles --C


C, Y, is(C,"&&"), neq(C,Y), --isVar(Y)  |- unisubst(C,chooseUnifiableSubEvent(C,Y),Y,strict), (Belief:Analogy,Goal:Analogy)
C, Y, is(C,"&&"), neq(C,Y), --isVar(Y)  |- unisubst(C,chooseUnifiableSubEvent(C,--Y),--Y,strict), (Belief:AnalogyPN,Goal:AnalogyPN)

//Anonymous Analogy (NAL5)
    //originally this only unified depvar (dep var elimination)
    (&&,X,A..+), Y   |- unisubst((&&,A..+),X,Y,"#"), (Belief:AnonymousAnalogy)
      //accelerated version requiring no second-level unification and allows the general case unisubst to be 'strict'
      //C, X, eventOf(C,X)    |- conjWithout(C,X), (Belief:AnonymousAnalogy)
    (&&,--X,A..+), Y   |- unisubst((&&,A..+),X,Y,"#"), (Belief:AnonymousAnalogyPN)
      //accelerated version requiring no second-level unification and allows the general case unisubst to be 'strict'
      //C, X, eventOfNeg(C,X) |- conjWithout(C,--X), (Belief:AnonymousAnalogyPN)

//    Y, (&&,X,A..+)                  |- unisubst((&&,  X,A..+),X,Y,"#",strict), (Belief:Deduction)
//    Y, (&&,--X,A..+)                |- unisubst((&&,--X,A..+),X,Y,"#",strict), (Belief:DeductionN)
//        Y, (&&,X,A..+), task("?")       |- unisubst((&&,  X,A..+),X,Y,"#",strict), (Punctuation:Question)
//        Y, (&&,--X,A..+), task("?")     |- unisubst((&&,--X,A..+),X,Y,"#",strict), (Punctuation:Question)
//        Y, (&&,X,A..+), task("@")       |- unisubst((&&,  X,A..+),X,Y,"#",strict), (Punctuation:Quest)
//        Y, (&&,--X,A..+), task("@")     |- unisubst((&&,--X,A..+),X,Y,"#",strict), (Punctuation:Quest)


          //Disjunction structural decompose: D = (||,a,b,..) = --(&&,--a, --b, ..)
          //   disabled: may be spam-like
            //D, X,conjParallel(D),  eventOfNeg(D,X)  |- --conjWithout(D,--X), (Belief:StructuralDeductionWeakN, Goal:StructuralDeductionWeakN)
            //D, X,conjParallel(D),  eventOf(D,X)     |- --conjWithout(D,X), (Belief:StructuralDeductionWeakN, Goal:StructuralDeductionWeakN)

    //D, X, --is(X,"#"),                     eventOf(D,X)     |- --X,  (Belief:StructuralDeductionWeakN, Time:TaskSubEventPos)
    //D, X, --is(X,"#"),conjParallel(D), eventOf(D,X)     |- --X,  (  Goal:StructuralDeductionWeakN, Time:TaskSubEventPos)
    //D, X, --is(X,"#"),                     eventOfNeg(D,X)  |-   X,  (Belief:StructuralDeductionWeakN, Time:TaskSubEventNeg)
    //D, X, --is(X,"#"),conjParallel(D), eventOfNeg(D,X)  |-   X,  (  Goal:StructuralDeductionWeakN, Time:TaskSubEventNeg)
