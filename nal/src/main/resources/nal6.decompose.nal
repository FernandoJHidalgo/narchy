//conjunction/disjunction structural decomposition

  //Conjunction structural decompose: C = (&&,a,b,..)
    C, X, eventOf(C,X)                                     |-   conjWithout(C,X), (Belief:StructuralDeduction, Time:TaskSubSequence)
    C, X, eventOf(C,X)                                     |-   X, (Belief:StructuralDeduction, Time:TaskSubEventPos)
    C, X, eventOf(C,X),    conjParallel(C), --is(X,"#")    |-   X, (  Goal:StructuralDeduction, Time:TaskSubEventPos)
    C, X, eventOfNeg(C,X)                                  |-   conjWithout(C,--X), (Belief:StructuralDeduction, Time:TaskSubSequence)
    C, X, eventOfNeg(C,X)                                  |- --X, (Belief:StructuralDeduction, Time:TaskSubEventNeg)
    C, X, eventOfNeg(C,X), conjParallel(C), --is(X,"#")    |- --X, (  Goal:StructuralDeduction, Time:TaskSubEventNeg)


    //antigoal in sequence
    X, C, eventOfNeg(C,X) |- --C, (Goal:DesireWeak, Time:Task)
    //X, C, eventOfNeg(C,X) |- --conjWithout(C,--X), (Goal:DesireWeak, Time:BeliefSubSequence)
    X, C, eventOf(C,X)    |- --C, (Goal:DesireWeakN, Time:Task)
    //X, C, eventOf(C,X)    |- --conjWithout(C,X), (Goal:DesireWeakN, Time:BeliefSubSequence)

    //D, X, --is(X,"#"),                     eventOf(D,X)     |- --X,  (Belief:StructuralDeductionWeakN, Time:TaskSubEventPos)
    //D, X, --is(X,"#"),conjParallel(D), eventOf(D,X)     |- --X,  (  Goal:StructuralDeductionWeakN, Time:TaskSubEventPos)
    //D, X, --is(X,"#"),                     eventOfNeg(D,X)  |-   X,  (Belief:StructuralDeductionWeakN, Time:TaskSubEventNeg)
    //D, X, --is(X,"#"),conjParallel(D), eventOfNeg(D,X)  |-   X,  (  Goal:StructuralDeductionWeakN, Time:TaskSubEventNeg)



    //see: https://en.wikipedia.org/wiki/Imperative_logic#Ross.27_Paradox


    //X is the desired outcome. C is a sequence ending in it.  this forms a goal of the sequence minus the trailing
    //  filters to prevent deriving anti-goal if it appears in the precondition, was called: "conjDropIfLatestFiltered"
    X, C, eventLastOf(C,X)    |- conjDropIfLatest(C,  X), (Goal:Deduction,Time:TaskInBelief)
      //TODO X, C    |- conjDropIfLatestUnifies(C,  X), (Goal:Deduction,Time:TaskInBelief)
    X, C, eventLastOfNeg(C,X) |- conjDropIfLatest(C,--X), (Goal:DeductionN,Time:TaskInBelief)

    C, X, eventFirstOf(C,X)    |- conjDropIfEarliest(C,  X), (Belief:Deduction,Goal:Deduction,Time:BeliefInTask)
    C, X, eventFirstOfNeg(C,X) |- conjDropIfEarliest(C,--X), (Belief:DeductionPN,Goal:DeductionPN,Time:BeliefInTask)

    //conditional disjunction decompose
    D, X, eventOfNeg(D,X) |- --conjWithout(D,--X), (Goal:DeductionNN,Time:BeliefInTask)
    D, X, eventOf(D,X)    |- --conjWithout(D,  X), (Goal:DeductionNP,Time:BeliefInTask)



          //Disjunction structural decompose: D = (||,a,b,..) = --(&&,--a, --b, ..)
          //   disabled: may be spam-like
            //D, X,conjParallel(D),  eventOfNeg(D,X)  |- --conjWithout(D,--X), (Belief:StructuralDeductionWeakN, Goal:StructuralDeductionWeakN)
            //D, X,conjParallel(D),  eventOf(D,X)     |- --conjWithout(D,X), (Belief:StructuralDeductionWeakN, Goal:StructuralDeductionWeakN)


//// implication-based decomposition ////////////////////////////////////////////////////////////////////////////////////
//Same as for inheritance again


    (S ==> M), (C ==> M), eventOf(C,S) |- (conjWithout(C,S) ==> M), (Belief:DecomposeNegativePositivePositive)
    (--S ==> M), (C ==> M), eventOfNeg(C,S) |- (conjWithout(C,--S) ==> M), (Belief:DecomposeNegativePositivePositive)
        //(S ==> M), ((&&,(--,%S),A..+) ==> M) |- ((&&,A..+) ==> M), (Belief:DecomposeNegativePositivePositiveN)
        //(S ==> M), ((||,S,A..+) ==> M) |- ((||,A..+) ==> M), (Belief:DecomposePositiveNegativeNegative)

    (M ==> S), (M ==> C), eventOf(C,S) |- (M ==> conjWithout(C,S)), (Belief:DecomposePositiveNegativeNegative)
    (M ==> S), (M ==> C), eventOfNeg(C,S) |- (M ==> conjWithout(C,--S)), (Belief:DecomposePositiveNegativeNegativeN)
        //(M ==> S), (M ==> (&&,(--,%S),A..+)) |- (M ==> (&&,A..+)), (Belief:DecomposePositiveNegativeNegativeN)
        //(M ==> S), (M ==> (||,S,A..+)) |- (M ==> (||,A..+)), (Belief:DecomposeNegativePositivePositive)


    //TODO disjunction decompose
    (M ==> C), M, is(C,"&&") |- (M ==> dropAnyEvent(C)), (Belief:StructuralReduction)
     //(M ==> C), X, eventOf(C,X) |- (M ==> conjWithout(C,X)), (Belief:StructuralReduction)
      //(M ==> C), X, eventOf(C,X) |- (M ==> X), (Belief:StructuralReduction)
     //(M ==> C), X, eventOfNeg(C,X) |- (M ==> conjWithout(C,--X)), (Belief:StructuralReduction)
      //(M ==> C), X, eventOfNeg(C,X) |- (M ==> --X), (Belief:StructuralReduction)
         //(M ==> C), X, eventOfPosOrNeg(C,X) |- (M ==> conjWithoutPosOrNeg(C,X)), (Belief:StructuralReduction)

    (C ==> M), X, is(C,"&&") |- (dropAnyEvent(C) ==> M), (Belief:StructuralReduction)
     //(C ==> M), X, eventOf(C,X) |- (conjWithout(C,X) ==> M), (Belief:StructuralReduction)
      //(C ==> M), X, eventOf(C,X) |- (X ==> M), (Belief:StructuralReduction)
     //(C ==> M), X, eventOfNeg(C,X) |- (conjWithout(C,--X) ==> M), (Belief:StructuralReduction)
      //(C ==> M), X, eventOfNeg(C,X) |- (--X ==> M), (Belief:StructuralReduction)
         //(C ==> M), X, eventOfPosOrNeg(C,X) |- (conjWithoutPosOrNeg(C,X) ==> M), (Belief:StructuralReduction)

    (--C ==> M), X, is(C,"&&") |- (--dropAnyEvent(C) ==> M), (Belief:StructuralReduction)
     //(--C ==> M), X, eventOf(C,X) |- (--conjWithout(C,X) ==> M), (Belief:StructuralReduction)
      //(--C ==> M), X, eventOf(C,X) |- (--X ==> M), (Belief:StructuralReduction)
     //(--C ==> M), X, eventOfNeg(C,X) |- (--conjWithout(C,--X) ==> M), (Belief:StructuralReduction)
      //(--C ==> M), X, eventOfNeg(C,X) |- (X ==> M), (Belief:StructuralReduction)
         //(--C ==> M), X, eventOfPosOrNeg(C,X) |- (--conjWithoutPosOrNeg(C,X) ==> M), (Belief:StructuralReduction)

            //(M ==> C), X, task("?"), eventOfPosOrNeg(C,X) |- (M ==> conjWithoutPosOrNeg(C,X)), (Punctuation:Question)
        //(M ==> C), X, eventOfNeg(C,X) |- (M ==> conjWithout(C,--X)), (Belief:StructuralReduction)
            //(M ==> C), X, task("?"), eventOfNeg(C,X) |- (M ==> conjWithout(C,--X)), (Punctuation:Question)
    //(M ==> C), C, is(C,"&&") |- (--,(M ==> dropAnyEvent(C))), (Belief:StructuralReductionN)
          //(M ==> C), D, belief("&&") |- (M ==> subIfUnifiesAny(dropAnyEvent(C), same, D)), (Belief:StructuralDeduction)
        //(--M ==> C), C, belief("&&") |- (--M ==> dropAnyEvent(C)), (Belief:StructuralDeduction)
          //(--M ==> C), D, belief("&&") |- (--M ==> subIfUnifiesAny(dropAnyEvent(C), same, D, strict)), (Belief:StructuralDeduction)
        //(M ==> (&&,(--,%S),A..+)), M |- (M ==> (&&,A..+)), (Belief:StructuralDeduction)
            //(C ==> M), X, task("?"), eventOfPosOrNeg(C,X) |- (conjWithoutPosOrNeg(C,X) ==> M), (Punctuation:Question)
        //(C ==> M), X, eventOfNeg(C,X) |- (conjWithout(C,--X) ==> M), (Belief:StructuralReduction)
            //(C ==> M), X, task("?"), eventOfNeg(C,X) |- (conjWithout(C,--X) ==> M), (Punctuation:Question)
            //(--C ==> M), X, task("?"), eventOfPosOrNeg(C,X) |- (--conjWithoutPosOrNeg(C,X) ==> M), (Punctuation:Question)
        //(--C ==> M), X, eventOfNeg(C,X) |- ((--,conjWithout(C,--X)) ==> M), (Belief:StructuralReduction)
            //(--C ==> M), X, task("?"), eventOfNeg(C,X) |- ((--,conjWithout(C,--X)) ==> M), (Punctuation:Question)


          //(C ==> M), D, belief("&&") |- (subIfUnifiesAny(dropAnyEvent(C), same, D) ==> M), (Belief:StructuralDeduction)
        //(C ==> --M), C, belief("&&") |- (dropAnyEvent(C) ==> --M), (Belief:StructuralDeduction)
          //(C ==> --M), D, belief("&&") |- (subIfUnifiesAny(dropAnyEvent(C), same, D, strict) ==> --M), (Belief:StructuralDeduction)
                //((&&,(--,%S),A..+) ==> M), M |- ((&&,A..+) ==> M), (Belief:StructuralDeduction)


