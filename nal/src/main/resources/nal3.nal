//// inheritance composition ////////////////////////////////////////////////////////////////////////////////////
//If P and S are in the intension/extension of M, then union/difference and intersection can be built:
//The duality of extension and intension in NAL corresponds to the
//  duality of intersection and union in set theory â€” intensional intersection
//  corresponds to extensional union, and extensional intersection corresponds
//  to intensional union.

    (P --> M), (S --> M), notSet(S), notSet(P), neqRCom(S,P) |- ((P | S) --> M), (Belief:Intersection, Time:Intersect)
    (P --> M), (S --> M), notSet(S), notSet(P), neqRCom(S,P) |- ((P & S) --> M), (Belief:Union, Time:Intersect)

    (M --> P), (M --> S), notSet(S), notSet(P), neqRCom(S,P) |- (M --> (P & S)), (Belief:Intersection, Time:Intersect)
    (M --> P), (M --> S), notSet(S), notSet(P), neqRCom(S,P) |- (M --> (P | S)), (Belief:Union, Time:Intersect)

    (P --> M), (S --> M), notSet(S), notSet(P), neqRCom(S,P) |- ((P ~ S) --> M), (Belief:Difference, Time:Intersect)
    (P --> M), (S --> M), notSet(S), notSet(P), neqRCom(S,P) |- ((S ~ P) --> M), (Belief:DifferenceReverse, Time:Intersect)

    (M --> P), (M --> S), notSet(S), notSet(P), neqRCom(S,P) |- (M --> (P - S)), (Belief:Difference, Time:Intersect)
    (M --> P), (M --> S), notSet(S), notSet(P), neqRCom(S,P) |- (M --> (S - P)), (Belief:DifferenceReverse, Time:Intersect)

        //(P --> M), (S --> M), is(P,"+"), is(S,"+") |- (differ(P,S) --> M), (Belief:Difference)
        //((A,B) --> M), ((X,Y) --> M), is(A,"+"), is(B,"+"), is(X,"+"), is(Y,"+") |- ((intersect(A,X),intersect(B,Y)) --> M), (Belief:Intersection)
        //((A,B) --> M), ((X,Y) --> M), is(A,"+"), is(B,"+"), is(X,"+"), is(Y,"+") |- ((union(A,X),union(B,Y)) --> M), (Belief:Union)


//// inheritance decomposition ////////////////////////////////////////////////////////////////////////////////////
//if (S --> M) is the case, and ((|,S,A..+) --> M) is not the case, then ((|,A..+) --> M) is not the case, hence Belief:DecomposePositiveNegativeNegative
//TODO maybe X-S should work like set difference, not 'without(' current semantics
     (X --> M), (S --> M), is(S,"|"), subOf(S,X) |- --(without(S,X) --> M), (Belief:DecomposePN)
         //(X-->M), (S --> N), is(S,"|"), subOf(S,X), neq(M,N) |- subIfUnifiesAny((without(S,X) --> N), N, M), (Belief:DecomposePositiveNegativeNegative)
     (X --> M), (S --> M), is(S,"&"), subOf(S,X) |- (without(S,X) --> M), (Belief:DecomposeNP)
         //(X-->M), (S --> N), is(S,"&"), subOf(S,X), neq(M,N) |- subIfUnifiesAny((without(S,X) --> N), N, M), (Belief:DecomposeNegativePositivePositive)

     (M --> X), (M --> S), is(S,"&"), subOf(S,X) |- --(M --> without(S,X)), (Belief:DecomposePN)
        //(M --> X), (N --> S), is(S,"&"), subOf(S,X), neq(M,N) |- subIfUnifiesAny((N --> without(S,X)), N, M), (Belief:DecomposePositiveNegativeNegative)
     (M --> X), (M --> S), is(S,"|"), subOf(S,X) |- (M --> without(S,X)), (Belief:DecomposeNP)
        //(M --> X), (N --> S), is(S,"|"), subOf(S,X), neq(M,N) |- subIfUnifiesAny((N --> without(S,X)), N, M), (Belief:DecomposeNegativePositivePositive)

     //DIFFi
     (M --> S), (M --> (S - P)) |- (M --> P), (Belief:DecomposeDiffX)
     (M --> P), (M --> (S - P)) |- (M --> S), (Belief:DecomposeDiffX)
//        (M --> S), (M --> (S - P)) |- --(M --> P), (Belief:DecomposePP)
//        (M --> P), (M --> (S - P)) |- (M --> S), (Belief:DecomposeNP)

     //DIFFe
     (S --> M), ((S ~ P) --> M) |- (P --> M), (Belief:DecomposeDiffX)
     (P --> M), ((S ~ P) --> M) |- (S --> M), (Belief:DecomposeDiffX)
//        (S --> M), ((S ~ P) --> M) |- --(P --> M), (Belief:DecomposePP)
//        (P --> M), ((S ~ P) --> M) |- (S --> M), (Belief:DecomposeNP)

    //Raw DIFFe
    S, (S ~ P) |- P, (Belief:DecomposeDiffX)
    P, (S ~ P) |- S, (Belief:DecomposeDiffX)
//        S, (S ~ P) |- --P, (Belief:DecomposePP)
//        P, (S ~ P) |- S, (Belief:DecomposeNP)

     //similarity (S==P)! (symmetric: DecomposeNegative....)
     ((S ~ P) --> M), (S --> M) |- (P --> M), (Goal:DecomposeDiff)
     (M --> (S - P)), (M --> S) |- (M --> P), (Goal:DecomposeDiff)
     (S ~ P),         S         |- P,         (Goal:DecomposeDiff)
        ((S ~ P) --> M), (P --> M) |- (S --> M), (Goal:DecomposeDiff)
        (M --> (S - P)), (M --> P) |- (M --> S), (Goal:DecomposeDiff)
        (S ~ P),         P         |- S,         (Goal:DecomposeDiff)

     //difference --(S==P)! (asymmetric: DecomposePositive... )
     ((S ~ P) --> M), (S --> M) |- --(P --> M), (Goal:DecomposePP)
     (M --> (S - P)), (M --> S) |- --(M --> P), (Goal:DecomposePP)
     (S ~ P),         S         |- --P,         (Goal:DecomposePP)
        ((S ~ P) --> M), (P --> M) |- (S --> M), (Goal:DecomposePN)
        (M --> (S - P)), (M --> P) |- (M --> S), (Goal:DecomposePN)
        (S ~ P),         P         |- S,         (Goal:DecomposePN)



     //intersection conditional goal decompose
     ((|,P,S,A..*) --> M), (S --> M) |- (P --> M), (Goal:DecomposePP)
     ((&,P,S,A..*) --> M), (S --> M) |- (P --> M), (Goal:DecomposePN)
     (M --> (&,P,S,A..*)), (M --> S) |- (M --> P), (Goal:DecomposePP)
     (M --> (|,P,S,A..*)), (M --> S) |- (M --> P), (Goal:DecomposePN)


//intesection question formation
    (W --> S), (W --> B), task("?"), is(S,"|"), neqRCom(S,B) |- (W --> (|,S,B)), (Punctuation:Question)
    (W --> S), (W --> B), task("?"), is(S,"&"), neqRCom(S,B) |- (W --> (&,S,B)), (Punctuation:Question)
    (S --> W), (B --> W), task("?"), is(S,"&"), neqRCom(S,B) |- ((&,S,B) --> W), (Punctuation:Question)
    (S --> W), (B --> W), task("?"), is(S,"|"), neqRCom(S,B) |- ((|,S,B) --> W), (Punctuation:Question)

//NAL3 single premise decompose
    (M --> S), X, is(S,"&"), subOf(S,X) |- (M --> without(S,X)), (Belief:StructuralDeduction, Goal:StructuralDeduction)
        //(M --> S), X, is(S,"&"), subOfNeg(S,X) |- (M --> without(S,--X)), (Belief:StructuralDeduction, Goal:StructuralDeduction)

    (S --> M), X, is(S,"|"), subOf(S,X) |- (without(S,X) --> M), (Belief:StructuralDeduction, Goal:StructuralDeduction)
        //(S --> M), X, is(S,"|"), subOfNeg(S,X) |- (without(S,--X) --> M), (Belief:StructuralDeduction, Goal:StructuralDeduction)

    (S --> (B - G)), B |- (S --> B), (Belief:StructuralDeduction)
        (S --> (B - G)), G |- --(S --> G), (Belief:StructuralDeduction)

    ((B ~ G) --> S), B |- (B --> S), (Belief:StructuralDeduction)
        ((B ~ G) --> S), G |- --(G --> S), (Belief:StructuralDeduction)

        (B ~ G), B |- B, (Belief:StructuralDeduction)
            (B ~ G), G |- --G, (Belief:StructuralDeduction)


        //if want X > Y ie. (X ~ Y), then to the extent that X == Y, decrease Y while increasing X
        //S:(X ~ Y), S:(X ~ Y), task("!") |- (S:X && (--,S:Y)), (Goal:WeakPN)
        //(X - Y):S, (X - Y):S, task("!") |- (X:S && (--,Y:S)), (Goal:WeakPN)
        //(X ~ Y), (X ~ Y), task("!") |- (X && --Y), (Goal:WeakPN)

        //if want X == Y ie. --(X ~ Y), then to the extent that X > Y, increase Y while decreasing X
        //S:(X ~ Y), S:(X ~ Y), task("!") |- (S:Y && (--,S:X)), (Goal:WeakN)
        //(X - Y):S, (X - Y):S, task("!") |- (Y:S && (--,X:S)), (Goal:WeakN)
        //(X ~ Y), (X ~ Y), task("!") |- (Y && --X), (Goal:WeakN)


        //1D:
        //(X --> C), (X --> C), is(X,"+") |- (dropAnySet(X) --> C), (Belief:StructuralDeduction, Goal:StructuralDeduction)
            //(Y --> M), (X --> M), is(Y,"+"), is(X,"+") |- (differ(Y,X) --> M), (Belief:StructuralDeduction, Goal:StructuralDeduction)

        //2D:
        //((X,Y) --> C), ((X,Y) --> C), is(X,"+") |- ((dropAnySet(X),Y) --> C), (Belief:StructuralDeduction, Goal:StructuralDeduction)
        //((X,Y) --> C), ((X,Y) --> C), is(Y,"+") |- ((X,dropAnySet(Y)) --> C), (Belief:StructuralDeduction, Goal:StructuralDeduction)



//Difference Goal Decompose TODO review
        //DIFFe
        //(B-->S), ((B ~ G) --> S) |- (G --> S), (Goal:Difference)
        //(G-->S), ((B ~ G) --> S) |- (--,(B --> S)), (Goal:Difference)

            //Raw DIFFe
            //B, (B ~ G) |- G, (Goal:Difference)
            //G, (B ~ G) |- (--,B), (Goal:Difference)

        //DIFFi
        //(S-->B), (S --> (B - G)) |- (S --> G), (Goal:Difference)
        //(S-->G), (S --> (B - G)) |- (--,(S --> B)), (Goal:Difference)


//experiment
//     (M --> (S - P)), (M --> S), task("!") |- (M --> P), (Goal:DecomposePositiveNegativeNegative)
//     (M --> (S - P)), (M --> P), task("!") |- (M --> S), (Goal:DecomposeNegativeNegativeNegative)

//raw product composition, may be redundant because general induction via && does the equivalent
//  (already in induction.nal)
 //    A, B, task("*"), belief("*") |- (A | B), (Belief:Intersection)
 //   A, B, task("*"), belief("*") |- (A & B), (Belief:Union)
//    A, B, task("*"), belief("*"), neq(A,B) |- (A - B), (Belief:Difference)
//    A, B, task("*"), belief("*"), neq(A,B) |- (B - A), (Belief:DifferenceReverse)

