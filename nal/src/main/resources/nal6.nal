//// implication-based syllogism ////////////////////////////////////////////////////////////////////////////////////
//       (A ==> B) ------- (B ==> C)
//            \               /
//             \             /
//              \           /
//               \         /
//                (A ==> C)

    //"Please note that the temporal order in the conclusion of a weak rule is
    //not necessarily the same as the order in the premises, given the hypothetical
    //nature of such a rule."

    //strong unification
    (Y ==> X), Z, task(positive), task(".")     |- subIfUnifiesAny(X,Y,Z,"$"), (Belief:DeductionRecursive)
    (Y ==> X), Z, task(negative), task(".")     |- subIfUnifiesAny(--X,Y,Z,"$"), (Belief:DeductionRecursiveN)
    (--Y ==> X), Z, task(positive), task(".")   |- subIfUnifiesAny(X,Y,Z,"$"), (Belief:DeductionRecursivePN)
    (--Y ==> X), Z, task(negative), task(".")   |- subIfUnifiesAny(--X,Y,Z,"$"), (Belief:DeductionRecursiveNN)
    (X ==> Y), Z, task(".")     |- subIfUnifiesAny(X,Y,Z,"$"), (Belief:AbductionRecursivePB)


    //If after S M happens, and after M P happens, so P happens after S
    (M ==> P), (S ==> M) |- (S ==>+- P), (Belief:Deduction)

      (M ==> P), (S ==> M), task("?") |- (S ==>+- P), (Punctuation:Question)
      (M ==> P), (S ==> M), task("?") |- (P ==>+- S), (Punctuation:Question)

        (S ==> M), (M ==> P) |- (S ==>+- P), (Belief:Deduction)


        //experimental:
            (S ==> M), (--M ==> P) |- (S ==>+- P), (Belief:DeductionN)

    (M ==> S), (M ==> P) |- (S ==>+- P), (Belief:Abduction)

      (M ==> S), (M ==> P), task("?") |- (S ==>+- P), (Punctuation:Question)
      (M ==> S), (M ==> P), task("?") |- (P ==>+- S), (Punctuation:Question)

        (M ==> S), (M ==> P) |- (P ==>+- S), (Belief:Abduction)

    //polar balance is possible here, if the impl are both neg ie. --M (as it would unwrap)
    (P ==> M), (S ==> M) |- (P ==>+- S), (Belief:InductionPB)

      (P ==> M), (S ==> M), task("?") |- (S ==>+- P), (Punctuation:Question)
      (P ==> M), (S ==> M), task("?") |- (P ==>+- S), (Punctuation:Question)

        (P ==> M), (S ==> M) |- (S ==>+- P), (Belief:InductionPB)

    (P ==> M), (M ==> S) |- (S ==>+- P), (Belief:Exemplification)

      (P ==> M), (M ==> S) , task("?") |- (S ==>+- P), (Punctuation:Question)
      (P ==> M), (M ==> S) , task("?") |- (P ==>+- S), (Punctuation:Question)

        (M ==> S), (P ==> M) |- (S ==>+- P), (Belief:Exemplification)
        //experimental:
            (P ==> M), (--M ==> S) |- (S ==>+- P), (Belief:ExemplificationN)


    //the comparison rules here emulates what Comparison did in generating <=> which are modeled here as a pair of opposing ==>
    //untested
//    (P ==> M), (S ==> M) |- (S ==>+- P), (Belief:Comparison)
//        (P ==> M), (S ==> M) |- (P ==>+- S), (Belief:Comparison)
//    (M ==> P), (M ==> S) |- (S ==>+- P), (Belief:Comparison)
//        (M ==> P), (M ==> S) |- (P ==>+- S), (Belief:Comparison)


// Contraposition (structural)
// "If not smoking causes health, being not healthy may be the result of smoking"
// "If smoking causes not health, being healthy may be the result of not smoking"

// original:	    ( --S ==> P),   P |- ( --P ==> S), (Truth:Contraposition, Derive:AllowBackward)
// original:	    ( --S ==> P), --S |- ( --P ==> S), (Truth:Contraposition, Derive:AllowBackward)

    ( --S ==> P), P |- ( --P ==>+- S), (Belief:Contraposition)
    //( --S ==> P), P |- ( P ==>+- S), (Belief:ContrapositionN)



//// implication-based composition ////////////////////////////////////////////////////////////////////////////////////
//Same as for inheritance


    (P ==> M), (S ==> M), neq(P,S) |- ((P &&+- S) ==>+- M), (Belief:Intersection)
    (P ==> M), (S ==> M), neq(P,S) |- (--(--P &&+- --S) ==>+- M), (Belief:Union)


    (M ==> P), (M ==> S), belief(positive), neq(P,S) |- (M ==>+- (P &&+- S)), (Belief:Intersection)
        (M ==> P), (M ==> S), belief(negative), neq(P,S) |- (M ==>+- (P &&+- --S)), (Belief:IntersectionPN)
    (M ==> P), (M ==> S), neq(P,S) |- (M ==>+- --(--P &&+- --S)), (Belief:Union)


//// implication-based decomposition ////////////////////////////////////////////////////////////////////////////////////
//Same as for inheritance again


    (S ==> M), (C ==> M), is(C,"&&"),in(S,C) |- (conjWithout(C,S) ==>+- M), (Belief:DecomposeNegativePositivePositive)
        //(S ==> M), ((&&,(--,%S),A..+) ==> M) |- ((&&,A..+) ==>+- M), (Belief:DecomposeNegativePositivePositiveN)
        //(S ==> M), ((||,S,A..+) ==> M) |- ((||,A..+) ==>+- M), (Belief:DecomposePositiveNegativeNegative)

    (M ==> S), (M ==> C), is(C,"&&"),in(S,C) |- (M ==>+- conjWithout(C,S)), (Belief:DecomposePositiveNegativeNegative)
        //(M ==> S), (M ==> (&&,(--,%S),A..+)) |- (M ==>+- (&&,A..+)), (Belief:DecomposePositiveNegativeNegativeN)
        //(M ==> S), (M ==> (||,S,A..+)) |- (M ==>+- (||,A..+)), (Belief:DecomposeNegativePositivePositive)

    (M ==> C), C, is(C,"&&") |- (M ==>+- dropAnyEvent(C)), (Belief:StructuralDeduction)
          //(M ==> C), D, belief("&&") |- (M ==>+- subIfUnifiesAny(dropAnyEvent(C), same, D)), (Belief:StructuralDeduction)
        //(--M ==> C), C, belief("&&") |- (--M ==>+- dropAnyEvent(C)), (Belief:StructuralDeduction)
          //(--M ==> C), D, belief("&&") |- (--M ==>+- subIfUnifiesAny(dropAnyEvent(C), same, D, strict)), (Belief:StructuralDeduction)
        //(M ==> (&&,(--,%S),A..+)), M |- (M ==>+- (&&,A..+)), (Belief:StructuralDeduction)
    (C ==> M), C, is(C,"&&") |- (dropAnyEvent(C) ==>+- M), (Belief:StructuralDeduction)
          //(C ==> M), D, belief("&&") |- (subIfUnifiesAny(dropAnyEvent(C), same, D) ==>+- M), (Belief:StructuralDeduction)
        //(C ==> --M), C, belief("&&") |- (dropAnyEvent(C) ==>+- --M), (Belief:StructuralDeduction)
          //(C ==> --M), D, belief("&&") |- (subIfUnifiesAny(dropAnyEvent(C), same, D, strict) ==>+- --M), (Belief:StructuralDeduction)
                //((&&,(--,%S),A..+) ==> M), M |- ((&&,A..+) ==>+- M), (Belief:StructuralDeduction)



// Conditional syllogism && Independent Variable Elimination
//      If after M, P usually happens, and M happens, it means P is expected to happen
// original:
//    M, (M ==> P), shift_occurrence_forward(M,"==>")  |- P, (Truth:Deduction, Desire:Induction, Order:ForAllSame)
//    M, (P ==> M), shift_occurrence_backward(P,"==>") |- P, (Truth:Abduction, Desire:Deduction, Order:ForAllSame)

    B, (A ==> C),  notImpl(B) |- subIfUnifiesAny(C,A,B), (Belief:Deduction, Goal:DeciInduction)
        //B, (A ==> C),  notImpl(B), task(".") |- subIfUnifiesAny(C,A,B,"$",strict), (Belief:DeductionRecursivePB)
        //B, (B ==> C),  notImpl(B), task("!") |- C, (Goal:DeciInduction)

    B, (--A ==> C),  notImpl(B) |- subIfUnifiesAny(C,A,B), (Belief:DeductionRecursivePBN, Goal:DeciInductionN)
        //B, (--A ==> C),  notImpl(B), task(".") |- subIfUnifiesAny(C,A,B,"$",strict), (Belief:DeductionRecursivePBN)
        //B, (--B ==> C),  notImpl(B), task("!") |- C, (Goal:DeciInductionN)

    B, (C ==> A), notImpl(B) |- subIfUnifiesAny(C,A,B), (Belief:Abduction, Goal:Deduction)
    //B, (C ==> A), notImpl(B) |- subIfUnifiesAny(C,A,B), (Belief:AbductionPB, Goal:DeciDeduction)
        //B, (C ==> B), notImpl(B), task("!") |- C (Goal:DeciDeduction)



    //answering
    //Z, (X==>Y), task("?") |- subIfUnifiesAny((X ==>+- Z), Y, Z, "$", strict), (Belief:BeliefStructuralDeduction, Punctuation:Belief)
        //Z, (X==>Y), task("?") |- subIfUnifiesAny(Y, X, Z, strict), (Belief:BeliefStructuralDeduction, Punctuation:Belief)
    //Z, (X==>Y), task("?") |- subIfUnifiesAny((Z ==>+- Y), X, Z, "$", strict), (Belief:BeliefStructuralAbduction, Punctuation:Belief)
    //Z, (--X==>Y), task("?") |- subIfUnifiesAny((--Z ==>+- Y), X, Z, "$", strict), (Belief:BeliefStructuralAbduction, Punctuation:Belief)
        //Z, (X==>Y), task("?") |- subIfUnifiesAny(X, Y, Z, strict), (Belief:BeliefStructuralAbduction, Punctuation:Belief)


    //B, (C && A), task("!"), time(urgent) |- subIfUnifiesAny(C,A,B), (Goal:Strong)
    //B, (C && (--,%A)), task("!"), time(urgent) |- subIfUnifiesAny(C,A,B), (Goal:StrongN)
        //B, (C && A) |- (--,subIfUnifiesAny(C,A,B)), (Goal:StrongN)
        //B, (C && (--,%A)) |- subIfUnifiesAny(C,A,B), (Goal:StrongN)



//// multi-conditional syllogism ////////////////////////////////////////////////////////////////////////////////////
//Inference about the pre/postconditions

//    ((&&,M,A_1..n) ==> C), M, not_implication_or_equivalence(M) |- ((&&,A_1..n) ==> C), (Truth:Deduction, Order:ForAllSame)
//    ((&&,M,A_1..n) ==> C), ((&&,A_1..n) ==> C) |- M, (Truth:Abduction, Order:ForAllSame)

//conditional deduction/abduction
//   original:   ((&&,M,A_1..n) ==> C), M, not_implication_or_equivalence(M) |- ((&&,A_1..n) ==> C), (Truth:Deduction, Order:ForAllSame)
//   original:   ((&&,M,A_1..n) ==> C), (A ==> M) |- ((&&,A,A_1..n) ==> C), (Truth:Deduction, Order:ForAllSame)
//   original:   ((&&,M,A_1..n) ==> C), ((&&,A_1..n) ==> C) |- M, (Truth:Abduction, Order:ForAllSame)
//   original:   ((&&,A,A_1..n) ==> C), (A ==> M) |- ((&&,M,A_1..n) ==> C), (Truth:Abduction, Order:ForAllSame)
//   original:   ((&&,A_1..n) =\> C), M, not_implication_or_equivalence(M) |- ((&&,M,A_1..n) =\> C), (Truth:Induction)
//   original:   ((&&,M,A_1..n) ==> C), ((&&,A,A_1..n) ==> C) |- (A ==> M), (Truth:Induction, Order:ForAllSame)

    (X ==> C), M,  is(X,"&&"), in(M,X) |- (conjWithout(X,M) ==>+- C), (Belief:Deduction)
        //((&&,M,A..+) ==> C), M,                  |- ((&&,A..+) ==>+- C), (Belief:Deduction)
    (X ==> C), (B==>M), is(X,"&&"), in(M,X) |- ((conjWithout(X,M) &&+- B) ==>+- C), (Belief:Deduction)
        //((&&,M,A..+) ==> C), (B ==> M), neq(B,M) |- ((&&,B,A..+) ==>+- C), (Belief:Deduction)

    (X ==> C), (Y==>C), is(X,"&&"), is(Y,"&&"), neq(X,Y)   |- differ(Y,X), (Belief:AbductionPB)
        (X ==> C), (Y==>C), is(X,"&&"), in(Y,X)   |- conjWithout(X,Y), (Belief:AbductionPB)
        (X ==> C), (Y==>C), is(Y,"&&"), in(X,Y)   |- conjWithout(Y,X), (Belief:AbductionPB)
        //((&&,M,A..+) ==> C), ((&&,A..+) ==> C)   |- M, (Belief:AbductionPB)

    (X ==> C), (B==>M), is(X,"&&"), in(B,X) |- ((conjWithout(X,B) &&+- M) ==>+- C), (Belief:AbductionPB)
        //((&&,B,A..+) ==> C), (B ==> M), neq(B,M) |- ((&&,M,A..+) ==>+- C), (Belief:AbductionPB)

    (X ==> C), M, is(X,"&&") |- ((X &&+- M) ==>+- C), (Belief:Induction)
        //((&&,A..+) ==> C), M,                    |- ((&&,M,A..+) ==>+- C), (Belief:Induction)
    (X ==> C), (Y ==> C), is(X,"&&"),is(Y,"&&"), neq(X,Y) |- (differ(Y,X) ==>+- differ(X,Y)), (Belief:Induction)
        //((&&,M,A..+) ==> C), ((&&,B,A..+)==>C)   |- (B ==>+- M), (Belief:Induction)

    //((&&,M,X,A..*) ==> C), (Y ==> C), task(".") |- subIfUnifiesAny((M ==>+- C),X,Y), (Belief:AbductionPB)
    //((&&,M,A..+) ==> X), ((&&,A..+) ==> Y), task(".") |- subIfUnifiesAny((M ==>+- C),X,Y,"$"), (Belief:AbductionPB)

    //Y, (B ==> (&&,X,A..+)), task(".") |- subIfUnifiesAny((B ==>+- (&&,A..+)),X,Y), (Belief:DeductionPB)
    //Y, (B ==> (&&,--X,A..+)), task(".") |- subIfUnifiesAny((B ==>+- (&&,A..+)),X,Y), (Belief:DeductionPBN)

    //Y, ((&&,X,A..+) ==> B) |- subIfUnifiesAny(((&&,A..+) ==>+- B),X,Y), (Belief:Deduction)
    //Y, ((&&,--X,A..+) ==> B) |- subIfUnifiesAny(((&&,A..+) ==>+- B),X,Y), (Belief:DeductionN)


//// propositional decomposition ////////////////////////////////////////////////////////////////////////////////////
//If S is the case, and (&&,S,A..+) is not the case, it can't be that (&&,A..+) is the case

//SUSPECT
    S, (&&,S,A..+), task(".") |- (&&,A..+), (Belief:DecomposePositiveNegativeNegative)
        //S, (||,S,A..+) |- (||,A..+), (Belief:DecomposeNegativePositivePositive)
    S, (&&,--S,A..+), task(".") |- (&&,A..+), (Belief:DecomposePositiveNegativeNegativeN)
        //S, (||,(--,%S),A..+) |- (||,A..+), (Belief:DecomposePositivePositivePositive)





//Can be derived by NAL7 rules so this won't be necessary there (Order:ForAllSame left out here)

//the first rule does not have Order:ForAllSame because it would be invalid, see: https://groups.google.com/forum/#!topic/open-nars/r5UJo64Qhrk
    //the strange composition of && is to preserve temporality

    ((&&,M,A..+) ==> C), (B ==> M)  |- (((&&,A..+) &&+- B) ==>+- C), (Belief:Deduction)
    ((&&,B,A..+) ==> C), (B ==> M) |- (((&&,A..+) &&+- M) ==>+- C), (Belief:Induction)
    ((&&,A..+) ==> C), M,  notImpl(M) |- (((&&,A..+) &&+- M) ==>+- C), (Belief:Induction)

    ((&&,X,A..+) ==> C), ((&&,Y,A..+) ==> C), neq(X,Y) |- (X ==>+- Y), (Belief:InductionPB)
    ((&&,X,A..+) ==> C), ((&&,Y,A..+) ==> C), neq(X,Y) |- (Y ==>+- X), (Belief:InductionPB)
    (C ==> (&&,X,A..+)), (C ==> (&&,Y,A..+)), neq(X,Y) |- (X ==>+- Y), (Belief:AbductionPB)
    (C ==> (&&,X,A..+)), (C ==> (&&,Y,A..+)), neq(X,Y) |- (Y ==>+- X), (Belief:AbductionPB)
        //((&&,B,A..+) ==> C), ((&&,A..+) ==> C) |- (B ==>+- C), (Belief:Induction)

//precondition combiner inference rule (variable_unification6):

    ((&&,C,A..+) ==> X), ((&&,C,B..+) ==> Y), neq(X,Y) |- subIfUnifiesAny(((&&,A..+) ==>+- (&&,B..+)),X,Y,"$"), (Belief:InductionPB)
    ((&&,C,A..+) ==> X), ((&&,C,B..+) ==> Y), neq(X,Y) |- subIfUnifiesAny(((&&,B..+) ==>+- (&&,A..+)),X,Y,"$"), (Belief:InductionPB)
    (X ==> (&&,C,A..+)), (Y ==> (&&,C,B..+)), neq(X,Y) |- subIfUnifiesAny(((&&,A..+) ==>+- (&&,B..+)),X,Y,"$"), (Belief:AbductionPB)
    (X ==> (&&,C,A..+)), (Y ==> (&&,C,B..+)), neq(X,Y) |- subIfUnifiesAny(((&&,B..+) ==>+- (&&,A..+)),X,Y,"$"), (Belief:AbductionPB)
        //((&&,C,A..+) ==> Z), ((&&,C,B..+) ==> Z), neq(A..+,B..+) |- ((&&,A..+) ==>+- (&&,B..+)), (Belief:Induction)
        //((&&,C,A..+) ==> Z), ((&&,C,B..+) ==> Z), neq(A..+,B..+) |- ((&&,B..+) ==>+- (&&,A..+)), (Belief:Induction)
        //(Z ==> (&&,C,A..+)), (Z ==> (&&,C,B..+)), neq(A..+,B..+) |- ((&&,A..+) ==>+- (&&,B..+)), (Belief:Abduction)
        //(Z ==> (&&,C,A..+)), (Z ==> (&&,C,B..+)), neq(A..+,B..+) |- ((&&,B..+) ==>+- (&&,A..+)), (Belief:Abduction)




//conditional abduction by dependent variable

    ((X --> R) ==> Z), ((&&,(#Y --> B),(#Y --> R),A..*) ==> Z)  |- (X --> B), (Belief:AbductionPB)
        (--(X --> R) ==> Z), ((&&,(#Y --> B),--(#Y --> R),A..*) ==> Z) |- (X --> B), (Belief:AbductionPB)


// conditional deduction "An inverse inference has been implemented as a form of deduction" https://code.google.com/p/open-nars/issues/detail?id=40&can=1

//    (U --> L), ((&&,(#X --> L),(#X --> R),A..*) ==> Z), neq(U,R) |- substitute((((&&,A..*) &&+- (U --> R)) ==>+- Z),#X,U), (Belief:Deduction)
//        (U --> L), ((&&,--(#X --> L),(#X --> R),A..*) ==> Z), neq(U,R) |- substitute((((&&,A..*) &&+- (U --> R)) ==>+- Z),#X,U), (Belief:DeductionN)



//// second level variable handling rules ////////////////////////////////////////////////////////////////////////////////////
//second level variable elimination (termlink level2 growth needed in order for these rules to work)

    (B --> K), (&&,(#X --> L),(($Y --> K) ==> A)) |- substitute(((#X --> L) &&+- A), $Y, B), (Belief:Deduction)
        (B --> K), (&&,(#X --> L),((--,($Y --> K)) ==> A)) |- substitute(((#X --> L) &&+- A), $Y, B), (Belief:DeductionN)
      //(K --> B), (&&,(#X --> L),((K --> $Y) ==> A)) |- substitute(((#X --> L) &&+- A), $Y, B), (Belief:Deduction)
        //(K --> B), (&&,(#X --> L),((--,(K --> $Y)) ==> A)) |- substitute(((#X --> L) &&+- A), $Y, B), (Belief:DeductionN)

    (B --> K), (($X --> L) ==> (&&,(#Y --> K),A..+)) |- substitute((($X --> L) ==>+- (&&,A..+)),#Y,B), (Belief:AnonymousAnalogy)
        (B --> K), (($X --> L) ==> (&&,--(#Y --> K),A..+)) |- substitute((($X --> L) ==>+- (&&,A..+)),#Y,B), (Belief:AnonymousAnalogyN)
        //TODO reversals if they are included

    (Y --> P), (&&,(X-->P),A..+),neq(X,Y) |- subIfUnifiesAny((&&,(X-->P),A..+), X,Y,strict), (Belief:Deduction)
        (Y --> P), (&&,--(X-->P),A..+),neq(X,Y) |- subIfUnifiesAny((&&,--(X-->P),A..+), X,Y,strict), (Belief:DeductionN)
      //(P --> Y), (&&,(P-->X),A..+),neq(X,Y) |- subIfUnifiesAny((&&,(P-->X),A..+), X,Y,strict), (Belief:Deduction)
        //  (P --> Y), (&&,--(P-->X),A..+),neq(X,Y) |- subIfUnifiesAny((&&,--(P-->X),A..+), X,Y,strict), (Belief:DeductionN)

    (Y --> P), ((&&,(X-->P),A..+) ==> Z),neq(X,Y) |- subIfUnifiesAny(((&&,(X-->P),A..+) ==>+- Z), X,Y,strict), (Belief:Deduction)
        (Y --> P), ((&&,--(X-->P),A..+) ==> Z),neq(X,Y) |- subIfUnifiesAny(((&&,--(X-->P),A..+) ==>+- Z), X,Y,strict), (Belief:DeductionN)
      //(P --> Y), ((&&,(P-->X),A..+) ==> Z),neq(X,Y) |- subIfUnifiesAny(((&&,(P-->X),A..+) ==>+- Z), X,Y,strict), (Belief:Deduction)
          //(P --> Y), ((&&,--(P-->X),A..+) ==> Z),neq(X,Y) |- subIfUnifiesAny(((&&,--(P-->X),A..+) ==>+- Z), X,Y,strict), (Belief:DeductionN)

    (Y --> P), (Z ==> (&&,(X-->P),A..+)),neq(X,Y) |- subIfUnifiesAny((Z ==>+- (&&,(X-->P),A..+)), X,Y,strict), (Belief:Deduction)
        (Y --> P), (Z ==> (&&,--(X-->P),A..+)),neq(X,Y) |- subIfUnifiesAny((Z ==>+- (&&,--(X-->P),A..+)), X,Y,strict), (Belief:DeductionN)
      //(P --> Y), (Z ==> (&&,(P-->X),A..+)),neq(X,Y) |- subIfUnifiesAny((Z ==>+- (&&,(P-->X),A..+)), X,Y,strict), (Belief:Deduction)
        //(P --> Y), (Z ==> (&&,--(P-->X),A..+)),neq(X,Y) |- subIfUnifiesAny((Z ==>+- (&&,--(P-->X),A..+)), X,Y,strict), (Belief:DeductionN)




//// conjunction decompose AND dependent variable elimination - decomposition with elimination of a variable


    //see: https://en.wikipedia.org/wiki/Imperative_logic#Ross.27_Paradox
    //originally these were only valid if A occurrs during or after C. the opposite is not logical and would also produce redundant results

    X, C, belief("&&"), task("!"), task(positive), in(X,C) |- conjPrior(C,X), (Goal:Weak)
    X, C, belief("&&"), task("!"), task(negative), in(X,C) |- conjPrior(C,--X), (Goal:WeakN)

    //B, C, belief("&&+"), task("!"), time(urgent) |- subIfUnifiesAny(conjEvent(C,early),conjEvent(C,late),B), (Goal:Strong)
    //B, C, belief("&&+"), task("!"), time(urgent) |- subIfUnifiesAny(conjEvent(C,early),--conjEvent(C,late),B), (Goal:StrongN)

    C, X, task("&&"), task("!"), belief(positive), in(X,C) |- conjDropIfEarliest(C,X), (Goal:Strong)
    C, X, task("&&"), task("!"), belief(negative), in(X,C) |- conjDropIfEarliest(C,--X), (Goal:StrongPN)
        //(&&,X,A..+), X, task("!") |- X, (Goal:Strong)
        //(&&,--X,A..+), X, task("!") |- X, (Goal:StrongPN)

    //structural decompose any component of a conjunction.
    //for belief: any conj
    //C, X, task("&&"), in(X,C)  |- conjWithout(C, X), (Belief:StructuralDeduction, Goal:StructuralDeduction)
    C, X, task("&&"), in(X,C)  |- dropAnyEvent(C), (Belief:StructuralDeduction, Goal:StructuralDeduction)

    //for goal: if eternal and paral (goal seq must be decomposed sequentially use &&| and add separate rule
    //C, X, task("&&") |- dropAnyEvent(C), (Goal:StructuralDeduction)


    //(&&,A_1..n), A_i |- A_i, (Truth:StructuralDeduction, Desire:Strong)
    //SUSPECT:
        //(&&,X,A..+), X, task("!") |- X, (Goal:Strong)
        //(&&,(--,%X),A..+), X, task("!") |- (--,%X), (Goal:StrongPN)


//Anonymous Analogy (NAL5)
    //originally this only unified depvar (dep var elimination)
     (&&,X,A..+), Y    |- subIfUnifiesAny((&&,A..+),X,Y,"#"), (Belief:AnonymousAnalogy)
     (&&,--X,A..+), Y  |- subIfUnifiesAny((&&,A..+),X,Y,"#"), (Belief:AnonymousAnalogyPN)


     //((&&,X,A..+) && Z), Z |- (X &&+- Z), (Belief:StructuralDeduction, Goal:StructuralDeduction)
     //(Z && (&&,X,A..+)), Z |- (Z &&+- X), (Belief:StructuralDeduction, Goal:StructuralDeduction)
        //((&&,X,A..+) && (--,%Z)), Z |- (X &&+- (--,%Z)), (Belief:StructuralDeduction, Goal:StructuralDeduction)
        //((--,%Z) && (&&,X,A..+)), Z |- ((--,%Z) &&+- X), (Belief:StructuralDeduction, Goal:StructuralDeduction)

//     (&&,X,A..+), B, task("!") |- subIfUnifiesAny((&&,A..+),X,B), (Goal:Strong)
//        (&&,(--,%X),A..+), B,  task("!") |- subIfUnifiesAny((&&,A..+),X,B), (Goal:StrongPN)

     //X, (&&,X,A..+),            task("?@") |- (&&,A..+), ()
     //   X, (&&,(--,%X),A..+),   task("?@") |- (&&,A..+), ()
     //B, (A==>B),                task("?@") |- A, ()
     //A, (A==>B),                task("?@") |- B, ()
     //A, ((--,%A)==>B),          task("?@") |- B, ()


     //(&&,X,A..+), X, task("?@") |- (&&,A..+), ()
     //   (&&,(--,%X),A..+), X, task("?@") |- (&&,A..+), ()


     //B, C, belief("&&") |- subIfUnifiesDep(dropAnyEvent(C),X,B), (Belief:AnonymousAnalogy)
                //,Goal:Deduction
                //Goal:Goduction)

///// conjunction decompose
//
//    (&&,A_1..n), A_1 |- A_1, (Truth:StructuralDeduction, Desire:StructuralStrong)
//    (&/,A_1..n), A_1 |- A_1, (Truth:StructuralDeduction, Desire:StructuralStrong)
//    (&|,A_1..n), A_1 |- A_1, (Truth:StructuralDeduction, Desire:StructuralStrong)
//    (&/,B,A_1..n), B, task("!") |- (&/,A_1..n), (Truth:Deduction, Desire:Strong, SequenceIntervals:FromPremises)
//
////// propositional decomposition ////////////////////////////////////////////////////////////////////////////////////
////If S is the case, and (&&,S,A_1..n) is not the case, it can't be that (&&,A_1..n) is the case
//
//    S, (&/,S,A_1..n) |- (&/,A_1..n), (Truth:DecomposePositiveNegativeNegative, SequenceIntervals:FromPremises)
//    S, (&|,S,A_1..n) |- (&|,A_1..n), (Truth:DecomposePositiveNegativeNegative)
//    S, (&&,S,A_1..n) |- (&&,A_1..n), (Truth:DecomposePositiveNegativeNegative)
//    S, (||,S,A_1..n) |- (||,A_1..n), (Truth:DecomposeNegativePositivePositive)
//
////Additional for negation: https://groups.google.com/forum/#!topic/open-nars/g-7r0jjq2Vc
//
//    S, (&/,(--,S),A_1..n) |- (&/,A_1..n), (Truth:DecomposeNegativeNegativeNegative, SequenceIntervals:FromPremises)
//    S, (&|,(--,S),A_1..n) |- (&|,A_1..n), (Truth:DecomposeNegativeNegativeNegative)
//    S, (&&,(--,S),A_1..n) |- (&&,A_1..n), (Truth:DecomposeNegativeNegativeNegative)
//    S, (||,(--,S),A_1..n) |- (||,A_1..n), (Truth:DecomposePositivePositivePositive)

