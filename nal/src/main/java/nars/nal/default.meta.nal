// Pei Wang's "Non-Axiomatic Logic" specified with a math. notation inspired DSL with given intiutive explainations:

//The rules of NAL, can be interpreted by considering the intiution behind the following two relations:
// Statement:                 (A --> B):               A can stand for B
// Statement about Statement: (A --> B) ==> (X --> Y): If A is true, so is/will be B
// --> is a relation in meaning of terms, while ==> is a relation of truth between statements.



//desire spreading by similarity
     S, (S <-> P), task("!") |- P, (Goal:Intersection)



//Set Definition Similarity to Inheritance

    ({S} <-> {P}), {S} |- ({S} --> {P}), (Belief:Identity, Permute:Backward)
    ([S] <-> [P]), [S] |- ([S] --> [P]), (Belief:Identity, Permute:Backward)


//Set Definition Unwrap

    ({S} <-> {P}), {S} |- (S <-> P), (Belief:Identity, Permute:Backward)
    ([S] <-> [P]), [S] |- (S <-> P), (Belief:Identity, Permute:Backward)

//Nothing is more specific than a instance, so its similar

    (S --> {P}),  S  |- (S <-> {P}), (Belief:Identity, Permute:Backward)
    (S --> {P}), {P} |- (S <-> {P}), (Belief:Identity, Permute:Backward)

//nothing is more general than a property, so its similar

    ([S] --> P), [S] |- ([S] <-> P), (Belief:Identity, Permute:Backward)
    ([S] --> P),  P  |- ([S] <-> P), (Belief:Identity, Permute:Backward)



// "If not smoking lets you be healthy, being not healthy may be the result of smoking"
//    ( (--,%S) ==> P),  P, neqRec(S,P), notEqui(P), time(dtTaskExact) |- ( (--,%P) ==>+- S), (Belief:Contraposition, Permute:Backward, Permute:NoSwap)
//    ( (--,%S) ==> P),  S, neq(S,P), neq((--,%S),P), neqRec(S,P), notEqui(S), time(dtTaskExact) |- ( (--,%P) ==>+- S), (Belief:Contraposition, Permute:Backward, Permute:NoSwap)



//// inheritance-based syllogism ////////////////////////////////////////////////////////////////////////////////////
//       (A --> B) ------- (B --> C)
//            \               /
//             \             /
//              \           /
//               \         /
//                (A --> C)
//If A is a special case of B, and B is a special case of C, so is A a special case of C (strong), the other variations are hypotheses (weak)

(A --> B), (B --> C), neqRec(A,C) |- (A --> C), (Belief:Deduction, Goal:Strong Permute:NoSwap)
(A --> B), (A --> C), neqRec(B,C) |- (C --> B), (Belief:Abduction, Goal:Weak, Permute:NoSwap)
(A --> C), (B --> C), neqRec(A,B) |- (A --> B), (Belief:Induction, Goal:Weak, Permute:NoSwap)
(A --> B), (B --> C), neqRec(A,C) |- (C --> A), (Belief:Exemplification, Goal:Weak, Permute:NoSwap)

//// similarity from inheritance ////////////////////////////////////////////////////////////////////////////////////
//If S is a special case of P, and P is a special case of S, then S and P are similar

    (S --> P), (P --> S) |- (S <-> P), (Belief:Intersection, Goal:Strong, Permute:Backward, Permute:NoSwap)

//// inheritance from similarty <- todo check why this one was missing ////////////////////////////////////////////////////////////////////////////////////

    (S <-> P), (P --> S) |- (S --> P), (Belief:ReduceConjunction, Goal:Strong, Permute:Backward, Permute:NoSwap)

//// similarity-based syllogism ////////////////////////////////////////////////////////////////////////////////////
//If P and S are a special case of M, then they might be similar (weak),
//also if P and S are a general case of M

    (P --> M), (S --> M), neqCom(S,P) |- (S <-> P), (Belief:Comparison, Goal:Weak, Permute:Backward, Permute:NoSwap)
    (M --> P), (M --> S), neqCom(S,P) |- (S <-> P), (Belief:Comparison, Goal:Weak, Permute:Backward, Permute:NoSwap)

//If M is a special case of P and S and M are similar, then S is also a special case of P (strong)

    (M --> P), (S <-> M), neqCom(S,P) |- (S --> P), (Belief:Analogy, Goal:Strong, Permute:Backward, Permute:NoSwap)
    (P --> M), (S <-> M), neqCom(S,P) |- (P --> S), (Belief:Analogy, Goal:Strong, Permute:Backward, Permute:NoSwap)
    (M <-> P), (S <-> M), neqCom(S,P) |- (S <-> P), (Belief:Resemblance, Goal:Strong, Permute:Backward, Permute:NoSwap)

//// inheritance composition ////////////////////////////////////////////////////////////////////////////////////
//If P and S are in the intension/extension of M, then union/difference and intersection can be built:
//The duality of extension and intension in NAL corresponds to the
//  duality of intersection and union in set theory â€” intensional intersection
//  corresponds to extensional union, and extensional intersection corresponds
//  to intensional union.

    (P --> M), (S --> M), notSet(S), notSet(P), neqRec(S,P) |- ((S | P) --> M), (Belief:Intersection, Permute:Backward, Permute:NoSwap)
    (P --> M), (S --> M), notSet(S), notSet(P), neqRec(S,P) |- ((S & P) --> M), (Belief:Union, Permute:Backward, Permute:NoSwap)
    (P --> M), (S --> M), notSet(S), notSet(P), neqRec(S,P) |- ((P ~ S) --> M), (Belief:Difference, Permute:Backward, Permute:NoSwap)

    (M --> P), (M --> S), notSet(S), notSet(P), neqRec(S,P) |- (M --> (P & S)), (Belief:Intersection, Permute:Backward, Permute:NoSwap)
    (M --> P), (M --> S), notSet(S), notSet(P), neqRec(S,P) |- (M --> (P | S)), (Belief:Union, Permute:Backward, Permute:NoSwap)
    (M --> P), (M --> S), notSet(S), notSet(P), neqRec(S,P) |- (M --> (P - S)), (Belief:Difference, Permute:Backward, Permute:NoSwap)

//raw product composition
//    (A..+), (B..+) |- ((A..+) | (B..+)), (Belief:Intersection, Permute:NoSwap)
//    (A..+), (B..+) |- ((A..+) & (B..+)), (Belief:Union, Permute:NoSwap)
//    (A..+), (B..+) |- ((A..+) ~ (B..+)), (Belief:Difference, Permute:NoSwap)
//raw product decomposition ?

//// inheritance decomposition ////////////////////////////////////////////////////////////////////////////////////
//if (S --> M) is the case, and ((|,S,A..+) --> M) is not the case, then ((|,A..+) --> M) is not the case, hence Belief:DecomposePositiveNegativeNegative

         (S --> M), ((|,S,A..+) --> M) |- ((|,A..+) --> M), (Belief:DecomposePositiveNegativeNegative)
         (S --> M), ((&,S,A..+) --> M) |- ((&,A..+) --> M), (Belief:DecomposeNegativePositivePositive)

         (M --> S), (M --> (&,S,A..+)) |- (M --> (&,A..+)), (Belief:DecomposePositiveNegativeNegative)
         (M --> S), (M --> (|,S,A..+)) |- (M --> (|,A..+)), (Belief:DecomposeNegativePositivePositive)

         (S --> M), ((S ~ P) --> M) |- (P --> M), (Belief:DecomposePositiveNegativePositive)
         (S --> M), ((P ~ S) --> M) |- (P --> M), (Belief:DecomposeNegativeNegativeNegative)

         (M --> S), (M --> (S - P)) |- (M --> P), (Belief:DecomposePositiveNegativePositive)
         (M --> S), (M --> (P - S)) |- (M --> P), (Belief:DecomposeNegativeNegativeNegative)


//Set comprehension:






//(C --> A), (C --> B), set_ext(A), union(A,B,R) |- (C --> R), (Truth:Union)
//(C --> A), (C --> B), set_ext(A), intersection(A,B,R) |- (C --> R), (Truth:Intersection)
    (C --> A), (C --> B), setext(A,B) |- (C --> union(A,B)), (Belief:Union, Permute:NoSwap)
    (C --> A), (C --> B), setext(A,B) |- (C --> intersect(A,B)), (Belief:Intersection, Permute:NoSwap)
    (C --> A), (C --> B), setext(A,B) |- (C --> differ(A,B)), (Belief:Difference, Permute:NoSwap)

//(C --> A), (C --> B), set_int(A), union(A,B,R) |- (C --> R), (Truth:Intersection)
//(C --> A), (C --> B), set_int(A), intersection(A,B,R) |- (C --> R), (Truth:Union)
    (C --> A), (C --> B), setint(A,B) |- (C --> union(A,B)), (Belief:Intersection, Permute:NoSwap)
    (C --> A), (C --> B), setint(A,B) |- (C --> intersect(A,B)), (Belief:Union, Permute:NoSwap)
    (C --> A), (C --> B), setint(A,B) |- (C --> differ(A,B)), (Belief:Difference, Permute:NoSwap)

//(A --> C), (B --> C), set_ext(A), union(A,B,R) |- (R --> C), (Truth:Intersection)
//(A --> C), (B --> C), set_ext(A), intersection(A,B,R) |- (R --> C), (Truth:Union)
    (A --> C), (B --> C), setext(A,B) |- (intersect(A,B) --> C), (Belief:Union, Permute:NoSwap)
    (A --> C), (B --> C), setext(A,B) |- (union(A,B) --> C), (Belief:Intersection, Permute:NoSwap)
    (A --> C), (B --> C), setext(A,B) |- (differ(A,B) --> C), (Belief:Difference, Permute:NoSwap)

//(A --> C), (B --> C), set_int(A), union(A,B,R) |- (R --> C), (Truth:Union)
//(A --> C), (B --> C), set_int(A), intersection(A,B,R) |- (R --> C), (Truth:Intersection)
    (A --> C), (B --> C), setint(A,B) |- (union(A,B) --> C), (Belief:Union, Permute:NoSwap)
    (A --> C), (B --> C), setint(A,B) |- (intersect(A,B) --> C), (Belief:Intersection, Permute:NoSwap)
    (A --> C), (B --> C), setint(A,B) |- (differ(A,B) --> C), (Belief:Difference, Permute:NoSwap)

//Set element takeout:

//    (C --> {X,A..+}), C |- (C --> {X}), (Belief:StructuralDeduction)
//    (C --> [X,A..+]), C |- (C --> [X]), (Belief:StructuralDeduction)
//    ({X,A..+} --> C), C |- ({X} --> C), (Belief:StructuralDeduction)
//    ([X,A..+] --> C), C |- ([X] --> C), (Belief:StructuralDeduction)
    (C --> {X,A..+}), {X,A..+}, neqRec(X,C) |- (C --> {X}), (Belief:StructuralDeduction)
    (C --> [X,A..+]), [X,A..+], neqRec(X,C) |- (C --> [X]), (Belief:StructuralDeduction)
    ({X,A..+} --> C), {X,A..+}, neqRec(X,C) |- ({X} --> C), (Belief:StructuralDeduction)
    ([X,A..+] --> C), [X,A..+], neqRec(X,C) |- ([X] --> C), (Belief:StructuralDeduction)

//NAL3 single premise inference

    ((|,X,A..+) --> M), (|,X,A..+), neqRec(X,M) |- (X --> M), (Belief:StructuralDeduction)
    (M --> (&,X,A..+)), (&,X,A..+), neqRec(X,M) |- (M --> X), (Belief:StructuralDeduction)

    ((B ~ G) --> S), S, neqRec(S,B) |- (B --> S), (Belief:StructuralDeduction)
    (R --> (B - S)), R, neqRec(S,B) |- (R --> B), (Belief:StructuralDeduction)

//// implication-based syllogism ////////////////////////////////////////////////////////////////////////////////////
//       (A ==> B) ------- (B ==> C)
//            \               /
//             \             /
//              \           /
//               \         /
//                (A ==> C)
//If after S M happens, and after M P happens, so P happens after S

    //"Please note that the temporal order in the conclusion of a weak rule is
    //not necessarily the same as the order in the premises, given the hypothetical
    //nature of such a rule."

    (M ==>+- P), (S ==>+- M), neqCom(S,P), time(dtUnionReverse), notImplEqui(S), notEqui(P) |- (S ==>+- P), (Belief:Deduction)

    (P ==>+- M), (S ==>+- M), neqCom(S,P), time(dtBminT), notImplEqui(S), notEqui(P) |- (S ==>+- P), (Belief:Induction)

    (M ==>+- P), (M ==>+- S), neqCom(S,P), time(dtTminB), notImplEqui(S), notEqui(P) |- (S ==>+- P), (Belief:Abduction)

    (P ==>+- M), (M ==>+- S), neqCom(S,P), time(dtUnion), notImplEqui(S), notEqui(P) |- (S ==>+- P), (Belief:Exemplification)

//// implication to equivalence ////////////////////////////////////////////////////////////////////////////////////
//If when S happens, P happens, and before P happens, S has happened, then they are truth-related equivalent

    (S ==>+- P), (P ==>+- S), notImplEqui(S), notImplEqui(P), neq(S,P), time(dtCombine) |- (S <=>+- P), (Belief:Intersection)

//// equivalence-based syllogism ////////////////////////////////////////////////////////////////////////////////////
//Same as for inheritance again

    (P ==>+- M), (S ==>+- M), notImplEqui(S), notImplEqui(P), neqCom(S,P), time(dtTminB) |- (S <=>+- P), (Belief:Comparison)

    (M ==>+- P), (M ==>+- S), notImplEqui(S), notImplEqui(P), neqCom(S,P), time(dtTminB) |- (S <=>+- P), (Belief:Comparison)

    (M <=>+- P), (S <=>+- M), notImplEqui(S), notImplEqui(P), neqCom(S,P), time(dtCombine) |- (S <=>+- P), (Belief:Resemblance)

    (M ==>+- P), (S <=>+- M), neqCom(S,P), notImplEqui(S), notEqui(P), time(dtTminB) |- (S ==>+- P), (Belief:Analogy)

    (P ==>+- M), (S <=>+- M), neqCom(S,P), notImplEqui(S), notEqui(P), time(dtTminB) |- (P ==>+- S), (Belief:Analogy)


//// implication-based composition ////////////////////////////////////////////////////////////////////////////////////
//Same as for inheritance again


    (P ==> M), (S ==> M), neq(S,P), time(dtCombine) |- ((P && S) ==>+- M), (Belief:Union)
    (%P ==> %M), (%S ==> %M), neq(%S,%P), time(dtCombine) |- ((%P || %S) ==>+- %M), (Belief:Intersection)

    (M ==> P), (M ==> S), neq(S,P), time(dtCombine) |- (M ==>+- (P && S)), (Belief:Intersection)
    (%M ==> %P), (%M ==> %S), neq(%S,%P), time(dtCombine) |- (%M ==>+- (%P || %S)), (Belief:Union)

//    (D =/> R), (D =\> K), neq(R,K) |- (K =/> R), (Belief:Abduction),
//                                      (R =\> K), (Belief:Induction),
//                                      (K </> R), (Belief:Comparison)

//// implication-based decomposition ////////////////////////////////////////////////////////////////////////////////////
//Same as for inheritance again

    //TODO versions with negated S subterms

    (S ==> M), ((&&,S,A..+) ==> M), time(dtCombine) |- ((&&,A..+) ==>+- M), (Belief:DecomposeNegativePositivePositive)
        //(%S ==> %M), ((||,%S,A..+) ==> M), time(dtCombine) |- ((||,A..+) ==>+- %M), (Belief:DecomposePositiveNegativeNegative)

    (M ==> S), (M ==> (&&,S,A..+)), time(dtCombine) |- (M ==>+- (&&,A..+)), (Belief:DecomposePositiveNegativeNegative)
        //(%M ==> %S), (%M ==> (||,%S,A..+)), time(dtCombine) |- (%M ==>+- (||,A..+)), (Belief:DecomposeNegativePositivePositive)

//// conditional syllogism ////////////////////////////////////////////////////////////////////////////////////
//      + Indep variable elimination
//If after M, P usually happens, and M happens, it means P is expected to happen

//      //NAL7 specific inference ////////////////////////////////////////////////////////////////////////////////////
//      Reasoning about temporal statements. those are using the ==> relation because relation in time is a relation of the truth between statements.

    B, (A ==> C), task(positive), time(decomposeBelief) |- subIfUnifiesAny(C,A,B), (Belief:Deduction, Goal:Induction, Event:Anticipate)
        B, ((--,%A) ==> C), task(negative), time(decomposeBelief) |- subIfUnifiesAny(C,A,B), (Belief:DeductionN, Goal:InductionN, Event:Anticipate)
    B, (C ==> A), task(positive), time(decomposeBelief) |- subIfUnifiesAny(C,A,B), (Belief:Abduction, Goal:Deduction)
        B, (C ==> (--,%A)), task(negative), time(decomposeBelief) |- subIfUnifiesAny(C,A,B), (Belief:AbductionN, Goal:Deduction)

    B, (A <=> C), time(decomposeBelief) |- subIfUnifiesAny(C,A,B), (Belief:Analogy, Goal:Strong)

    B, (C && A), time(decomposeBelief) |- subIfUnifiesForward(C,A,B), (Goal:Strong)
        //^ this is only valid if A occurrs during or after C. the opposite is not logical and would also produce redundant results


    //// propositional decomposition ////////////////////////////////////////////////////////////////////////////////////
    //If S is the case, and (&&,S,A..+) is not the case, it can't be that (&&,A..+) is the case

    S, (&&,S,A..+), time(decomposeBelief) |- (&&,A..+), (Belief:DecomposePositiveNegativeNegative)
        //S, (||,S,A..+)                        |- (||,A..+), (Belief:DecomposeNegativePositivePositive)
    S, (&&,(--,%S),A..+), time(decomposeBelief) |- (&&,A..+), (Belief:DecomposeNegativeNegativeNegative)
        //S, (||,(--,%S),A..+)                        |- (||,A..+), (Belief:DecomposePositivePositivePositive)



//// conditional composition: ////////////////////////////////////////////////////////////////////////////////////
//They are let out for AGI purpose, don't let the system generate conjunctions or useless <=> and ==> statements
//For this there needs to be a semantic dependence between both, either by the predicate or by the subject,
//or a temporal dependence which acts as special case of semantic dependence
//These cases are handled by "Variable Introduction" and "Temporal Induction"

    //implications may be constructed with implications for preds but not subjs
    S, P, time(eternal), task(positive), task("."), neq(P,S), notImplEqui(S), notEqui(P) |- (S ==> P), (Belief:Induction)
        S, P, time(eternal), task(negative), task("."), neq(P,S), notImplEqui(S), notEqui(P) |- ((--,%S) ==> P), (Belief:InductionN)
    S, P, time(eternal), task(positive), task("."), neq(P,S), notEqui(S), notImplEqui(P) |- (P ==> S), (Belief:Abduction)
        S, P, time(eternal), task(negative), task("."), neq(P,S), notEqui(S), notImplEqui(P) |- (P ==> (--,%S)) (Belief:AbductionN)
    S, P, time(eternal), task(positive), task("."), neq(P,S), notImplEqui(S), notImplEqui(P) |- (S <=> P), (Belief:Comparison)
        S, P, time(eternal), task(negative), task("."), neq(P,S), notImplEqui(S), notImplEqui(P) |- (--,(S <=> P)), (Belief:ComparisonN)
    S, P, time(eternal), task("."), neq(P,S) |- (S && P), (Belief:Intersection)
        //S, P, time(eternal), task(negative), task("."), neq(P,S) |- ((--,%S) && P), (Belief:IntersectionN)
    //%S, %P, time(eternal), neqCom(P,S) |- (%S || %P), (Belief:Union)

////Temporal induction: ////////////////////////////////////////////////////////////////////////////////////
//When P and then S happened according to an observation, by induction (weak) it may be that alyways after P, usually S happens.

    //implications may be constructed with implications for preds but not subjs
    A, B, task(positive), task("."), time(dtAfter), neq(A,B), notImplEqui(A), notEqui(B) |- (A ==>+- B), (Belief:Induction)
        A, B, task(negative), task("."), time(dtAfter), neq(A,B), notImplEqui(A), notEqui(B) |- ((--,%A) ==>+- B), (Belief:InductionN)

    A, B, task(positive), task("."), time(dtAfterReverse), neq(A,B), notEqui(A), notImplEqui(B) |- (B ==>+- A), (Belief:Abduction)
        A, B, task(negative), task("."), time(dtAfterReverse), neq(A,B), notEqui(A), notImplEqui(B) |- (B ==>+- (--,%A)), (Belief:AbductionN)

    A, B, task(positive), task("."), time(dtForward), neq(A,B), notImplEqui(A), notImplEqui(B) |- (A <=>+- B), (Belief:Comparison)
        A, B, task(negative), task("."), time(dtForward), neq(A,B), notImplEqui(A), notImplEqui(B) |- (--,(A <=>+- B)), (Belief:ComparisonN)

    A, B, task("."), time(dtAfter), neq(A,B) |- (A &&+- B), (Belief:Intersection)
        ///A, B, task(negative), task("."), time(dtAfter), neq(A,B) |- ((--,%A) &&+- B), (Belief:IntersectionN)

                //A, B, task(negative), task("."), time(dtAfter), neqRec(A,B) notImplEqui(A), notImplEqui(B) |- ((--,%A) &&+- B), (Belief:IntersectionN)




//// conjunction decompose AND dependent variable elimination - decomposition with elimination of a variable

     //structural decompose any component of a conjunction
     (&&,X,A..+), X, time(decomposeTaskIfTemporal) |- X, (Belief:StructuralDeduction,Goal:StructuralStrong)
     (&&,X,A..+), X, time(decomposeTask) |- (&&,A..+), (Belief:StructuralDeduction,Goal:StructuralStrong)
     (&&,X,A..+), X, time(decomposeTask), task("?") |- (&&,A..+), (Permute:NoSwap)

     (&&,X,A), B, time(decomposeTask) |- subIfUnifiesDep(X,A,B), (Belief:AnonymousAnalogy, Goal:Strong)
     (&&,X,A..+), B, time(decomposeTask) |- subIfUnifiesDep((&&,A..+),X,B), (Belief:AnonymousAnalogy, Goal:Strong)

        //(&&,(--,%X),A..+), X, time(decomposeTask) |- (&&,A..+), (Belief:StructuralDeduction)
     //(&&,X,A..+), B, time(decomposeTask) |- subOnlyIfUnifiesDep((&&,A..+),X,B), (Belief:AnonymousAnalogy, Goal:Strong)


    //decompose (only) the leading event in a conjunction goal
    //(&&,X,A..+), X, time(decomposeTaskIfTermLinkBefore), task("!") |- X, (Goal:StructuralStrong)
        //(&&,(--,%X),A), X, time(decomposeTaskIfTermLinkBefore), task("!") |- (--,%X), (Goal:StructuralStrong)
    //(&&,X,A..+), X, time(decomposeTaskIfBeliefBefore), task("!") |- (&&,A..+), (Goal:StructuralStrong)

        //(&&,(--,%X),A), X, time(decomposeTaskIfTermLinkBefore), task("!") |- A, (Goal:StructuralStrong)
        //TODO as above


        //TODO use ellipsis here?


//// multi-conditional syllogism ////////////////////////////////////////////////////////////////////////////////////
//Inference about the pre/postconditions

    Y, ((&&,X,A..+) ==> B), time(dtBeliefExact), notImplEqui(A..+) |- subIfUnifiesAny(((&&,A..+) ==>+- B),X,Y), (Belief:Deduction)


//conditional abduction
    ((&&,M,X,A..*) ==> C), (Y ==> C) |- subIfUnifiesAny(M,X,Y), (Belief:Abduction)
    ((&&,M,A..+) ==> C), ((&&,A..+) ==> C) |- M, (Belief:Abduction)
        //TODO modify ellipsis to allow these two rules to be expressed as one:
        // ((&&,M,A..+) ==> C), (A..+ ==> C) |- M, (Belief:Abduction)
        //  which will match A..+ to a Conjunction


//Can be derived by NAL7 rules so this won't be necessary there (Order:ForAllSame left out here)

//the first rule does not have Order:ForAllSame because it would be invalid, see: https://groups.google.com/forum/#!topic/open-nars/r5UJo64Qhrk
    //((&&,A..+) ==> C), M, time(dtTask), neqRec(C,M), notImplEqui(M) |- ((&&,M,A..+) ==>+- C), (Belief:Induction)

    ((&&,M,A..+) ==> C), (B ==> M), time(dtUnion), neqCom(C,M), notImplEqui(M), notEqui(C)  |- ((&&,B,A..+) ==>+- C), (Belief:Deduction)
    ((&&,B,A..+) ==> C), (B ==> M), time(dtTminB), neqCom(C,M), notImplEqui(M), notEqui(C)  |- ((&&,M,A..+) ==>+- C), (Belief:Abduction)
    ((&&,M,A..+) ==> C), ((&&,B,A..+) ==> C), time(dtBminT), neqCom(B,M), notEqui(M), notImplEqui(B) |- (B ==>+- M), (Belief:Induction)

//// variable introduction ////////////////////////////////////////////////////////////////////////////////////
//Introduce variables by common subject or predicate

//    (S --> M), (P --> M), task(positive), neq(S,P), time(dtAfterOrEternalReverse) |- ((P --> $X) ==>+- (S --> $X)), (Belief:Abduction)
//        (S --> M), (P --> M), task(negative), neq(S,P), time(dtAfterOrEternalReverse) |- ((P --> $X) ==>+- (--,(S --> $X))), (Belief:AbductionN)
//    (S --> M), (P --> M), task(positive), neq(S,P), time(dtAfterOrEternal) |- ((S --> $X) ==>+- (P --> $X)), (Belief:Induction)
//        (S --> M), (P --> M), task(negative), neq(S,P), time(dtAfterOrEternal) |- ((--,(S --> $X)) ==>+- (P --> $X)), (Belief:InductionN)
//    (S --> M), (P --> M), task(positive), neq(S,P), time(dtForward) |- ((S --> $X) <=>+- (P --> $X)), (Belief:Comparison)
//        (S --> M), (P --> M), task(negative), neq(S,P), time(dtForward) |- ((--,(S --> $X)) <=>+- (P --> $X)), (Belief:ComparisonN)
//    (S --> M), (P --> M), neq(S,P), time(dtAfterOrEternal) |- ((S --> #Y) &&+- (P --> #Y)), (Belief:Intersection)
//
//    (M --> S), (M --> P), task(positive), neq(S,P), time(dtAfterOrEternal) |- (($X --> S) ==>+- ($X --> P)), (Belief:Induction)
//        (M --> S), (M --> P), task(negative), neq(S,P), time(dtAfterOrEternal) |- ((--,($X --> S)) ==>+- ($X --> P)), (Belief:InductionN)
//    (M --> S), (M --> P), task(positive), neq(S,P), time(dtAfterOrEternalReverse) |- (($X --> P) ==>+- ($X --> S)), (Belief:Abduction)
//        (M --> S), (M --> P), task(negative), neq(S,P), time(dtAfterOrEternalReverse) |- (($X --> P) ==>+- (--,($X --> S))), (Belief:AbductionN)
//    (M --> S), (M --> P), task(positive), neq(S,P), time(dtForward) |- (($X --> S) <=>+- ($X --> P)), (Belief:Comparison)
//        (M --> S), (M --> P), task(negative), neq(S,P), time(dtForward) |- ((--,($X --> S)) <=>+- ($X --> P)), (Belief:ComparisonN)
//    (M --> S), (M --> P), neq(S,P), time(dtAfterOrEternal) |- ((#Y --> S) &&+- (#Y --> P)), (Belief:Intersection)


//// 2nd variable introduction ////////////////////////////////////////////////////////////////////////////////////
//, not_equal(A, (M --> S))
//    (A ==> (M --> P)), (M --> S), neq(S,P), neq(A, (M --> S)), time(dtTaskExact) |- ((&&,A,($X --> S)) ==>+- ($X --> P)), (Belief:Induction)
//    (A ==> (M --> P)), (M --> S), neq(S,P), neq(A, (M --> S)), time(dtTaskExact) |- (&&,(A ==> (#Y --> P)), (#Y --> S)), (Belief:Intersection)
//
//    (&&,(M --> P), A..+), (M --> S), neq(S,P), time(dtTaskExact) |- (($Y --> S) ==>+- (&&,($Y --> P), A..+)), (Belief:Induction)
//    (&&,(M --> P), A..+), (M --> S), neq(S,P), time(dtTaskExact) |- (&&,(#Y --> S), (#Y --> P), A..+), (Belief:Intersection)
//
//    (A ==> (P --> M)), (S --> M), neq(S,P), neq(A, (S --> M)), time(dtTaskExact) |- ((&&,A,(P --> $X)) ==>+- (S --> $X)), (Belief:Abduction)
//    (A ==> (P --> M)), (S --> M), neq(S,P), neq(A, (S --> M)), time(dtTaskExact) |- (&&,(A ==> (P --> #Y)), (S --> #Y)), (Belief:Intersection)
//
//    (&&,(P --> M), A..+), (S --> M), neq(S,P), time(dtTaskExact) |- ((S --> $Y) ==>+- (&&,(P --> $Y), A..+)), (Belief:Abduction)
//    (&&,(P --> M), A..+), (S --> M), neq(S,P), time(dtTaskExact) |- (&&, (S --> #Y), (P --> #Y), A..+), (Belief:Intersection)


//conditional abduction by dependent variable

    ((X --> R) ==> Z), ((&&,(#Y --> B),(#Y --> R),A..*) ==> Z), time(dtTask) |- (X --> B), (Belief:Abduction)

// conditional deduction "An inverse inference has been implemented as a form of deduction" https://code.google.com/p/open-nars/issues/detail?id=40&can=1

    (U --> L), ((&&,(#X --> L),(#X --> R),A..*) ==> Z), time(dtBeliefExact) |- substitute(((&&,A..*,(U --> R)) ==>+- Z),#X,U), (Belief:Deduction)



//// second level variable handling rules ////////////////////////////////////////////////////////////////////////////////////
//second level variable elimination (termlink level2 growth needed in order for these rules to work)

    (B --> K), (&&,(#X --> L),(($Y --> K) ==> A)), time(dtBeliefExact) |- substitute((&&, (#X --> L), A), $Y,B), (Belief:Deduction)
    (B --> K), (($X --> L) ==> (&&,(#Y --> K),A..+)), time(dtBeliefExact) |- substitute((($X --> L) ==>+- (&&,A..+)),#Y,B), (Belief:AnonymousAnalogy)

//    (B --> K), (&&,(#X --> L),(($Y --> K) ==> (&&,A..+))), time(dtBeliefExact) |- substitute((&&,(#X --> L),A..+),$Y,B), (Belief:Deduction)
//    (B --> K), (($X --> L) ==> (&&,(#Y --> K),A)), time(dtBeliefExact) |- substitute((($X --> L) ==>+- A),#Y,B), (Belief:AnonymousAnalogy)


//precondition combiner inference rule (variable_unification6):

    ((&&,C,A..+) ==> Z), ((&&,C,B..+) ==> Z), time(dtCombine) |- ((&&,A..+) ==>+- (&&,B..+)), (Belief:Induction)
    ((&&,C,A..+) ==> Z), ((&&,C,B..+) ==> Z), time(dtCombine) |- ((&&,B..+) ==>+- (&&,A..+)), (Belief:Induction)
    (Z ==> (&&,C,A..+)), (Z ==> (&&,C,B..+)), time(dtCombine) |- ((&&,A..+) ==>+- (&&,B..+)), (Belief:Abduction)
    (Z ==> (&&,C,A..+)), (Z ==> (&&,C,B..+)), time(dtCombine) |- ((&&,B..+) ==>+- (&&,A..+)), (Belief:Abduction)


//second level variable introduction

//    (Y --> L), ((Y --> S) ==> R), neq(L,S), time(dtBeliefExact) |- substitute(((&&,(#X --> L),(#X --> S)) ==>+- R),Y,#X), (Belief:Induction)
//    (Y --> L), ((&&,(Y --> S),A..+) ==> R), neq(L,S), time(dtBeliefExact) |- substitute(((&&,(#X --> L),(#X --> S),A..+) ==>+- R),Y,#X), (Belief:Intersection)








//    A, B, after(_), neq(A,B), notConjunction(A), notConjunction(B),  notImplEqui(A), notImplEqui(B) |- (B && A), (Belief:Intersection)


//    P, S, after(Task,Belief), measure_time(I), notImplEqui(P), notImplEqui(S) |- ((&/,S,I) =/> P), (Belief:Induction, Eternalize:Immediate),
//                                                                                                                       (P =\> (&/,S,I)), (Belief:Abduction),
//                                                                                                                       ((&/,S,I) </> P), (Belief:Comparison)

//    P, S, after(Task,Belief), notConjunction(P), notConjunction(S),  measure_time(I), notImplEqui(P), notImplEqui(S) |- (&/,S,I,P), (Belief:Intersection)

//    P, S, concurrent(Task,Belief), notImplEqui(P), notImplEqui(S) |- (S =|> P), (Belief:Induction, Eternalize:Immediate),
//                                                                                                          (P =|> S), (Belief:Induction),
//                                                                                                           (S <|> P), (Belief:Comparison)

//    P, S, concurrent(Task,Belief), notConjunction(P), notConjunction(S), notImplEqui(P), notImplEqui(S) |- (&|,S,P), (Belief:Intersection)

////backward inference is mostly handled by the rule transformation:

//    T, B |- C, [post] =>
//          C, B, task("?") |- T, [post]
//          C, T, task("?") |- B, [post]

//backward inference rules which should really only work on backward inference:


    (A --> S), (B --> S), neqCom(A,B), task("?") |- (A --> B), (Permute:NoSwap)
    (A --> S), (B --> S), neqCom(A,B), task("?") |- (B --> A), (Permute:NoSwap)

    (A ==> S), (B ==> S), neqCom(A,B), task("?"), notImplEqui(A), notEqui(B)  |- (A ==>+- B), (Permute:NoSwap)
    (A ==> S), (B ==> S), neqCom(A,B), task("?"), notImplEqui(B), notEqui(A)  |- (B ==>+- A), (Permute:NoSwap)

//Inheritance to Similarity

    (S <-> P), (S --> P), neqCom(S,P), task("?") |- (S <-> P), (Belief:StructuralAbduction, Punctuation:Belief, Permute:NoSwap)


//backward temporal induction
    (&&, B, A..+), B, time(decomposeTask), task("?")  |- B, (Permute:NoSwap, Punctuation:Question)
    (A ==> B), A, time(decomposeTask), task("?") |- B, (Permute:NoSwap, Punctuation:Question)
    (A ==> B), B, time(decomposeTask), task("?") |- A, (Permute:NoSwap, Punctuation:Question)
    (A <=> B), A, time(decomposeTask), task("?") |- B, (Permute:NoSwap, Punctuation:Question)

//If S can stand for P, P can to a certain low degree also represent the class S
//If after S usually P happens, then it might be a good guess that usually before P happens, S happens.

    (P --> S), (S --> P), neqCom(S,P),                                              task("?") |- (P --> S),   (Belief:Conversion, Punctuation:Belief, Permute:NoSwap)
    (P ==> S), (S ==> P), neqCom(S,P), time(dtCombine), notImplEqui(P), notEqui(S)  task("?") |- (P ==>+- S), (Belief:Conversion, Punctuation:Belief, Permute:NoSwap)

//and the backward inference driven forward inference:

//Similarity to Inheritance

    (S --> P), (S <-> P), neqCom(S,P), task("?") |- (S --> P), (Belief:StructuralIntersection, Punctuation:Belief, Permute:NoSwap)
    (S ==> P), (S <=> P), neqCom(S,P), task("?") |- (S ==> P), (Belief:StructuralIntersection, Punctuation:Belief, Permute:NoSwap)

//NAL2:

    ([A] <-> [B]), (A <-> B), task("?") |- ([A] <-> [B]), (Belief:BeliefIdentity, Punctuation:Belief, Permute:NoSwap)
    ({A} <-> {B}), (A <-> B), task("?") |- ({A} <-> {B}), (Belief:BeliefIdentity, Punctuation:Belief, Permute:NoSwap)

    ([A] --> [B]), (A <-> B), task("?") |- ([A] --> [B]), (Belief:BeliefIdentity, Punctuation:Belief, Permute:NoSwap)
    ({A} --> {B}), (A <-> B), task("?") |- ({A} --> {B}), (Belief:BeliefIdentity, Punctuation:Belief, Permute:NoSwap)

//experimental:
//    ([A] <-> {B}), (A <-> B), task("?") |- ([A] <-> {B}), (Belief:BeliefIdentity, Punctuation:Belief)
//    ({A} <-> [B]), (A <-> B), task("?") |- ({A} <-> [B]), (Belief:BeliefIdentity, Punctuation:Belief)
//    ([A] --> {B}), (A <-> B), task("?") |- ([A] --> {B}), (Belief:BeliefIdentity, Punctuation:Belief)
//    ({A} --> [B]), (A <-> B), task("?") |- ({A} --> [B]), (Belief:BeliefIdentity, Punctuation:Belief)


//NAL3:

////composition on both sides of a statement:

    ((&,B,A..+) --> (&,X,A..+)), (B --> X), task("?") |- ((&,B,A..+) --> (&,X,A..+)), (Belief:BeliefStructuralDeduction, Punctuation:Belief, Permute:NoSwap)
    ((|,B,A..+) --> (|,X,A..+)), (B --> X), task("?") |- ((|,B,A..+) --> (|,X,A..+)), (Belief:BeliefStructuralDeduction, Punctuation:Belief, Permute:NoSwap)

    ((-,S,A) --> (-,S,B)), (B --> A), task("?") |- ((-,S,A) --> (-,S,B)), (Belief:BeliefStructuralDeduction, Punctuation:Belief, Permute:NoSwap)
    ((~,S,A) --> (~,S,B)), (B --> A), task("?") |- ((~,S,A) --> (~,S,B)), (Belief:BeliefStructuralDeduction, Punctuation:Belief, Permute:NoSwap)

////composition on one side of a statement:

    (W --> (|,B,A..+)), (W --> B), task("?") |- (W --> (|,B,A..+)), (Belief:BeliefStructuralDeduction, Punctuation:Belief, Permute:NoSwap)
    ((&,B,A..+) --> W), (B --> W), task("?") |- ((&,B,A..+) --> W), (Belief:BeliefStructuralDeduction, Punctuation:Belief, Permute:NoSwap)

    (W --> (-,S,B)), (W --> B), neqCom(W,S), task("?") |- (W --> (-,S,B)), (Belief:BeliefStructuralDifference, Punctuation:Belief, Permute:NoSwap)
    ((~,S,B) --> W), (B --> W), neqCom(W,S), task("?") |- ((~,S,B) --> W), (Belief:BeliefStructuralDifference, Punctuation:Belief, Permute:NoSwap)

////// NAL4 - Transformations between products and images: ////////////////////////////////////////////////////////////////////////////////////
//Relations and transforming them into different representations so that arguments and the relation itself can become the subject or predicate

    (B --> (/, M, A.._=B..+, _)), M |- ((A.._=B..+) --> M), (Belief:Identity, Goal:Identity, Permute:NoSwap)

    ((A..B=_..+) --> M), B |- (B --> (/, M, A..B=_..+, _ )), (Belief:Identity, Goal:Identity, Permute:NoSwap)

    (M --> (A..B=_..+)), B |- ((\, M, A..B=_..+, _ ) --> B), (Belief:Identity, Goal:Identity, Permute:NoSwap)

    ((\, M, A.._=B..+, _) --> B), M |- (M --> (A.._=B..+)), (Belief:Identity, Goal:Identity, Permute:NoSwap)

//Recursion Force - TODO use varargs

  //2
//    ((A,B) --> Y), A |- ((A,B)-->((/,Y,_,B), B)), (Belief:StructuralDeduction, Goal:StructuralDeduction)
//    ((A,B) --> Y), B |- ((A,B)-->(A, (/,Y,A,_))), (Belief:StructuralDeduction, Goal:StructuralDeduction)
  //3
//    ((A,B,C) --> Y), A |- ((A,B,C)-->((/,Y, _, B, C), B, C)), (Belief:StructuralDeduction, Goal:StructuralDeduction)
//    ((A,B,C) --> Y), B |- ((A,B,C)-->(A, (/,Y, A, _, C), C)), (Belief:StructuralDeduction, Goal:StructuralDeduction)
//    ((A,B,C) --> Y), C |- ((A,B,C)-->(A, B, (/,Y, A, B, _))), (Belief:StructuralDeduction, Goal:StructuralDeduction)



////composition on both sides of a statement:


    ((B,P) <-> Z) ,(B <-> A), task("?") |- ((B,P) <-> (A,P)), (Belief:BeliefStructuralDeduction, Punctuation:Belief, Permute:NoSwap)
    ((P,B) <-> Z) ,(B <-> A), task("?") |- ((P,B) <-> (P,A)), (Belief:BeliefStructuralDeduction, Punctuation:Belief, Permute:NoSwap)

    ((B,P) --> Z) ,(B --> A), task("?") |- ((B,P) --> (A,P)), (Belief:BeliefStructuralDeduction, Punctuation:Belief, Permute:NoSwap)
    ((P,B) --> Z) ,(B --> A), task("?") |- ((P,B) --> (P,A)), (Belief:BeliefStructuralDeduction, Punctuation:Belief, Permute:NoSwap)



//use variables here to force the image/product normalization to not apply
    ((/,%N,_,%A) --> %Z), (%B --> %A), task("?") |- ((/,%N,_,%A) --> (/,%N,_,%B)), (Belief:BeliefStructuralDeduction, Punctuation:Belief, Permute:NoSwap)
    ((\,%N,%A,_) --> %Z), (%N --> %R), task("?") |- ((\,%N,%A,_) --> (\,%R,%A,_)), (Belief:BeliefStructuralDeduction, Punctuation:Belief, Permute:NoSwap)





//Relation introduction (wastepaper experimental)
//   (A --> C), (B --> D) |- ((A,B) --> (C,D)), (Belief:Intersection)
//   (A --> C), (A --> D) |- ((A,A) --> {C,D}), (Belief:Intersection)
//   (C --> A), (D --> A) |- ({C,D} --> (A,A)), (Belief:Intersection)

//          #_#R[(A --> C) (B --> D) |- ((* A B) --> (* C D)) :post (:t/intersection)] //            ;this one cant be allowed due to control reasons:
//          #R[(A --> C) (A --> D) |- ((* A A) --> (* C D)) :post (:t/intersection)]
//         #R[(A --> C) (B --> C) |- ((* A B) --> (* C C)) :post (:t/intersection)]
//         #R[({A} --> C) (A --> D) |- ((* {A} A) --> (* C D)) :post (:t/intersection)]
//          #R[(A --> C) ({A} --> D) |- ((* A {A}) --> (* C D)) :post (:t/intersection)]
//         #R[(A --> [C]) (B --> C) |- ((* A B) --> (* [C] C)) :post (:t/intersection)]
//         #R[(A --> C) (B --> [C]) |- ((* A B) --> (* C [C])) :post (:t/intersection)]


//compound composition one premise

    (||,%B,A..+), B, task("?") |- (||,%B,A..+), (Belief:BeliefStructuralDeduction, Punctuation:Belief, Permute:NoSwap)


//TODO for desire

//query-variable queston answering HACK currently this is done better in PremiseGeneration, not here. but this sort of works
//  A, B, task("?") |- subIfUnifiesQuery(B, A, B), (Belief:BeliefIdentity, Punctuation:Belief)



//WASTEPAPER ===

//Single product variations
//    (S), (P), neqRec(S,P) |- (S | P), (Belief:Union),
//                                                  (S & P), (Belief:Intersection),
//                                                  (P ~ S), (Belief:Difference)


//DeMorgan's Law - currently implemented as a reduction but possibly should be a structural rule
    //<sseehh__> it becomes more helpful when there are >2 terms, ex: (&&, --(x), --(y), --(z))
    //<sseehh__> then it can replace N negations with one
    //<sseehh__> then the compound and its opposite resolve to the same compound
    //<patham9> if then I would add it as structural rule
    //<patham9> not as "reduction"
    //<patham9> meaning the system has free choice about the representation
    //<patham9> should have
    //<sseehh__> thats possible
    //<patham9> and I wouldnt apply StructuralDeduction as truth
