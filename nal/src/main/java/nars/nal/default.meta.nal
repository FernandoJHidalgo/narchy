// Pei Wang's "Non-Axiomatic Logic" specified with a math. notation inspired DSL with given intiutive explainations:


// Variable Introduction
    //X, Y, component(task,belief), time(dtTask), task(any)       |- varIntro(X), (Belief:Identity, Goal:Identity)

//The rules of NAL, can be interpreted by considering the intiution behind the following two relations:
// Statement:                 (A --> B):               A can stand for B
// Statement about Statement: (A --> B) ==> (X --> Y): If A is true, so is/will be B
// --> is a relation in meaning of terms, while ==> is a relation of truth between statements.

//Set Definition Similarity to Inheritance

    ({S} <-> {P}), {S} |- ({S} --> {P}), (Belief:Identity, Permute:Backward)
    ([S] <-> [P]), [S] |- ([S] --> [P]), (Belief:Identity, Permute:Backward)


//Set Definition Unwrap

    ({S} <-> {P}), S |- (S <-> P), (Belief:Identity)
    ([S] <-> [P]), S |- (S <-> P), (Belief:Identity)

//Nothing is more specific than a instance, so its similar

    (S --> {P}),  S  |- (S <-> {P}), (Belief:Identity)
    //(S --> {P}), {P} |- (S <-> {P}), (Belief:Identity, Permute:Backward)

//nothing is more general than a property, so its similar

    //([S] --> P), [S] |- ([S] <-> P), (Belief:Identity, Permute:Backward)
    ([S] --> P),  P  |- ([S] <-> P), (Belief:Identity)



// "If not smoking lets you be healthy, being not healthy may be the result of smoking"
//    ( (--,%S) ==> P),  P, neqRec(S,P), notEqui(P), time(dtTaskExact) |- ( (--,%P) ==>+- S), (Belief:Contraposition, Permute:Backward)
//    ( (--,%S) ==> P),  S, neq(S,P), neq((--,%S),P), neqRec(S,P), notEqui(S), time(dtTaskExact) |- ( (--,%P) ==>+- S), (Belief:Contraposition, Permute:Backward)



//// inheritance-based syllogism ////////////////////////////////////////////////////////////////////////////////////
//       (A --> B) ------- (B --> C)
//            \               /
//             \             /
//              \           /
//               \         /
//                (A --> C)
//If A is a special case of B, and B is a special case of C, so is A a special case of C (strong), the other variations are hypotheses (weak)

    (A --> B), (B --> C), neqCom(A,C) |- (A --> C), (Belief:Deduction, Goal:Strong, Permute:Backward)
    (A --> B), (A --> C), neqCom(B,C) |- (C --> B), (Belief:Abduction, Goal:Weak, Permute:Backward)
    (A --> C), (B --> C), neqCom(A,B) |- (A --> B), (Belief:Induction, Goal:Weak, Permute:Backward)
    (A --> B), (B --> C), neqCom(A,C) |- (C --> A), (Belief:Exemplification, Goal:Weak, Permute:Backward)

//// similarity from inheritance ////////////////////////////////////////////////////////////////////////////////////
//If S is a special case of P, and P is a special case of S, then S and P are similar

    (S --> P), (P --> S), neqCom(S,P) |- (S <-> P), (Belief:Intersection, Goal:Strong)

//// inheritance from similarty <- todo check why this one was missing ////////////////////////////////////////////////////////////////////////////////////

    (S <-> P), (P --> S), neqCom(S,P) |- (S --> P), (Belief:ReduceConjunction, Goal:Strong)

//// similarity-based syllogism ////////////////////////////////////////////////////////////////////////////////////
//If P and S are a special case of M, then they might be similar (weak),
//also if P and S are a general case of M

    (P --> M), (S --> M), neqCom(S,P) |- (P <-> S), (Belief:Comparison, Goal:Weak)
    (M --> P), (M --> S), neqCom(S,P) |- (P <-> S), (Belief:Comparison, Goal:Weak)

//If M is a special case of P and S and M are similar, then S is also a special case of P (strong)

    (M --> P), (S <-> M), neqCom(S,P) |- (S --> P), (Belief:Analogy, Goal:Strong)
    (P --> M), (S <-> M), neqCom(S,P) |- (P --> S), (Belief:Analogy, Goal:Strong)
    (M <-> P), (S <-> M), neqCom(S,P) |- (S <-> P), (Belief:Resemblance, Goal:Strong)

//// inheritance composition ////////////////////////////////////////////////////////////////////////////////////
//If P and S are in the intension/extension of M, then union/difference and intersection can be built:
//The duality of extension and intension in NAL corresponds to the
//  duality of intersection and union in set theory â€” intensional intersection
//  corresponds to extensional union, and extensional intersection corresponds
//  to intensional union.

    (P --> M), (S --> M), notSet(S), notSet(P), neqCom(S,P) |- ((S | P) --> M), (Belief:Intersection)
    (P --> M), (S --> M), notSet(S), notSet(P), neqCom(S,P) |- ((S & P) --> M), (Belief:Union)
    (P --> M), (S --> M), notSet(S), notSet(P), neqCom(S,P) |- ((P ~ S) --> M), (Belief:Difference)

    (M --> P), (M --> S), notSet(S), notSet(P), neqCom(S,P) |- (M --> (P & S)), (Belief:Intersection)
    (M --> P), (M --> S), notSet(S), notSet(P), neqCom(S,P) |- (M --> (P | S)), (Belief:Union)
    (M --> P), (M --> S), notSet(S), notSet(P), neqCom(S,P) |- (M --> (P - S)), (Belief:Difference)

//raw product composition
//    (A..+), (B..+) |- ((A..+) | (B..+)), (Belief:Intersection)
//    (A..+), (B..+) |- ((A..+) & (B..+)), (Belief:Union)
//    (A..+), (B..+) |- ((A..+) ~ (B..+)), (Belief:Difference)
//raw product decomposition ?

//// inheritance decomposition ////////////////////////////////////////////////////////////////////////////////////
//if (S --> M) is the case, and ((|,S,A..+) --> M) is not the case, then ((|,A..+) --> M) is not the case, hence Belief:DecomposePositiveNegativeNegative

     (S --> M), ((|,S,A..+) --> M) |- ((|,A..+) --> M), (Belief:DecomposePositiveNegativeNegative)
     (S --> M), ((&,S,A..+) --> M) |- ((&,A..+) --> M), (Belief:DecomposeNegativePositivePositive)

     (M --> S), (M --> (&,S,A..+)) |- (M --> (&,A..+)), (Belief:DecomposePositiveNegativeNegative)
     (M --> S), (M --> (|,S,A..+)) |- (M --> (|,A..+)), (Belief:DecomposeNegativePositivePositive)

     (S --> M), ((S ~ P) --> M) |- (P --> M), (Belief:DecomposePositiveNegativePositive)
     (S --> M), ((P ~ S) --> M) |- (P --> M), (Belief:DecomposeNegativeNegativeNegative)

     (M --> S), (M --> (S - P)) |- (M --> P), (Belief:DecomposePositiveNegativePositive)
     (M --> S), (M --> (P - S)) |- (M --> P), (Belief:DecomposeNegativeNegativeNegative)


//NAL3 single premise inference

    ((|,X,A..+) --> M), X |- ((|,A..+) --> M), (Belief:StructuralDeduction, Goal:StructuralDeduction)
    (M --> (&,X,A..+)), X |- (M --> (&,A..+)), (Belief:StructuralDeduction, Goal:StructuralDeduction)

    ((B ~ G) --> S), G |- (B --> S), (Belief:StructuralDeduction, Goal:StructuralDeduction)
    (R --> (B - S)), S |- (R --> B), (Belief:StructuralDeduction, Goal:StructuralDeduction)


//Set comprehension:

//(C --> A), (C --> B), set_ext(A), union(A,B,R) |- (C --> R), (Truth:Union)
//(C --> A), (C --> B), set_ext(A), intersection(A,B,R) |- (C --> R), (Truth:Intersection)
    (C --> A), (C --> B), setext(A,B) |- (C --> union(A,B)), (Belief:Union)
    (C --> A), (C --> B), setext(A,B) |- (C --> intersect(A,B)), (Belief:Intersection)
    (C --> A), (C --> B), setext(A,B) |- (C --> differ(A,B)), (Belief:Difference)

//(C --> A), (C --> B), set_int(A), union(A,B,R) |- (C --> R), (Truth:Intersection)
//(C --> A), (C --> B), set_int(A), intersection(A,B,R) |- (C --> R), (Truth:Union)
    (C --> A), (C --> B), setint(A,B) |- (C --> union(A,B)), (Belief:Intersection)
    (C --> A), (C --> B), setint(A,B) |- (C --> intersect(A,B)), (Belief:Union)
    (C --> A), (C --> B), setint(A,B) |- (C --> differ(A,B)), (Belief:Difference)

//(A --> C), (B --> C), set_ext(A), union(A,B,R) |- (R --> C), (Truth:Intersection)
//(A --> C), (B --> C), set_ext(A), intersection(A,B,R) |- (R --> C), (Truth:Union)
    (A --> C), (B --> C), setext(A,B) |- (intersect(A,B) --> C), (Belief:Union)
    (A --> C), (B --> C), setext(A,B) |- (union(A,B) --> C), (Belief:Intersection)
    (A --> C), (B --> C), setext(A,B) |- (differ(A,B) --> C), (Belief:Difference)

//(A --> C), (B --> C), set_int(A), union(A,B,R) |- (R --> C), (Truth:Union)
//(A --> C), (B --> C), set_int(A), intersection(A,B,R) |- (R --> C), (Truth:Intersection)
    (A --> C), (B --> C), setint(A,B) |- (union(A,B) --> C), (Belief:Union)
    (A --> C), (B --> C), setint(A,B) |- (intersect(A,B) --> C), (Belief:Intersection)
    (A --> C), (B --> C), setint(A,B) |- (differ(A,B) --> C), (Belief:Difference)

//Set element takeout:

//    (C --> {X,A..+}), C |- (C --> {X}), (Belief:StructuralDeduction)
//    (C --> [X,A..+]), C |- (C --> [X]), (Belief:StructuralDeduction)
//    ({X,A..+} --> C), C |- ({X} --> C), (Belief:StructuralDeduction)
//    ([X,A..+] --> C), C |- ([X] --> C), (Belief:StructuralDeduction)
    (C --> {X,A..+}), {X,A..+}, neqCom(X,C) |- (C --> {X}), (Belief:StructuralDeduction, Goal:StructuralDeduction)
    (C --> [X,A..+]), [X,A..+], neqCom(X,C) |- (C --> [X]), (Belief:StructuralDeduction, Goal:StructuralDeduction)
    ({X,A..+} --> C), {X,A..+}, neqCom(X,C) |- ({X} --> C), (Belief:StructuralDeduction, Goal:StructuralDeduction)
    ([X,A..+] --> C), [X,A..+], neqCom(X,C) |- ([X] --> C), (Belief:StructuralDeduction, Goal:StructuralDeduction)

//// implication-based syllogism ////////////////////////////////////////////////////////////////////////////////////
//       (A ==> B) ------- (B ==> C)
//            \               /
//             \             /
//              \           /
//               \         /
//                (A ==> C)
//If after S M happens, and after M P happens, so P happens after S

    //"Please note that the temporal order in the conclusion of a weak rule is
    //not necessarily the same as the order in the premises, given the hypothetical
    //nature of such a rule."

    (M ==> P), (S ==> M), neqCom(S,P), time(dtUnionReverse), notImplEqui(S), notEqui(P) |- (S ==>+- P), (Belief:Deduction, Permute:Backward)

    (P ==> M), (S ==> M), neqCom(S,P), time(dtBminT), notImplEqui(S), notEqui(P) |- (S ==>+- P), (Belief:Induction, Permute:Backward)

    (M ==> P), (M ==> S), neqCom(S,P), time(dtTminB), notImplEqui(S), notEqui(P) |- (S ==>+- P), (Belief:Abduction, Permute:Backward)

    (P ==> M), (M ==> S), neqCom(S,P), time(dtUnion), notImplEqui(S), notEqui(P) |- (S ==>+- P), (Belief:Exemplification, Permute:Backward)

//// implication to equivalence ////////////////////////////////////////////////////////////////////////////////////
//If when S happens, P happens, and before P happens, S has happened, then they are truth-related equivalent

    (S ==> P), (P ==> S), notImplEqui(S), notImplEqui(P), neqCom(S,P), time(dtCombine) |- (S <=>+- P), (Belief:Intersection)

//// equivalence-based syllogism ////////////////////////////////////////////////////////////////////////////////////
//Same as for inheritance again

    (P ==> M), (S ==> M), notImplEqui(S), notImplEqui(P), neqCom(S,P), time(dtTminB) |- (S <=>+- P), (Belief:Comparison)

    (M ==> P), (M ==> S), notImplEqui(S), notImplEqui(P), neqCom(S,P), time(dtTminB) |- (S <=>+- P), (Belief:Comparison)

    (M <=> P), (S <=> M), notImplEqui(S), notImplEqui(P), neqCom(S,P), time(dtCombine) |- (S <=>+- P), (Belief:Resemblance)

    (M ==> P), (S <=> M), notImplEqui(S), notEqui(P), neqCom(S,P), time(dtTminB) |- (S ==>+- P), (Belief:Analogy)

    (P ==> M), (S <=> M), notImplEqui(S), notEqui(P), neqCom(S,P), time(dtTminB) |- (P ==>+- S), (Belief:Analogy)


//// implication-based composition ////////////////////////////////////////////////////////////////////////////////////
//Same as for inheritance
    //Note: the P && S subterm of the conclusion may get rewritten with appropraite 'dt' as per dtCombinePre/dtCombinePost.
    //otherwise it will remain DTERNAL. using XTERNAL (&&+-) here is more trouble than its worth

    (P ==> M), (S ==> M), neqCom(S,P), time(dtCombinePre) |- ((P && S) ==>+- M), (Belief:Union)
        (P ==> M), (S ==> M), neqCom(S,P), time(dtCombinePre) |- ((%P || %S) ==>+- M), (Belief:Intersection)

    (M ==> P), (M ==> S), neqCom(S,P), time(dtCombinePost) |- (M ==>+- (P && S)), (Belief:Intersection)
        (M ==> P), (M ==> S), neqCom(S,P), time(dtCombinePost) |- (M ==>+- (%P || %S)), (Belief:Union)


//    (D =/> R), (D =\> K), neq(R,K) |- (K =/> R), (Belief:Abduction),
//                                      (R =\> K), (Belief:Induction),
//                                      (K </> R), (Belief:Comparison)

//// implication-based decomposition ////////////////////////////////////////////////////////////////////////////////////
//Same as for inheritance again

    //TODO versions with negated S subterms

    (S ==> M), ((&&,S,A..+) ==> M), time(dtCombine) |- ((&&,A..+) ==>+- M), (Belief:DecomposeNegativePositivePositive)
        //(%S ==> %M), ((||,%S,A..+) ==> M), time(dtCombine) |- ((||,A..+) ==>+- %M), (Belief:DecomposePositiveNegativeNegative)

    (M ==> S), (M ==> (&&,S,A..+)), time(dtCombine) |- (M ==>+- (&&,A..+)), (Belief:DecomposePositiveNegativeNegative)
        //(%M ==> %S), (%M ==> (||,%S,A..+)), time(dtCombine) |- (%M ==>+- (||,A..+)), (Belief:DecomposeNegativePositivePositive)

//// conditional syllogism ////////////////////////////////////////////////////////////////////////////////////
//      + Indep variable elimination
//If after M, P usually happens, and M happens, it means P is expected to happen

//      //NAL7 specific inference ////////////////////////////////////////////////////////////////////////////////////
//      Reasoning about temporal statements. those are using the ==> relation because relation in time is a relation of the truth between statements.


    B, (A ==> C), task(positive), time(decomposeBelief) |- subIfUnifiesAny(C,A,B), (Belief:Deduction, Goal:Induction)
        B, ((--,%A) ==> C), task(negative), time(decomposeBelief) |- subIfUnifiesAny(C,A,B), (Belief:DeductionN, Goal:InductionN)

    B, (C ==> A), time(decomposeBelief) |- subIfUnifiesAny(C,A,B), (Belief:Abduction, Goal:Deduction)
        //B, (C ==> A), task(negative), belief(negative), time(decomposeBelief) |- subIfUnifiesAny(C,A,B), (Belief:AbductionPN, Goal:DeductionPN)

    B, (A <=> C), belief(positive), time(decomposeBelief), neqCom(B,C) |- subIfUnifiesAny(C,A,B), (Belief:Analogy, Goal:Strong)
        B, (A <=> C), belief(negative), time(decomposeBelief), neqCom(B,C) |- subIfUnifiesAny((--,%C),A,B), (Belief:AnalogyPN, Goal:StrongPN)


    //originally these were only valid if A occurrs during or after C. the opposite is not logical and would also produce redundant results
    B, (C && A), task(positive), time(decomposeBelief), neqCom(B,C), notImplEqui(C) |- subIfUnifiesAny(C,A,B), (Goal:Strong)
        B, (C && (--,%A)), task(negative), time(decomposeBelief), neqCom(B,C), notImplEqui(C) |- subIfUnifiesAny(C,A,B), (Goal:StrongN)

        //experimental pos/neg polarization
        //B, (C && (--,%A)), task(negative), time(decomposeBelief) |- subIfUnifiesForward(C,A,B), (Goal:StrongN)


    //// propositional decomposition ////////////////////////////////////////////////////////////////////////////////////
    //If S is the case, and (&&,S,A..+) is not the case, it can't be that (&&,A..+) is the case

    S, (&&,S,A..+), time(decomposeBelief) |- (&&,A..+), (Belief:DecomposePositiveNegativeNegative)
        //S, (||,S,A..+)                        |- (||,A..+), (Belief:DecomposeNegativePositivePositive)
    S, (&&,(--,%S),A..+), time(decomposeBelief) |- (&&,A..+), (Belief:DecomposeNegativeNegativeNegative)
        //S, (||,(--,%S),A..+)                        |- (||,A..+), (Belief:DecomposePositivePositivePositive)



//// conditional composition: ////////////////////////////////////////////////////////////////////////////////////
//They are let out for AGI purpose, don't let the system generate conjunctions or useless <=> and ==> statements
//For this there needs to be a semantic dependence between both, either by the predicate or by the subject,
//or a temporal dependence which acts as special case of semantic dependence
//These cases are handled by "Variable Introduction" and "Temporal Induction"

//    //implications may be constructed with implications for preds but not subjs
//    S, P, commonSubterms(S,P), task(positive), task("."), neqCom(P,S), notImplEqui(S), notEqui(P) |- varIntro((S ==>+- P)), (Belief:Induction)
//        S, P, commonSubterms(S,P), task(negative), task("."), neqCom(P,S), notImplEqui(S), notEqui(P) |- varIntro(((--,%S) ==>+- P)), (Belief:InductionN)
//    S, P, commonSubterms(S,P), task(positive), task("."), neqCom(P,S), notEqui(S), notImplEqui(P) |- varIntro((P ==>+- S)), (Belief:Abduction)
//        S, P, commonSubterms(S,P), task(negative), task("."), neqCom(P,S), notEqui(S), notImplEqui(P) |- varIntro((P ==>+- (--,%S))), (Belief:AbductionN)
//
//    //S, P, time(eternal), task("."), neqCom(P,S), notImplEqui(S), notImplEqui(P) |- varIntro((S <=> P)), (Belief:Comparison)
//    S, P, commonSubterms(S,P), task(positive), task("."), neqCom(P,S), notImplEqui(S), notImplEqui(P) |- varIntro((S <=>+- P)), (Belief:Comparison)
//        S, P, commonSubterms(S,P), task(negative), task("."), neqCom(P,S), notImplEqui(S), notImplEqui(P) |- varIntro((--,(S <=>+- P))), (Belief:ComparisonN)
//
//    S, P, commonSubterms(S,P), task(positive), task("."), neqCom(P,S) |- varIntro((S &&+- P)), (Belief:Intersection)
//        S, P, commonSubterms(S,P), task(negative), task("."), neqCom(P,S) |- varIntro(((--,%S) &&+- P)), (Belief:IntersectionN)
//    //S || P:
//    %S, %P, commonSubterms(S,P), task("."), neqCom(%P,%S) |- (--,varIntro(((--,%S) &&+- (--,%P)))), (Belief:Union)


////Temporal induction: ////////////////////////////////////////////////////////////////////////////////////
//When P and then S happened according to an observation, by induction (weak) it may be that alyways after P, usually S happens.

    //implications may be constructed with implications for preds but not subjs
    A, B, task(positive), task("."), time(dtAfter), neqCom(A,B),                 notImplEqui(A), notEqui(B) |- (A ==>+- B), (Belief:Induction)
    A, B, task(positive), task("."), time(dtAfterOrEternal), neqAndCom(A,B),     notImplEqui(A), notEqui(B) |- varIntro((A ==>+- B)), (Belief:Induction)
        A, B, task(negative), task("."), time(dtAfter), neqCom(A,B),             notImplEqui(A), notEqui(B) |- ((--,%A) ==>+- B), (Belief:InductionN)
        A, B, task(negative), task("."), time(dtAfterOrEternal), neqAndCom(A,B), notImplEqui(A), notEqui(B) |- varIntro(((--,%A) ==>+- B)), (Belief:InductionN)

    A, B, task(positive), task("."), time(dtAfterReverse), neqCom(A,B),                   notEqui(A), notImplEqui(B) |- (B ==>+- A), (Belief:Abduction)
    A, B, task(positive), task("."), time(dtAfterOrEternalReverse), neqAndCom(A,B),       notEqui(A), notImplEqui(B) |- varIntro((B ==>+- A)), (Belief:Abduction)
        A, B, belief(negative), task("."), time(dtAfterReverse), neqCom(A,B),             notEqui(A), notImplEqui(B) |- ((--,%B) ==>+- A), (Belief:AbductionPN)
        A, B, belief(negative), task("."), time(dtAfterOrEternalReverse), neqAndCom(A,B), notEqui(A), notImplEqui(B) |- varIntro(((--,%B) ==>+- A)), (Belief:AbductionPN)
        A, B, task(negative), task("."), time(dtAfterReverse), neqCom(A,B),               notEqui(A), notImplEqui(B) |- (--,(B ==>+- A)), (Belief:AbductionN)
        A, B, task(negative), task("."), time(dtAfterOrEternalReverse), neqAndCom(A,B),   notEqui(A), notImplEqui(B) |- (--,varIntro((B ==>+- A))), (Belief:AbductionN)

    A, B, task(positive), task("."), time(dtAfter), neqCom(A,B),                     notImplEqui(A), notImplEqui(B) |- (A <=>+- B), (Belief:Comparison)
    A, B, task(positive), task("."), time(dtAfterOrEternal), neqAndCom(A,B),         notImplEqui(A), notImplEqui(B) |- varIntro((A <=>+- B)), (Belief:Comparison)
        A, B, task(negative), task("."), time(dtAfter), neqCom(A,B),                 notImplEqui(A), notImplEqui(B) |- (--,(A <=>+- B)), (Belief:ComparisonN)
        A, B, task(negative), task("."), time(dtAfterOrEternal), neqAndCom(A,B),     notImplEqui(A), notImplEqui(B) |- (--,varIntro((A <=>+- B))), (Belief:ComparisonN)

    A, B, task(positive), task("."), time(dtAfter), neqCom(A,B)                                   |- (A &&+- B), (Belief:Intersection)
    A, B, task(positive), task("."), time(dtAfterOrEternal), neqAndCom(A,B)                       |- varIntro((A &&+- B)), (Belief:Intersection)
        A, B, task(positive), belief(negative), task("."), time(dtAfterReverse), neqCom(A,B)             |- (A &&+- (--,%B)), (Belief:IntersectionPN)
        A, B, task(positive), belief(negative), task("."), time(dtAfterOrEternalReverse), neqAndCom(A,B) |- varIntro((A &&+- (--,%B))), (Belief:IntersectionPN)
        A, B, task(negative), task("."), time(dtAfter), neqCom(A,B)                               |- ((--,%A) &&+- B), (Belief:IntersectionN)
        A, B, task(negative), task("."), time(dtAfterOrEternal), neqAndCom(A,B)                   |- varIntro(((--,%A) &&+- B)), (Belief:IntersectionN)

    //S || P:
    S, P, time(dtAfter), task("."), neqCom(P,S) |- (--,((--,%S) &&+- (--,%P))), (Belief:Union)
    S, P, time(dtAfterOrEternal), task("."), neqAndCom(P,S) |- (--,varIntro(((--,%S) &&+- (--,%P)))), (Belief:Union)





//// conjunction decompose AND dependent variable elimination - decomposition with elimination of a variable

     //structural decompose any component of a conjunction.
     //     NOTE: the multi-term decomposition allows the superset of subterms without overlap. if they are chosen only one at a time, then overlap will prevent their recombination to the aforementioned superset result so it is incomplete. thus only the ellipsis form is necessary

     (&&,X,A..+), X, time(decomposeTaskSubset) |-                   (&&,A..+), (Belief:StructuralDeduction,Goal:StructuralDeduction)
        (&&,(--,%X),A..+), X, time(decomposeTaskSubset) |-       (&&,A..+), (Belief:StructuralDeduction,Goal:StructuralDeduction)

     (&&,X,A..+), X, time(decomposeTaskSubset), task("?@") |- (&&,A..+), ()
        (&&,(--,%X),A..+), X, time(decomposeTaskSubset), task("?@") |- (&&,A..+), ()

     (&&,X,A..+), B, time(decomposeTaskSubset) |- subIfUnifiesDep((&&,A..+),X,B), (Belief:AnonymousAnalogy, Goal:Strong)
         //TODO: negation form for this?

//disjunction
    (&&,(--,%B),(--,%A)), B, task("?") |- (||,%B,%A), (Belief:BeliefStructuralDeduction, Punctuation:Belief)

//substitutionViaSimilarity
     X, (B<->C), neqCom(X,C), neq(X,B) |- substitute(X,B,C,strict), (Belief:Intersection, Goal:Intersection)

//desire spreading by similarity (was: Goal:Intersection)
     S, (S<->P) |- P, (Goal:Strong)
        S, ((--,%S)<->P), task(negative)  |- P, (Goal:StrongN)
        S, ((--,%P)<->S), task(negative)  |- (--,%P), (Goal:StrongN)




        //(&&,(--,%X),A..+), X, time(decomposeTask) |- (&&,A..+), (Belief:StructuralDeduction)
     //(&&,X,A..+), B, time(decomposeTask) |- subOnlyIfUnifiesDep((&&,A..+),X,B), (Belief:AnonymousAnalogy, Goal:Strong)


    //decompose (only) the leading event in a conjunction goal
    //(&&,X,A..+), X, time(decomposeTaskIfTermLinkBefore), task("!") |- X, (Goal:StructuralStrong)
        //(&&,(--,%X),A), X, time(decomposeTaskIfTermLinkBefore), task("!") |- (--,%X), (Goal:StructuralStrong)
    //(&&,X,A..+), X, time(decomposeTaskIfBeliefBefore), task("!") |- (&&,A..+), (Goal:StructuralStrong)

        //(&&,(--,%X),A), X, time(decomposeTaskIfTermLinkBefore), task("!") |- A, (Goal:StructuralStrong)
        //TODO as above


        //TODO use ellipsis here?


//// multi-conditional syllogism ////////////////////////////////////////////////////////////////////////////////////
//Inference about the pre/postconditions

    Y, ((&&,X,A..+) ==> B), task(positive), time(dtBeliefExact), notImplEqui(A..+) |- subIfUnifiesAny(((&&,A..+) ==>+- B),X,Y), (Belief:Deduction)
        Y, ((&&,(--,%X),A..+) ==> B), task(negative), time(dtBeliefExact), notImplEqui(A..+) |- subIfUnifiesAny(((&&,A..+) ==>+- B),X,Y), (Belief:DeductionN)

    Y, (B ==> (&&,X,A..+)), task(positive), time(dtBeliefExact), notImplEqui(A..+) |- subIfUnifiesAny((B ==>+- (&&,A..+)),X,Y), (Belief:Deduction)
        Y, (B ==> (&&,(--,%X),A..+)), task(negative), time(dtBeliefExact), notImplEqui(A..+) |- subIfUnifiesAny((B ==>+- (&&,A..+)),X,Y), (Belief:DeductionN)


//conditional abduction
    ((&&,M,X,A..*) ==> C), (Y ==> C) |- subIfUnifiesAny(M,X,Y), (Belief:Abduction)
    ((&&,M,A..+) ==> C), ((&&,A..+) ==> C) |- M, (Belief:Abduction)
        //TODO modify ellipsis to allow these two rules to be expressed as one:
        // ((&&,M,A..+) ==> C), (A..+ ==> C) |- M, (Belief:Abduction)
        //  which will match A..+ to a Conjunction


//Can be derived by NAL7 rules so this won't be necessary there (Order:ForAllSame left out here)

//the first rule does not have Order:ForAllSame because it would be invalid, see: https://groups.google.com/forum/#!topic/open-nars/r5UJo64Qhrk
    //((&&,A..+) ==> C), M, time(dtTask), neqRec(C,M), notImplEqui(M) |- ((&&,M,A..+) ==>+- C), (Belief:Induction)

    ((&&,M,A..+) ==> C), (B ==> M), time(dtUnion), neqCom(C,M), notImplEqui(M), notEqui(C)  |- ((&&,B,A..+) ==>+- C), (Belief:Deduction)
    ((&&,B,A..+) ==> C), (B ==> M), time(dtTminB), neqCom(C,M), notImplEqui(M), notEqui(C)  |- ((&&,M,A..+) ==>+- C), (Belief:Abduction)
    ((&&,M,A..+) ==> C), ((&&,B,A..+) ==> C), time(dtBminT), neqCom(B,M), notEqui(M), notImplEqui(B) |- (B ==>+- M), (Belief:Induction)

//// variable introduction ////////////////////////////////////////////////////////////////////////////////////
//Introduce variables by common subject or predicate

//    (S --> M), (P --> M), task(positive), neq(S,P), time(dtAfterOrEternalReverse) |- ((P --> $X) ==>+- (S --> $X)), (Belief:Abduction)
//        (S --> M), (P --> M), task(negative), neq(S,P), time(dtAfterOrEternalReverse) |- ((P --> $X) ==>+- (--,(S --> $X))), (Belief:AbductionN)
//    (S --> M), (P --> M), task(positive), neq(S,P), time(dtAfterOrEternal) |- ((S --> $X) ==>+- (P --> $X)), (Belief:Induction)
//        (S --> M), (P --> M), task(negative), neq(S,P), time(dtAfterOrEternal) |- ((--,(S --> $X)) ==>+- (P --> $X)), (Belief:InductionN)
//    (S --> M), (P --> M), task(positive), neq(S,P), time(dtForward) |- ((S --> $X) <=>+- (P --> $X)), (Belief:Comparison)
//        (S --> M), (P --> M), task(negative), neq(S,P), time(dtForward) |- ((--,(S --> $X)) <=>+- (P --> $X)), (Belief:ComparisonN)
//    (S --> M), (P --> M), neq(S,P), time(dtAfterOrEternal) |- ((S --> #Y) &&+- (P --> #Y)), (Belief:Intersection)
//
//    (M --> S), (M --> P), task(positive), neq(S,P), time(dtAfterOrEternal) |- (($X --> S) ==>+- ($X --> P)), (Belief:Induction)
//        (M --> S), (M --> P), task(negative), neq(S,P), time(dtAfterOrEternal) |- ((--,($X --> S)) ==>+- ($X --> P)), (Belief:InductionN)
//    (M --> S), (M --> P), task(positive), neq(S,P), time(dtAfterOrEternalReverse) |- (($X --> P) ==>+- ($X --> S)), (Belief:Abduction)
//        (M --> S), (M --> P), task(negative), neq(S,P), time(dtAfterOrEternalReverse) |- (($X --> P) ==>+- (--,($X --> S))), (Belief:AbductionN)
//    (M --> S), (M --> P), task(positive), neq(S,P), time(dtForward) |- (($X --> S) <=>+- ($X --> P)), (Belief:Comparison)
//        (M --> S), (M --> P), task(negative), neq(S,P), time(dtForward) |- ((--,($X --> S)) <=>+- ($X --> P)), (Belief:ComparisonN)
//    (M --> S), (M --> P), neq(S,P), time(dtAfterOrEternal) |- ((#Y --> S) &&+- (#Y --> P)), (Belief:Intersection)


//// 2nd variable introduction ////////////////////////////////////////////////////////////////////////////////////
//, not_equal(A, (M --> S))
//    (A ==> (M --> P)), (M --> S), neq(S,P), neq(A, (M --> S)), time(dtTaskExact) |- ((&&,A,($X --> S)) ==>+- ($X --> P)), (Belief:Induction)
//    (A ==> (M --> P)), (M --> S), neq(S,P), neq(A, (M --> S)), time(dtTaskExact) |- (&&,(A ==> (#Y --> P)), (#Y --> S)), (Belief:Intersection)
//
//    (&&,(M --> P), A..+), (M --> S), neq(S,P), time(dtTaskExact) |- (($Y --> S) ==>+- (&&,($Y --> P), A..+)), (Belief:Induction)
//    (&&,(M --> P), A..+), (M --> S), neq(S,P), time(dtTaskExact) |- (&&,(#Y --> S), (#Y --> P), A..+), (Belief:Intersection)
//
//    (A ==> (P --> M)), (S --> M), neq(S,P), neq(A, (S --> M)), time(dtTaskExact) |- ((&&,A,(P --> $X)) ==>+- (S --> $X)), (Belief:Abduction)
//    (A ==> (P --> M)), (S --> M), neq(S,P), neq(A, (S --> M)), time(dtTaskExact) |- (&&,(A ==> (P --> #Y)), (S --> #Y)), (Belief:Intersection)
//
//    (&&,(P --> M), A..+), (S --> M), neq(S,P), time(dtTaskExact) |- ((S --> $Y) ==>+- (&&,(P --> $Y), A..+)), (Belief:Abduction)
//    (&&,(P --> M), A..+), (S --> M), neq(S,P), time(dtTaskExact) |- (&&, (S --> #Y), (P --> #Y), A..+), (Belief:Intersection)


//conditional abduction by dependent variable

    ((X --> R) ==> Z), ((&&,(#Y --> B),(#Y --> R),A..*) ==> Z), task(positive) |- (X --> B), (Belief:Abduction)
        ((X --> R) ==> Z), ((&&,(#Y --> B),--(#Y --> R),A..*) ==> Z), task(negative) |- (X --> B), (Belief:AbductionN)

// conditional deduction "An inverse inference has been implemented as a form of deduction" https://code.google.com/p/open-nars/issues/detail?id=40&can=1

    (U --> L), ((&&,(#X --> L),(#X --> R),A..*) ==> Z), task(positive), time(dtBeliefExact) |- substitute(((&&,A..*,(U --> R)) ==>+- Z),#X,U,strict), (Belief:Deduction)
        (U --> L), ((&&,--(#X --> L),(#X --> R),A..*) ==> Z), task(negative), time(dtBeliefExact) |- substitute(((&&,A..*,(U --> R)) ==>+- Z),#X,U,strict), (Belief:DeductionN)



//// second level variable handling rules ////////////////////////////////////////////////////////////////////////////////////
//second level variable elimination (termlink level2 growth needed in order for these rules to work)

    (B --> K), (&&,(#X --> L),(($Y --> K) ==> A)), task(positive), time(dtBeliefExact) |- substitute((&&, (#X --> L), A), $Y, B, strict), (Belief:Deduction)
        (B --> K), (&&,(#X --> L),((--,($Y --> K)) ==> A)), task(negative), time(dtBeliefExact) |- substitute((&&, (#X --> L), A), $Y, B, strict), (Belief:DeductionN)
    (B --> K), (($X --> L) ==> (&&,(#Y --> K),A..+)), task(positive), time(dtBeliefExact) |- substitute((($X --> L) ==>+- (&&,A..+)),#Y,B, strict), (Belief:AnonymousAnalogy)
        (B --> K), (($X --> L) ==> (&&,--(#Y --> K),A..+)), task(negative), time(dtBeliefExact) |- substitute((($X --> L) ==>+- (&&,A..+)),#Y,B, strict), (Belief:AnonymousAnalogyN)


//precondition combiner inference rule (variable_unification6):
//  TODO can these also apply to goals somehow?
//  TODO negative versions

    ((&&,C,A..+) ==> Z), ((&&,C,B..+) ==> Z), neqCom(A..+,B..+), time(dtCombine) |- ((&&,A..+) ==>+- (&&,B..+)), (Belief:Induction)
    ((&&,C,A..+) ==> Z), ((&&,C,B..+) ==> Z), neqCom(A..+,B..+), time(dtCombine) |- ((&&,B..+) ==>+- (&&,A..+)), (Belief:Induction)
    (Z ==> (&&,C,A..+)), (Z ==> (&&,C,B..+)), neqCom(A..+,B..+), time(dtCombine) |- ((&&,A..+) ==>+- (&&,B..+)), (Belief:Abduction)
    (Z ==> (&&,C,A..+)), (Z ==> (&&,C,B..+)), neqCom(A..+,B..+), time(dtCombine) |- ((&&,B..+) ==>+- (&&,A..+)), (Belief:Abduction)


//second level variable introduction

//    (Y --> L), ((Y --> S) ==> R), neq(L,S), time(dtBeliefExact) |- substitute(((&&,(#X --> L),(#X --> S)) ==>+- R),Y,#X), (Belief:Induction)
//    (Y --> L), ((&&,(Y --> S),A..+) ==> R), neq(L,S), time(dtBeliefExact) |- substitute(((&&,(#X --> L),(#X --> S),A..+) ==>+- R),Y,#X), (Belief:Intersection)




//    A, B, after(_), neq(A,B), notConjunction(A), notConjunction(B),  notImplEqui(A), notImplEqui(B) |- (B && A), (Belief:Intersection)


//    P, S, after(Task,Belief), measure_time(I), notImplEqui(P), notImplEqui(S) |- ((&/,S,I) =/> P), (Belief:Induction, Eternalize:Immediate),
//                                                                                                                       (P =\> (&/,S,I)), (Belief:Abduction),
//                                                                                                                       ((&/,S,I) </> P), (Belief:Comparison)

//    P, S, after(Task,Belief), notConjunction(P), notConjunction(S),  measure_time(I), notImplEqui(P), notImplEqui(S) |- (&/,S,I,P), (Belief:Intersection)

//    P, S, concurrent(Task,Belief), notImplEqui(P), notImplEqui(S) |- (S =|> P), (Belief:Induction, Eternalize:Immediate),
//                                                                                                          (P =|> S), (Belief:Induction),
//                                                                                                           (S <|> P), (Belief:Comparison)

//    P, S, concurrent(Task,Belief), notConjunction(P), notConjunction(S), notImplEqui(P), notImplEqui(S) |- (&|,S,P), (Belief:Intersection)

////backward inference is mostly handled by the rule transformation:

//    T, B |- C, [post] =>
//          C, B, task("?") |- T, [post]
//          C, T, task("?") |- B, [post]

//backward inference rules which should really only work on backward inference:

    //(A --> S), (B --> S), neqCom(A,B), task("?@") |- (A --> B), ()
    //(A --> S), (B --> S), neqCom(A,B), task("?@") |- (B --> A), ()

    //(A ==> S), (B ==> S), neqCom(A,B), task("?@"), notImplEqui(A), notEqui(B)  |- (A ==>+- B), ()
    //(A ==> S), (B ==> S), neqCom(A,B), task("?@"), notImplEqui(B), notEqui(A)  |- (B ==>+- A), ()

//Inheritance to Similarity

    (S <-> P), (S --> P), neqCom(S,P), task("?") |- (S <-> P), (Belief:StructuralAbduction, Punctuation:Belief)
        //TODO negated subterm variant


//backward temporal induction
    (A ==> B), A, time(decomposeTask), task("?") |- B, (Punctuation:Question)
    ((--,%A) ==> B), A, time(decomposeTask), task("?") |- B, (Punctuation:Question)
    (A ==> B), B, time(decomposeTask), task("?") |- A, (Punctuation:Question)

    //(A <=> B), A, time(decomposeTask), task("?") |- B, (Punctuation:Question)

//If S can stand for P, P can to a certain low degree also represent the class S
//If after S usually P happens, then it might be a good guess that usually before P happens, S happens.

    (P --> S), (S --> P), neqCom(S,P),                                              task("?") |- (P --> S),   (Belief:Conversion, Punctuation:Belief)

    (P ==> S), (S ==> P), neqCom(S,P), time(dtCombine), notImplEqui(P), notEqui(S), task("?") |- (P ==>+- S), (Belief:Conversion, Punctuation:Belief)
    (P ==> S), ((--,%S) ==> P), neqCom(S,P), time(dtCombine), notImplEqui(P), notEqui(S), task("?") |- --(P ==>+- S), (Belief:Conversion, Punctuation:Belief)
    (P ==> S), (S ==> P), belief(negative), neqCom(S,P), time(dtCombine), notImplEqui(P), notEqui(S), task("?") |- ((--,%P) ==>+- S), (Belief:ConversionPN, Punctuation:Belief)

//and the backward inference driven forward inference:

//Similarity to Inheritance

    (S --> P), (S <-> P), neqCom(S,P), task("?") |- (S --> P), (Belief:StructuralIntersection, Punctuation:Belief)
    (S ==> P), (S <=> P), neqCom(S,P), time(dtBeliefExact), task("?") |- (S ==>+- P), (Belief:StructuralIntersection, Punctuation:Belief)

//NAL2:

    ([A] <-> [B]), (A <-> B), task("?") |- ([A] <-> [B]), (Belief:BeliefIdentity, Punctuation:Belief)
    ({A} <-> {B}), (A <-> B), task("?") |- ({A} <-> {B}), (Belief:BeliefIdentity, Punctuation:Belief)

    ([A] --> [B]), (A <-> B), task("?") |- ([A] --> [B]), (Belief:BeliefIdentity, Punctuation:Belief)
    ({A} --> {B}), (A <-> B), task("?") |- ({A} --> {B}), (Belief:BeliefIdentity, Punctuation:Belief)

//experimental:
//    ([A] <-> {B}), (A <-> B), task("?") |- ([A] <-> {B}), (Belief:BeliefIdentity, Punctuation:Belief)
//    ({A} <-> [B]), (A <-> B), task("?") |- ({A} <-> [B]), (Belief:BeliefIdentity, Punctuation:Belief)
//    ([A] --> {B}), (A <-> B), task("?") |- ([A] --> {B}), (Belief:BeliefIdentity, Punctuation:Belief)
//    ({A} --> [B]), (A <-> B), task("?") |- ({A} --> [B]), (Belief:BeliefIdentity, Punctuation:Belief)


//NAL3:

////composition on both sides of a statement:

    ((&,B,A..+) --> (&,X,A..+)), (B --> X), task("?") |- ((&,B,A..+) --> (&,X,A..+)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)
    ((|,B,A..+) --> (|,X,A..+)), (B --> X), task("?") |- ((|,B,A..+) --> (|,X,A..+)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)

    ((-,S,A) --> (-,S,B)), (B --> A), task("?") |- ((-,S,A) --> (-,S,B)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)
    ((~,S,A) --> (~,S,B)), (B --> A), task("?") |- ((~,S,A) --> (~,S,B)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)

////composition on one side of a statement:

    (W --> (|,B,A..+)), (W --> B), task("?") |- (W --> (|,B,A..+)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)
    ((&,B,A..+) --> W), (B --> W), task("?") |- ((&,B,A..+) --> W), (Belief:BeliefStructuralDeduction, Punctuation:Belief)

    (W --> (-,S,B)), (W --> B), neqCom(W,S), task("?") |- (W --> (-,S,B)), (Belief:BeliefStructuralDifference, Punctuation:Belief)
    ((~,S,B) --> W), (B --> W), neqCom(W,S), task("?") |- ((~,S,B) --> W), (Belief:BeliefStructuralDifference, Punctuation:Belief)







//Relation introduction (wastepaper experimental)
//   (A --> C), (B --> D) |- ((A,B) --> (C,D)), (Belief:Intersection)
//   (A --> C), (A --> D) |- ((A,A) --> {C,D}), (Belief:Intersection)
//   (C --> A), (D --> A) |- ({C,D} --> (A,A)), (Belief:Intersection)

//          #_#R[(A --> C) (B --> D) |- ((* A B) --> (* C D)) :post (:t/intersection)] //            ;this one cant be allowed due to control reasons:
//          #R[(A --> C) (A --> D) |- ((* A A) --> (* C D)) :post (:t/intersection)]
//         #R[(A --> C) (B --> C) |- ((* A B) --> (* C C)) :post (:t/intersection)]
//         #R[({A} --> C) (A --> D) |- ((* {A} A) --> (* C D)) :post (:t/intersection)]
//          #R[(A --> C) ({A} --> D) |- ((* A {A}) --> (* C D)) :post (:t/intersection)]
//         #R[(A --> [C]) (B --> C) |- ((* A B) --> (* [C] C)) :post (:t/intersection)]
//         #R[(A --> C) (B --> [C]) |- ((* A B) --> (* C [C])) :post (:t/intersection)]




//TODO for desire

//query-variable queston answering HACK currently this is done better in PremiseGeneration, not here. but this sort of works
//  A, B, task("?") |- subIfUnifiesQuery(B, A, B), (Belief:BeliefIdentity, Punctuation:Belief)



//WASTEPAPER ===

//Single product variations
//    (S), (P), neqRec(S,P) |- (S | P), (Belief:Union),
//                                                  (S & P), (Belief:Intersection),
//                                                  (P ~ S), (Belief:Difference)


//DeMorgan's Law - currently implemented as a reduction but possibly should be a structural rule
    //<sseehh__> it becomes more helpful when there are >2 terms, ex: (&&, --(x), --(y), --(z))
    //<sseehh__> then it can replace N negations with one
    //<sseehh__> then the compound and its opposite resolve to the same compound
    //<patham9> if then I would add it as structural rule
    //<patham9> not as "reduction"
    //<patham9> meaning the system has free choice about the representation
    //<patham9> should have
    //<sseehh__> thats possible
    //<patham9> and I wouldnt apply StructuralDeduction as truth
