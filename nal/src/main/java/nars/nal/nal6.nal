//// implication-based syllogism ////////////////////////////////////////////////////////////////////////////////////
//       (A ==> B) ------- (B ==> C)
//            \               /
//             \             /
//              \           /
//               \         /
//                (A ==> C)
//If after S M happens, and after M P happens, so P happens after S

    //"Please note that the temporal order in the conclusion of a weak rule is
    //not necessarily the same as the order in the premises, given the hypothetical
    //nature of such a rule."

    (M ==> P), (S ==> M), neqCom(P,S), time(dtSum), notImplEqui(S), notEqui(P) |- (S ==>+- P), (Belief:Deduction)
        (S ==> P), (S ==> M), neqCom(P,S), time(dtSum), notImplEqui(S), notEqui(P) |- (S ==>+- P), (Punctuation:Question)

    (P ==> M), (S ==> M), neqCom(P,S), time(dtBminT), notImplEqui(S), notEqui(P) |- (S ==>+- P), (Belief:Induction)

    (M ==> P), (M ==> S), neqCom(P,S), time(dtTminB), notImplEqui(S), notEqui(P) |- (S ==>+- P), (Belief:Abduction)

    (P ==> M), (M ==> S), neqCom(P,S), time(dtSumReverse), notImplEqui(S), notEqui(P)   |- (S ==>+- P), (Belief:Exemplification)


//// implication to equivalence ////////////////////////////////////////////////////////////////////////////////////
//If when S happens, P happens, and before P happens, S has happened, then they are truth-related equivalent

    (S ==> P), (P ==> S), notImplEqui(S), notImplEqui(P), time(dtCombine) |- (P <=>+- S), (Belief:Intersection)

//// equivalence-based syllogism ////////////////////////////////////////////////////////////////////////////////////
//Same as for inheritance again
    //TODO some of these notEqui and notImplEqui can be removed because the premise is already valid in the same way as the conclusion would be

    (M ==> P), (M ==> S), notImplEqui(S), notImplEqui(P), neqCom(P,S), time(dtBminT) |- (P <=>+- S), (Belief:Comparison)

    (P ==> M), (S ==> M), notImplEqui(S), notImplEqui(P), neqCom(P,S), time(dtTminB) |- (P <=>+- S), (Belief:Comparison)

    (M <=> P), (S <=> M), notImplEqui(S), notImplEqui(P), neqCom(P,S), time(dtCombine) |- (P <=>+- S), (Belief:Resemblance)

    (M ==> P), (S <=> M), notImplEqui(S), notEqui(P), neqCom(P,S), time(dtTminB) |- (S ==>+- P), (Belief:Analogy)

    (P ==> M), (S <=> M), notImplEqui(P), notEqui(S), neqCom(P,S), time(dtTminB) |- (P ==>+- S), (Belief:Analogy)


// Contraposition (structural)
// "If not smoking lets you be healthy, being not healthy may be the result of smoking"
// original:	    ( --S ==> P),   P |- ( --P ==> S), (Truth:Contraposition, Derive:AllowBackward)
// original:	    ( --S ==> P), --S |- ( --P ==> S), (Truth:Contraposition, Derive:AllowBackward)

    ( (--,%S) ==> P), ( (--,%S) ==> P), time(dtTaskExact) |- ( (--,%P) ==>+- S),       (Belief:Contraposition)


//// implication-based composition ////////////////////////////////////////////////////////////////////////////////////
//Same as for inheritance
    //Note: the P && S subterm of the conclusion may get rewritten with appropraite 'dt' as per dtCombinePre/dtCombinePost.
    //otherwise it will remain DTERNAL. using XTERNAL (&&+-) here is more trouble than its worth

    (P ==> M), (S ==> M), neqRCom(S,P), time(dtCombinePre) |- ((P && S) ==>+- M), (Belief:Intersection)
        //(P ==> M), (S ==> M), neqCom(P,S), time(dtCombinePre) |- ((%P || %S) ==>+- M), (Belief:Intersection)

    (M ==> P), (M ==> S), neqRCom(S,P), time(dtCombinePost) |- (M ==>+- (P && S)), (Belief:Intersection)
        //(M ==> P), (M ==> S), neqCom(P,S), time(dtCombinePost) |- (M ==>+- (%P || %S)), (Belief:Union)


//// implication-based decomposition ////////////////////////////////////////////////////////////////////////////////////
//Same as for inheritance again


    (S ==> M), ((&&,S,A..+) ==> M), time(dtCombine) |- ((&&,A..+) ==>+- M), (Belief:DecomposeNegativePositivePositive)
        //(S ==> M), ((&&,(--,%S),A..+) ==> M), time(dtCombine) |- ((&&,A..+) ==>+- M), (Belief:DecomposeNegativePositivePositiveN)
        //(%S ==> %M), ((||,%S,A..+) ==> M), time(dtCombine) |- ((||,A..+) ==>+- %M), (Belief:DecomposePositiveNegativeNegative)

    (M ==> S), (M ==> (&&,S,A..+)), time(dtCombine) |- (M ==>+- (&&,A..+)), (Belief:DecomposePositiveNegativeNegative)
        (M ==> S), (M ==> (&&,(--,%S),A..+)), time(dtCombine) |- (M ==>+- (&&,A..+)), (Belief:DecomposePositiveNegativeNegativeN)
        //(%M ==> %S), (%M ==> (||,%S,A..+)), time(dtCombine) |- (%M ==>+- (||,A..+)), (Belief:DecomposeNegativePositivePositive)

    (M ==> C), C, belief("&&"), time(dtTaskExact) |- (M ==>+- dropAnyConj(C)), (Belief:StructuralDeduction)
        ((--,%M) ==> C), C, belief("&&"), time(dtTaskExact) |- ((--,%M) ==>+- dropAnyConj(C)), (Belief:StructuralDeduction)
        //(M ==> (&&,(--,%S),A..+)), M, time(dtTaskExact) |- (M ==>+- (&&,A..+)), (Belief:StructuralDeduction)
    (C ==> M), C, belief("&&"), time(dtTaskExact) |- (dropAnyConj(C) ==>+- M), (Belief:StructuralDeduction)
        (C ==> (--,%M)), C, belief("&&"), time(dtTaskExact) |- (dropAnyConj(C) ==>+- (--,%M)), (Belief:StructuralDeduction)
        //((&&,(--,%S),A..+) ==> M), M, time(dtTaskExact) |- ((&&,A..+) ==>+- M), (Belief:StructuralDeduction)

//// conditional syllogism ////////////////////////////////////////////////////////////////////////////////////
//      + Indep variable elimination
//If after M, P usually happens, and M happens, it means P is expected to happen

// NAL7 specific inference ////////////////////////////////////////////////////////////////////////////////////
//      Reasoning about temporal statements. those are using the ==> relation because relation in time is a relation of the truth between statements.


    B, (A ==> C), belief(positive), time(belief, C, A), notImplEqui(B) |- subIfUnifiesAny(C,A,B), (Belief:Deduction, Goal:Induction)
        B, (A ==> C), belief(negative), time(belief, C, A), notImplEqui(B) |- (--,subIfUnifiesAny(C,A,B)), (Belief:DeductionPN, Goal:InductionPN)
    B, ((--,%A) ==> C), belief(positive), time(belief, C, A), notImplEqui(B) |- subIfUnifiesAny(C,A,B), (Belief:DeductionN, Goal:InductionN)
        B, ((--,%A) ==> C), belief(negative), time(belief, C, A), notImplEqui(B) |- (--,subIfUnifiesAny(C,A,B)), (Belief:DeductionNN, Goal:InductionNN)

    B, (C ==> A), belief(positive), time(belief, C, A), notImplEqui(B) |- subIfUnifiesAny(C,A,B), (Belief:Abduction, Goal:Deduction)
        B, (C ==> A), belief(negative), time(belief, C, A), notImplEqui(B) |- (--,subIfUnifiesAny(C,A,B)), (Belief:AbductionPN, Goal:DeductionPN)
    B, ((--,%C) ==> A), belief(positive), time(belief, C, A), notImplEqui(B) |- subIfUnifiesAny(C,A,B), (Belief:AbductionN, Goal:DeductionN)
        B, ((--,%C) ==> A), belief(negative), time(belief, C, A), notImplEqui(B) |- (--,subIfUnifiesAny(C,A,B)), (Belief:AbductionNN, Goal:DeductionNN)

    B, (A <=> C), neq(C, B), task(positive), belief(positive), time(belief, C, A) |- subIfUnifiesAny(C,A,B), (Belief:Analogy, Goal:Deduction)
    B, (A <=> C), neq(C, B), task(positive), belief(negative), time(belief, C, A) |- (--,subIfUnifiesAny(C,A,B)), (Belief:AnalogyPN, Goal:DeductionPN)
    B, (A <=> C), neq(C, B), task(negative), belief(positive), time(belief, C, A) |- (--,subIfUnifiesAny(C,A,B)), (Belief:AnalogyN, Goal:DeductionN)
    B, (A <=> C), neq(C, B), task(negative), belief(negative), time(belief, C, A) |- subIfUnifiesAny(C,A,B), (Belief:AnalogyNN, Goal:DeductionNN)

            ////desire spreading by equivalence
            //     S, (S<=>P), task(positive), belief(positive) |-      P,  (Goal:Strong)
            //     S, (S<=>P), task(positive), belief(negative) |- (--,%P), (Goal:StrongN)
            //     S, (S<=>P), task(negative), belief(positive) |- (--,%P), (Goal:StrongN)
            //     S, (S<=>P), task(negative), belief(negative) |- (--,%P), (Goal:Strong)

    //answering
    Z, (X==>Y), task("?"), time(dtBeliefExact) |- subIfUnifiesAny((X ==>+- Y), Y, Z), (Belief:BeliefStructuralDeduction, Punctuation:Belief)
    Z, (X==>Y), task("?"), time(dtBeliefExact) |- subIfUnifiesAny((X ==>+- Y), X, Z), (Belief:BeliefStructuralAbduction, Punctuation:Belief)
    Z, (X<=>Y), task("?"), time(dtBeliefExact) |- subIfUnifiesAny((X <=>+- Y), Y, Z), (Belief:BeliefStructuralAnalogy, Punctuation:Belief)

    //strong unification
    (Y==>X),Z,task(".") |- subIfUnifiesAny(X,Y,Z), (Belief:Deduction)
    ((--,%Y)==>X),Z,task(".") |- subIfUnifiesAny(X,Y,Z), (Belief:DeductionPN)
    (X==>Y),Z,task(".") |- subIfUnifiesAny(X,Y,Z), (Belief:Abduction)
    (X<=>Y),Z,task(".") |- subIfUnifiesAny(X,Y,Z), (Belief:Comparison)
        //TODO check the truth here

    //see: https://en.wikipedia.org/wiki/Imperative_logic#Ross.27_Paradox
    //originally these were only valid if A occurrs during or after C. the opposite is not logical and would also produce redundant results
    B, (C && A), time(decomposeBeliefLate), task("!") |- subIfUnifiesAny(C,A,B), (Goal:Strong)
    B, (C && (--,%A)), time(decomposeBeliefLate), task("!") |- subIfUnifiesAny(C,A,B), (Goal:StrongN)
        //B, (C && A), time(decomposeBeliefLate) |- (--,subIfUnifiesAny(C,A,B)), (Goal:StrongN)
        //B, (C && (--,%A)), time(decomposeBeliefLate) |- subIfUnifiesAny(C,A,B), (Goal:StrongN)



//// multi-conditional syllogism ////////////////////////////////////////////////////////////////////////////////////
//Inference about the pre/postconditions

    Y, ((&&,X,A..+) ==> B), task("."), time(dtBeliefExact) |- subIfUnifiesAny(((&&,A..+) ==>+- B),X,Y), (Belief:Deduction)
    Y, ((&&,(--,%X),A..+) ==> B), task("."), time(dtBeliefExact) |- subIfUnifiesAny(((&&,A..+) ==>+- B),X,Y), (Belief:DeductionN)

    Y, (B ==> (&&,X,A..+)), task("."), time(dtBeliefExact) |- subIfUnifiesAny((B ==>+- (&&,A..+)),X,Y), (Belief:Deduction)
    Y, (B ==> (&&,(--,%X),A..+)), task("."), time(dtBeliefExact) |- subIfUnifiesAny((B ==>+- (&&,A..+)),X,Y), (Belief:DeductionN)

//// propositional decomposition ////////////////////////////////////////////////////////////////////////////////////
//If S is the case, and (&&,S,A..+) is not the case, it can't be that (&&,A..+) is the case

    S, (&&,S,A..+), task("."), time(decomposeBelief) |- (&&,A..+), (Belief:DecomposePositiveNegativeNegative)
        //S, (||,S,A..+), time(dtBeliefExact) |- (||,A..+), (Belief:DecomposeNegativePositivePositive)
    S, (&&,(--,%S),A..+), task("."), time(decomposeBelief) |- (&&,A..+), (Belief:DecomposeNegativeNegativeNegative)
        //S, (||,(--,%S),A..+), time(dtBeliefExact) |- (||,A..+), (Belief:DecomposePositivePositivePositive)


//conditional abduction TODO this needs to be 'dt' sensitive

    ((&&,M,X,A..*) ==> C), (Y ==> C), task("."), time(task, M) |- subIfUnifiesAny(M,X,Y), (Belief:Abduction)
    ((&&,M,A..+) ==> C), ((&&,A..+) ==> C), task("."), time(decomposeTask) |- M, (Belief:Abduction)

        //TODO modify ellipsis to allow these two rules to be expressed as one:
        // ((&&,M,A..+) ==> C), (A..+ ==> C) |- M, (Belief:Abduction)
        //  which will match A..+ to a Conjunction


//Can be derived by NAL7 rules so this won't be necessary there (Order:ForAllSame left out here)

//the first rule does not have Order:ForAllSame because it would be invalid, see: https://groups.google.com/forum/#!topic/open-nars/r5UJo64Qhrk
    //((&&,A..+) ==> C), M, time(dtTaskExact), neqRCom(C,M), notImplEqui(M) |- ((&&,M,A..+) ==>+- C), (Belief:Induction)

    ((&&,M,A..+) ==> C), (B ==> M), time(dtSum), neqRCom(C,B)  |- ((&&,B,A..+) ==>+- C), (Belief:Deduction)
    ((&&,B,A..+) ==> C), (B ==> M), time(dtTminB), neqRCom(C,M) |- ((&&,M,A..+) ==>+- C), (Belief:Abduction)
    //((&&,M,A..+) ==> C), ((&&,B,A..+) ==> C), time(dtBminT), neqRCom(B,M), notEqui(M), notImplEqui(B) |- (B ==>+- M), (Belief:Induction)



//conditional abduction by dependent variable

    ((X --> R) ==> Z), ((&&,(#Y --> B),(#Y --> R),A..*) ==> Z)  |- (X --> B), (Belief:Abduction)
        ((X --> R) ==> Z), ((&&,(#Y --> B),--(#Y --> R),A..*) ==> Z) |- (X --> B), (Belief:AbductionN)

// conditional deduction "An inverse inference has been implemented as a form of deduction" https://code.google.com/p/open-nars/issues/detail?id=40&can=1

    (U --> L), ((&&,(#X --> L),(#X --> R),A..*) ==> Z), time(dtBeliefExact) |- substitute(((&&,A..*,(U --> R)) ==>+- Z),#X,U,strict), (Belief:Deduction)
        (U --> L), ((&&,--(#X --> L),(#X --> R),A..*) ==> Z), time(dtBeliefExact) |- substitute(((&&,A..*,(U --> R)) ==>+- Z),#X,U,strict), (Belief:DeductionN)



//// second level variable handling rules ////////////////////////////////////////////////////////////////////////////////////
//second level variable elimination (termlink level2 growth needed in order for these rules to work)

    (B --> K), (&&,(#X --> L),(($Y --> K) ==> A)), time(dtBeliefExact) |- substitute((&&, (#X --> L), A), $Y, B, strict), (Belief:Deduction)
        (B --> K), (&&,(#X --> L),((--,($Y --> K)) ==> A)), time(dtBeliefExact) |- substitute((&&, (#X --> L), A), $Y, B, strict), (Belief:DeductionN)
    (B --> K), (($X --> L) ==> (&&,(#Y --> K),A..+)), time(dtBeliefExact) |- substitute((($X --> L) ==>+- (&&,A..+)),#Y,B, strict), (Belief:AnonymousAnalogy)
        (B --> K), (($X --> L) ==> (&&,--(#Y --> K),A..+)), time(dtBeliefExact) |- substitute((($X --> L) ==>+- (&&,A..+)),#Y,B, strict), (Belief:AnonymousAnalogyN)


//precondition combiner inference rule (variable_unification6):
//  TODO can these also apply to goals somehow?
//  TODO negative versions

//    ((&&,C,A..+) ==> Z), ((&&,C,B..+) ==> Z), neq(A..+,B..+), time(dtTminB) |- ((&&,A..+) ==>+- (&&,B..+)), (Belief:Induction)
//    ((&&,C,A..+) ==> Z), ((&&,C,B..+) ==> Z), neq(A..+,B..+), time(dtBminT) |- ((&&,B..+) ==>+- (&&,A..+)), (Belief:Induction)
//    (Z ==> (&&,C,A..+)), (Z ==> (&&,C,B..+)), neq(A..+,B..+), time(dtTminB) |- ((&&,A..+) ==>+- (&&,B..+)), (Belief:Abduction)
//    (Z ==> (&&,C,A..+)), (Z ==> (&&,C,B..+)), neq(A..+,B..+), time(dtBminT) |- ((&&,B..+) ==>+- (&&,A..+)), (Belief:Abduction)


    //(X ==> Y), (X ==> Y), task("?"), time(dtTaskExact) |- (?1 ==>+- Y), (Punctuation:Question)
    //(X ==> Y), (X ==> Y), task("?"), time(dtTaskExact) |- (X ==>+- ?1), (Punctuation:Question)

