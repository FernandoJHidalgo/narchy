

//// conjunction decompose AND dependent variable elimination - decomposition with elimination of a variable

     //structural decompose any component of a conjunction.
     //     NOTE: the multi-term decomposition allows the superset of subterms without overlap. if they are chosen only one at a time, then overlap will prevent their recombination to the aforementioned superset result so it is incomplete. thus only the ellipsis form is necessary

     C, X, time(decomposeTaskSubset) |- dropAnyConj(C), (Belief:StructuralDeduction, Goal:StructuralDeduction)
        //TODO add a conj() guard to fast fail
        //(&&,(--,%X),A..+), X, time(task, esubterm((A..+)), X) |- (&&,A..+), (Belief:StructuralDeduction, Goal:StructuralDeduction)

     ((&&,X,A..+) &&+- Z), Z, time(decomposeTaskComponents) |- (X &&+- Z), (Belief:StructuralDeduction, Goal:StructuralDeduction)
     (Z &&+- (&&,X,A..+)), Z, time(decomposeTaskComponents) |- (Z &&+- X), (Belief:StructuralDeduction, Goal:StructuralDeduction)
        ((&&,X,A..+) &&+- (--,%Z)), Z, time(decomposeTaskComponents) |- (X &&+- (--,%Z)), (Belief:StructuralDeduction, Goal:StructuralDeduction)
        ((--,%Z) &&+- (&&,X,A..+)), Z, time(decomposeTaskComponents) |- ((--,%Z) &&+- X), (Belief:StructuralDeduction, Goal:StructuralDeduction)

     (&&,X,A..+), B, task("!"), time(task, esubterm((A..+), 0)) |- subIfUnifiesAny((&&,A..+),X,B,strict), (Goal:Strong)
        (&&,(--,%X),A..+), B,  task("!"), time(task, esubterm((A..+), 0)) |- subIfUnifiesAny((&&,A..+),X,B,strict), (Goal:StrongPN)

     //X, (&&,X,A..+),            task("?@"), time(decomposeBelief) |- (&&,A..+), ()
     //   X, (&&,(--,%X),A..+),   task("?@"), time(decomposeBelief) |- (&&,A..+), ()
     //B, (A==>B),                task("?@"), time(decomposeBelief) |- A, ()
     //A, (A==>B),                task("?@"), time(decomposeBelief) |- B, ()
     //A, ((--,%A)==>B),          task("?@"), time(decomposeBelief) |- B, ()

     //quest to 'how' question
     //B, X, neqRCom(B,X), task("@"), time(dtEventsOrEternals), notImplEqui(B), notEqui(X) |- (B ==>+- X), (Punctuation:Question)
     //B, X, neqRCom(B,X), task("@"), time(dtEventsOrEternals), notImplEqui(B), notEqui(X) |- ((--,%B) ==>+- X), (Punctuation:Question)

     //(&&,X,A..+), X, time(decomposeTaskSubset), task("?@") |- (&&,A..+), ()
     //   (&&,(--,%X),A..+), X, time(decomposeTaskSubset), task("?@") |- (&&,A..+), ()

     B, (&&,X,A..+), time(decomposeBelief) |- subIfUnifiesDep((&&,A..+),X,B,strict), (Belief:AnonymousAnalogy)
                //,Goal:Deduction
                //Goal:Goduction)

///// conjunction decompose
//
//    (&&,A_1..n), A_1 |- A_1, (Truth:StructuralDeduction, Desire:StructuralStrong)
//    (&/,A_1..n), A_1 |- A_1, (Truth:StructuralDeduction, Desire:StructuralStrong)
//    (&|,A_1..n), A_1 |- A_1, (Truth:StructuralDeduction, Desire:StructuralStrong)
//    (&/,B,A_1..n), B, task("!") |- (&/,A_1..n), (Truth:Deduction, Desire:Strong, SequenceIntervals:FromPremises)
//
////// propositional decomposition ////////////////////////////////////////////////////////////////////////////////////
////If S is the case, and (&&,S,A_1..n) is not the case, it can't be that (&&,A_1..n) is the case
//
//    S, (&/,S,A_1..n) |- (&/,A_1..n), (Truth:DecomposePositiveNegativeNegative, SequenceIntervals:FromPremises)
//    S, (&|,S,A_1..n) |- (&|,A_1..n), (Truth:DecomposePositiveNegativeNegative)
//    S, (&&,S,A_1..n) |- (&&,A_1..n), (Truth:DecomposePositiveNegativeNegative)
//    S, (||,S,A_1..n) |- (||,A_1..n), (Truth:DecomposeNegativePositivePositive)
//
////Additional for negation: https://groups.google.com/forum/#!topic/open-nars/g-7r0jjq2Vc
//
//    S, (&/,(--,S),A_1..n) |- (&/,A_1..n), (Truth:DecomposeNegativeNegativeNegative, SequenceIntervals:FromPremises)
//    S, (&|,(--,S),A_1..n) |- (&|,A_1..n), (Truth:DecomposeNegativeNegativeNegative)
//    S, (&&,(--,S),A_1..n) |- (&&,A_1..n), (Truth:DecomposeNegativeNegativeNegative)
//    S, (||,(--,S),A_1..n) |- (||,A_1..n), (Truth:DecomposePositivePositivePositive)



//substitutionViaSimilarity
     X, (B<->C), neqCom(X,C), neq(X,B) |- substitute(X,B,C,strict), (Belief:Intersection, Goal:Strong)

//needs special temporal handling to shift occurrence time of result if the <=> has a non-zero non-eternal dt
     X, (B<=>C), neqCom(X,C), neq(X,B), time(beliefDTSimultaneous) |- substitute(X,B,C,strict), (Belief:Intersection, Goal:Strong)

//INVALID:
//desire spreading by similarity (was: Goal:Intersection)
//     S, (S<->P) |- P, (Goal:Strong)
//        S, ((--,%S)<->P), task(negative)  |- P, (Goal:StrongN)
//        S, ((--,%P)<->S), task(negative)  |- (--,%P), (Goal:StrongN)




//Inheritance to Similarity

    (S <-> P), (S --> P), task("?") |- (S <-> P), (Belief:StructuralAbduction, Punctuation:Belief)
        //TODO negated subterm variant



//If S can stand for P, P can to a certain low degree also represent the class S
//If after S usually P happens, then it might be a good guess that usually before P happens, S happens.

    (P --> S), (S --> P),                               task("?") |- (P --> S),   (Belief:Conversion, Punctuation:Belief)
    (P ==> S), (S ==> P), time(dtBeliefReverse),        task("?") |- (P ==>+- S), (Belief:Conversion, Punctuation:Belief)
    (P ==> S), ((--,%S) ==> P), time(dtBeliefReverse),  task("?") |- (--,(P ==>+- S)), (Belief:Conversion, Punctuation:Belief)
    (P ==> S), (S ==> P), time(dtBeliefReverse),        task("?") |- ((--,%P) ==>+- S), (Belief:ConversionPN, Punctuation:Belief)
    (P ==> S), ((--,%S) ==> P), time(dtBeliefReverse),  task("?") |- (--,((--,%P) ==>+- S)), (Belief:ConversionPN, Punctuation:Belief)

//and the backward inference driven forward inference:

//Similarity to Inheritance

    (S --> P), (S <-> P),                   task("?") |- (S --> P),   (Belief:StructuralIntersection, Punctuation:Belief)
    (S ==> P), (S <=> P), time(dtCombine),  task("?") |- (S ==>+- P), (Belief:StructuralIntersection, Punctuation:Belief)

//NAL2:

    ([A] <-> [B]), (A <-> B), task("?") |- ([A] <-> [B]), (Belief:BeliefIdentity, Punctuation:Belief)
    ({A} <-> {B}), (A <-> B), task("?") |- ({A} <-> {B}), (Belief:BeliefIdentity, Punctuation:Belief)

    ([A] --> [B]), (A <-> B), task("?") |- ([A] --> [B]), (Belief:BeliefIdentity, Punctuation:Belief)
    ({A} --> {B}), (A <-> B), task("?") |- ({A} --> {B}), (Belief:BeliefIdentity, Punctuation:Belief)

//experimental:
//    ([A] <-> {B}), (A <-> B), task("?") |- ([A] <-> {B}), (Belief:BeliefIdentity, Punctuation:Belief)
//    ({A} <-> [B]), (A <-> B), task("?") |- ({A} <-> [B]), (Belief:BeliefIdentity, Punctuation:Belief)
//    ([A] --> {B}), (A <-> B), task("?") |- ([A] --> {B}), (Belief:BeliefIdentity, Punctuation:Belief)
//    ({A} --> [B]), (A <-> B), task("?") |- ({A} --> [B]), (Belief:BeliefIdentity, Punctuation:Belief)


//NAL3:

//TODO these may produce invalid beliefs if the input contains a query variable, this can be filtered before the rule is processed:

////composition on both sides of a statement:

    ((&,B,A..+) --> (&,X,A..+)), (B --> X), task("?") |- ((&,B,A..+) --> (&,X,A..+)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)
    ((|,B,A..+) --> (|,X,A..+)), (B --> X), task("?") |- ((|,B,A..+) --> (|,X,A..+)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)

    ((-,S,A) --> (-,S,B)), (B --> A), task("?") |- ((-,S,A) --> (-,S,B)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)
    ((~,S,A) --> (~,S,B)), (B --> A), task("?") |- ((~,S,A) --> (~,S,B)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)

////composition on one side of a statement:

    (W --> (|,B,A..+)), (W --> B), task("?") |- (W --> (|,B,A..+)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)
    ((&,B,A..+) --> W), (B --> W), task("?") |- ((&,B,A..+) --> W), (Belief:BeliefStructuralDeduction, Punctuation:Belief)

    (W --> (-,S,B)), (W --> B), task("?"), neqRCom(S,B) |- (W --> (-,S,B)), (Belief:BeliefStructuralDifference, Punctuation:Belief)
    ((~,S,B) --> W), (B --> W), task("?"), neqRCom(S,B) |- ((~,S,B) --> W), (Belief:BeliefStructuralDifference, Punctuation:Belief)


//disjunction
   (&&,(--,%B),A..+), B, task("?") |- (--,(&&,(--,%B),A..+)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)

////composition on both sides of a statement  TODO - quests handling of these
    ((A..+) --> Z), (X --> Y), task("?") |- ((A..+) --> substitute((A..+),X,Y,strict)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)
        //contains(A..+,X),
    (Z --> (A..+)), (X --> Y), task("?") |- (substitute((A..+),X,Y,strict) --> (A..+)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)

    ((A..+) <-> Z), (X <-> Y), task("?") |- ((A..+) <-> substitute((A..+),X,Y,strict)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)
        //this one needs reviewed, it might need to be subIfUnified, and other problems


//query-variable queston answering HACK currently this is done better in PremiseGeneration, not here. but this sort of works
//  A, B, task("?") |- subIfUnifiesQuery(B, A, B), (Belief:BeliefIdentity, Punctuation:Belief)



//WASTEPAPER ===

//Single product variations
//    (S), (P), neqRec(S,P) |- (S | P), (Belief:Union),
//                                                  (S & P), (Belief:Intersection),
//                                                  (P ~ S), (Belief:Difference)


//DeMorgan's Law - currently implemented as a reduction but possibly should be a structural rule
    //<sseehh__> it becomes more helpful when there are >2 terms, ex: (&&, --(x), --(y), --(z))
    //<sseehh__> then it can replace N negations with one
    //<sseehh__> then the compound and its opposite resolve to the same compound
    //<patham9> if then I would add it as structural rule
    //<patham9> not as "reduction"
    //<patham9> meaning the system has free choice about the representation
    //<patham9> should have
    //<sseehh__> thats possible
    //<patham9> and I wouldnt apply StructuralDeduction as truth
