

//substitutionViaSimilarity
     (&&,X,A..+), (X<->Y), time(dtTaskExact)  |- (&&,Y,A..+), (Belief:Intersection, Goal:Strong)
        (&&,(--,%X),A..+), (X<->Y), time(dtTaskExact)  |- (&&,(--,%Y),A..+), (Belief:Intersection, Goal:Strong)
     (&&,X,A..+), (X<=>Y), time(dtTaskExact)  |- (&&,Y,A..+), (Belief:Intersection, Goal:Strong)
        (&&,(--,%X),A..+), (X<=>Y), time(dtTaskExact)  |- (&&,(--,%Y),A..+), (Belief:Intersection, Goal:Strong)
     (X ==> Z), (X<->Y), time(dtTaskExact) |- (Y ==>+- Z), (Belief:Intersection)
        ((--,%X) ==> Z), (X<->Y), time(dtTaskExact) |- ((--,%Y) ==>+- Z), (Belief:Intersection)
     (X ==> Z), (X<=>Y), time(dtTaskExact) |- (Y ==>+- Z), (Belief:Intersection)
        ((--,%X) ==> Z), (X<=>Y), time(dtTaskExact) |- ((--,%Y) ==>+- Z), (Belief:Intersection)
     (Z ==> X), (X<->Y), time(dtTaskExact) |- (Z ==>+- Y), (Belief:Intersection)
        (Z ==> (--,%X)), (X<->Y), time(dtTaskExact) |- (Z ==> (--,%Y)), (Belief:Intersection)
     (Z ==> X), (X<=>Y), time(dtTaskExact) |- (Z ==>+- Y), (Belief:Intersection)
        (Z ==> (--,%X)), (X<=>Y), time(dtTaskExact) |- (Z ==> (--,%Y)), (Belief:Intersection)

//needs special temporal handling to shift occurrence time of result if the <=> has a non-zero non-eternal dt
     X, (B<=>C), task(positive), neqCom(X,C), time(beliefDTSimultaneous) |- subIfUnifiesAny(C,B,X), (Belief:Intersection, Goal:Strong)
     X, (B<=>C), task(negative), neqCom(X,C), time(beliefDTSimultaneous) |- subIfUnifiesAny((--,%C),B,X), (Belief:IntersectionN, Goal:StrongN)




//INVALID:
//desire spreading by similarity (was: Goal:Intersection)
//     S, (S<->P) |- P, (Goal:Strong)
//        S, ((--,%S)<->P), task(negative)  |- P, (Goal:StrongN)
//        S, ((--,%P)<->S), task(negative)  |- (--,%P), (Goal:StrongN)




//Inheritance to Similarity

    (S <-> P), (S --> P), task("?") |- (S <-> P), (Belief:StructuralAbduction, Punctuation:Belief)
        //TODO negated subterm variant



//If S can stand for P, P can to a certain low degree also represent the class S
//If after S usually P happens, then it might be a good guess that usually before P happens, S happens.

    (P --> S), (S --> P),                               task("?") |- (P --> S),   (Belief:Conversion, Punctuation:Belief)
    (P ==> S), (S ==> P), time(dtBeliefReverse),        task("?") |- (P ==> S), (Belief:Conversion, Punctuation:Belief)
    (P ==> S), ((--,%S) ==> P), time(dtBeliefReverse),  task("?") |- (--,(P ==> S)), (Belief:Conversion, Punctuation:Belief)
    (P ==> S), (S ==> P), time(dtBeliefReverse),        task("?") |- ((--,%P) ==> S), (Belief:ConversionPN, Punctuation:Belief)
    (P ==> S), ((--,%S) ==> P), time(dtBeliefReverse),  task("?") |- (--,((--,%P) ==> S)), (Belief:ConversionPN, Punctuation:Belief)

//and the backward inference driven forward inference:

//Similarity to Inheritance

    (S --> P), (S <-> P),                   task("?") |- (S --> P),   (Belief:StructuralIntersection, Punctuation:Belief)
    (S --> P), (S <-> P),                   task("@") |- (S --> P),   (Goal:StructuralIntersection, Punctuation:Goal)
    (S ==> P), (S <=> P), time(dtCombine),  task("?") |- (S ==>+- P), (Belief:StructuralIntersection, Punctuation:Belief)


//experimental:
//    ([A] <-> {B}), (A <-> B), task("?") |- ([A] <-> {B}), (Belief:BeliefIdentity, Punctuation:Belief)
//    ({A} <-> [B]), (A <-> B), task("?") |- ({A} <-> [B]), (Belief:BeliefIdentity, Punctuation:Belief)
//    ([A] --> {B}), (A <-> B), task("?") |- ([A] --> {B}), (Belief:BeliefIdentity, Punctuation:Belief)
//    ({A} --> [B]), (A <-> B), task("?") |- ({A} --> [B]), (Belief:BeliefIdentity, Punctuation:Belief)


//NAL3:

//TODO these may produce invalid beliefs if the input contains a query variable, this can be filtered before the rule is processed:



//disjunction
   (&&,(--,%B),A..+), B, task("?") |- (--,(&&,(--,%B),A..+)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)

////composition on both sides of a statement  TODO - quests handling of these
    ((A..+) --> Z), (X --> Y), task("?") |- ((A..+) --> substitute((A..+),X,Y,strict)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)
        //contains(A..+,X),
    (Z --> (A..+)), (X --> Y), task("?") |- (substitute((A..+),X,Y,strict) --> (A..+)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)

    ((A..+) <-> Z), (X <-> Y), task("?") |- ((A..+) <-> substitute((A..+),X,Y,strict)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)
        //this one needs reviewed, it might need to be subIfUnified, and other problems


//WASTEPAPER ===

//Single product variations
//    (S), (P), neqRec(S,P) |- (S | P), (Belief:Union),
//                                                  (S & P), (Belief:Intersection),
//                                                  (P ~ S), (Belief:Difference)


//DeMorgan's Law - currently implemented as a reduction but possibly should be a structural rule
    //<sseehh__> it becomes more helpful when there are >2 terms, ex: (&&, --(x), --(y), --(z))
    //<sseehh__> then it can replace N negations with one
    //<sseehh__> then the compound and its opposite resolve to the same compound
    //<patham9> if then I would add it as structural rule
    //<patham9> not as "reduction"
    //<patham9> meaning the system has free choice about the representation
    //<patham9> should have
    //<sseehh__> thats possible
    //<patham9> and I wouldnt apply StructuralDeduction as truth


