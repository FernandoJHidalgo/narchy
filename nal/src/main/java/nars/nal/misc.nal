

//// conjunction decompose AND dependent variable elimination - decomposition with elimination of a variable

     //structural decompose any component of a conjunction.
     //     NOTE: the multi-term decomposition allows the superset of subterms without overlap. if they are chosen only one at a time, then overlap will prevent their recombination to the aforementioned superset result so it is incomplete. thus only the ellipsis form is necessary

     (&&,X,A..+), X, time(decomposeTaskSubset) |- (&&,A..+), (Belief:StructuralDeduction, Goal:StructuralDeduction)
        (&&,(--,%X),A..+), X, time(decomposeTaskSubset) |- (&&,A..+), (Belief:StructuralDeduction, Goal:StructuralDeduction)


     //not working right:
     ((&&,X,A..+) &&+- Z), Z, time(decomposeTaskComponents) |- (X &&+- Z), (Belief:StructuralDeduction, Goal:StructuralDeduction)
     (Z &&+- (&&,X,A..+)), Z, time(decomposeTaskComponents) |- (Z &&+- X), (Belief:StructuralDeduction, Goal:StructuralDeduction)
        ((&&,X,A..+) &&+- (--,%Z)), Z, time(decomposeTaskComponents) |- (X &&+- (--,%Z)), (Belief:StructuralDeduction, Goal:StructuralDeduction)
        ((--,%Z) &&+- (&&,X,A..+)), Z, time(decomposeTaskComponents) |- ((--,%Z) &&+- X), (Belief:StructuralDeduction, Goal:StructuralDeduction)

     (&&,X,A..+), B, task("!"), time(decomposeTaskSubset) |- subIfUnifiesAny((&&,A..+),X,B), (Goal:Strong)
        (&&,(--,%X),A..+), B,  task("!"), time(decomposeTaskSubset), belief(negative) |- subIfUnifiesAny((&&,A..+),X,B), (Goal:StrongPN)
        // ^ check this negation condition

     X, (&&,X,A..+), time(decomposeBelief), task("?@") |- (&&,A..+), ()
        X, (&&,(--,%X),A..+), time(decomposeBelief), task("?@") |- (&&,A..+), ()
     B, (A==>B), time(decomposeBelief), task("?@") |- A, ()

     //quest to 'how' question
     //B, X, neq(B,X), task("@"), time(dtAfterOrEternal), notImplEqui(B), notEqui(X) |- (B ==>+- X), (Punctuation:Question)
     //B, X, neq(B,X), task("@"), time(dtAfterOrEternal), notImplEqui(B), notEqui(X) |- ((--,%B) ==>+- X), (Punctuation:Question)

     (&&,X,A..+), X, time(decomposeTaskSubset), task("?@") |- (&&,A..+), ()
        (&&,(--,%X),A..+), X, time(decomposeTaskSubset), task("?@") |- (&&,A..+), ()

     B, (&&,X,A..+), time(decomposeBelief) |- subIfUnifiesDep((&&,A..+),X,B), (Belief:AnonymousAnalogy, Goal:StructuralGoduction)

///// conjunction decompose
//
//    (&&,A_1..n), A_1 |- A_1, (Truth:StructuralDeduction, Desire:StructuralStrong)
//    (&/,A_1..n), A_1 |- A_1, (Truth:StructuralDeduction, Desire:StructuralStrong)
//    (&|,A_1..n), A_1 |- A_1, (Truth:StructuralDeduction, Desire:StructuralStrong)
//    (&/,B,A_1..n), B, task("!") |- (&/,A_1..n), (Truth:Deduction, Desire:Strong, SequenceIntervals:FromPremises)
//
////// propositional decomposition ////////////////////////////////////////////////////////////////////////////////////
////If S is the case, and (&&,S,A_1..n) is not the case, it can't be that (&&,A_1..n) is the case
//
//    S, (&/,S,A_1..n) |- (&/,A_1..n), (Truth:DecomposePositiveNegativeNegative, SequenceIntervals:FromPremises)
//    S, (&|,S,A_1..n) |- (&|,A_1..n), (Truth:DecomposePositiveNegativeNegative)
//    S, (&&,S,A_1..n) |- (&&,A_1..n), (Truth:DecomposePositiveNegativeNegative)
//    S, (||,S,A_1..n) |- (||,A_1..n), (Truth:DecomposeNegativePositivePositive)
//
////Additional for negation: https://groups.google.com/forum/#!topic/open-nars/g-7r0jjq2Vc
//
//    S, (&/,(--,S),A_1..n) |- (&/,A_1..n), (Truth:DecomposeNegativeNegativeNegative, SequenceIntervals:FromPremises)
//    S, (&|,(--,S),A_1..n) |- (&|,A_1..n), (Truth:DecomposeNegativeNegativeNegative)
//    S, (&&,(--,S),A_1..n) |- (&&,A_1..n), (Truth:DecomposeNegativeNegativeNegative)
//    S, (||,(--,S),A_1..n) |- (||,A_1..n), (Truth:DecomposePositivePositivePositive)



//substitutionViaSimilarity
     X, (B<->C), neqCom(X,C), neq(X,B) |- substitute(X,B,C,strict), (Belief:Intersection, Goal:Strong)

//needs special temporal handling to shift occurrence time of result if the <=> has a non-zero non-eternal dt
     X, (B<=>C), neqCom(X,C), neq(X,B), time(beliefDTSimultaneous) |- substitute(X,B,C,strict), (Belief:Intersection, Goal:Strong)

//INVALID:
//desire spreading by similarity (was: Goal:Intersection)
//     S, (S<->P) |- P, (Goal:Strong)
//        S, ((--,%S)<->P), task(negative)  |- P, (Goal:StrongN)
//        S, ((--,%P)<->S), task(negative)  |- (--,%P), (Goal:StrongN)




//Inheritance to Similarity

    (S <-> P), (S --> P), task("?") |- (S <-> P), (Belief:StructuralAbduction, Punctuation:Belief)
        //TODO negated subterm variant



//If S can stand for P, P can to a certain low degree also represent the class S
//If after S usually P happens, then it might be a good guess that usually before P happens, S happens.

    (P --> S), (S --> P),                                                 task("?") |- (P --> S),   (Belief:Conversion, Punctuation:Belief)
    (P ==> S), (S ==> P), belief(positive), time(dtBeliefReverse),        task("?") |- (P ==>+- S), (Belief:Conversion, Punctuation:Belief)
    (P ==> S), ((--,%S) ==> P), belief(positive), time(dtBeliefReverse),  task("?") |- (--,(P ==>+- S)), (Belief:Conversion, Punctuation:Belief)
    (P ==> S), (S ==> P), belief(negative), time(dtBeliefReverse),        task("?") |- ((--,%P) ==>+- S), (Belief:ConversionPN, Punctuation:Belief)
    (P ==> S), ((--,%S) ==> P), belief(negative), time(dtBeliefReverse),  task("?") |- (--,((--,%P) ==>+- S)), (Belief:ConversionPN, Punctuation:Belief)

//and the backward inference driven forward inference:

//Similarity to Inheritance

    (S --> P), (S <-> P),                       task("?") |- (S --> P),   (Belief:StructuralIntersection, Punctuation:Belief)
    (S ==> P), (S <=> P), time(dtBeliefExact),  task("?") |- (S ==>+- P), (Belief:StructuralIntersection, Punctuation:Belief)



//NAL2:

    ([A] <-> [B]), (A <-> B), task("?") |- ([A] <-> [B]), (Belief:BeliefIdentity, Punctuation:Belief)
    ({A} <-> {B}), (A <-> B), task("?") |- ({A} <-> {B}), (Belief:BeliefIdentity, Punctuation:Belief)

    ([A] --> [B]), (A <-> B), task("?") |- ([A] --> [B]), (Belief:BeliefIdentity, Punctuation:Belief)
    ({A} --> {B}), (A <-> B), task("?") |- ({A} --> {B}), (Belief:BeliefIdentity, Punctuation:Belief)

//experimental:
//    ([A] <-> {B}), (A <-> B), task("?") |- ([A] <-> {B}), (Belief:BeliefIdentity, Punctuation:Belief)
//    ({A} <-> [B]), (A <-> B), task("?") |- ({A} <-> [B]), (Belief:BeliefIdentity, Punctuation:Belief)
//    ([A] --> {B}), (A <-> B), task("?") |- ([A] --> {B}), (Belief:BeliefIdentity, Punctuation:Belief)
//    ({A} --> [B]), (A <-> B), task("?") |- ({A} --> [B]), (Belief:BeliefIdentity, Punctuation:Belief)


//NAL3:

//TODO these may produce invalid beliefs if the input contains a query variable, this can be filtered before the rule is processed:

////composition on both sides of a statement:

    ((&,B,A..+) --> (&,X,A..+)), (B --> X), task("?") |- ((&,B,A..+) --> (&,X,A..+)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)
    ((|,B,A..+) --> (|,X,A..+)), (B --> X), task("?") |- ((|,B,A..+) --> (|,X,A..+)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)

    ((-,S,A) --> (-,S,B)), (B --> A), task("?") |- ((-,S,A) --> (-,S,B)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)
    ((~,S,A) --> (~,S,B)), (B --> A), task("?") |- ((~,S,A) --> (~,S,B)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)

////composition on one side of a statement:

    (W --> (|,B,A..+)), (W --> B), task("?") |- (W --> (|,B,A..+)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)
    ((&,B,A..+) --> W), (B --> W), task("?") |- ((&,B,A..+) --> W), (Belief:BeliefStructuralDeduction, Punctuation:Belief)

    (W --> (-,S,B)), (W --> B), neqCom(W,S), task("?") |- (W --> (-,S,B)), (Belief:BeliefStructuralDifference, Punctuation:Belief)
    ((~,S,B) --> W), (B --> W), neqCom(W,S), task("?") |- ((~,S,B) --> W), (Belief:BeliefStructuralDifference, Punctuation:Belief)


//disjunction
    (&&,(--,%B),(--,%A)), B, task("?") |- (||,%B,%A), (Belief:BeliefStructuralDeduction, Punctuation:Belief)





//Relation introduction (wastepaper experimental)
//   (A --> C), (B --> D) |- ((A,B) --> (C,D)), (Belief:Intersection)
//   (A --> C), (A --> D) |- ((A,A) --> {C,D}), (Belief:Intersection)
//   (C --> A), (D --> A) |- ({C,D} --> (A,A)), (Belief:Intersection)

//          #_#R[(A --> C) (B --> D) |- ((* A B) --> (* C D)) :post (:t/intersection)] //            ;this one cant be allowed due to control reasons:
//          #R[(A --> C) (A --> D) |- ((* A A) --> (* C D)) :post (:t/intersection)]
//         #R[(A --> C) (B --> C) |- ((* A B) --> (* C C)) :post (:t/intersection)]
//         #R[({A} --> C) (A --> D) |- ((* {A} A) --> (* C D)) :post (:t/intersection)]
//          #R[(A --> C) ({A} --> D) |- ((* A {A}) --> (* C D)) :post (:t/intersection)]
//         #R[(A --> [C]) (B --> C) |- ((* A B) --> (* [C] C)) :post (:t/intersection)]
//         #R[(A --> C) (B --> [C]) |- ((* A B) --> (* C [C])) :post (:t/intersection)]





//query-variable queston answering HACK currently this is done better in PremiseGeneration, not here. but this sort of works
//  A, B, task("?") |- subIfUnifiesQuery(B, A, B), (Belief:BeliefIdentity, Punctuation:Belief)



//WASTEPAPER ===

//Single product variations
//    (S), (P), neqRec(S,P) |- (S | P), (Belief:Union),
//                                                  (S & P), (Belief:Intersection),
//                                                  (P ~ S), (Belief:Difference)


//DeMorgan's Law - currently implemented as a reduction but possibly should be a structural rule
    //<sseehh__> it becomes more helpful when there are >2 terms, ex: (&&, --(x), --(y), --(z))
    //<sseehh__> then it can replace N negations with one
    //<sseehh__> then the compound and its opposite resolve to the same compound
    //<patham9> if then I would add it as structural rule
    //<patham9> not as "reduction"
    //<patham9> meaning the system has free choice about the representation
    //<patham9> should have
    //<sseehh__> thats possible
    //<patham9> and I wouldnt apply StructuralDeduction as truth
