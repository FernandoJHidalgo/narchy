package objenome.solver;

import com.gs.collections.api.map.primitive.MutableObjectDoubleMap;
import com.gs.collections.impl.map.mutable.primitive.ObjectDoubleHashMap;
import objenome.goal.DoubleFitness;
import objenome.solver.evolve.Fitness;
import objenome.solver.evolve.TypedOrganism;

import java.util.Iterator;
import java.util.concurrent.ExecutorService;

/**
 * Civilized organism
 * Acts as a proxy class for a TypedOrganism generated by the breeders, etc
 *
 */
public class Civilized<I> extends TypedOrganism implements Runnable {

    final MutableObjectDoubleMap<EGoal<I>> cost = new ObjectDoubleHashMap<EGoal<I>>().asSynchronized();
    private final Iterable<EGoal> goalSequence;
    private final ExecutorService exe;

    double age = 0;

    private double totalCost = 0;
    private boolean running;

    public Civilized(TypedOrganism root, Iterable<EGoal> goalSequence, ExecutorService exe) {
        super(root.getRoot());

        fitness = root.getFitness();

        this.goalSequence = goalSequence;
        this.exe = exe;

//                new ArrayList(goals);
//        Collections.shuffle(goalSequence);
        running = true;
    }

    @Override
    public Fitness getFitness() {
        return fitness;
    }

    @Override
    public String toString() {
        return super.toString() + " [age=" + age + ", cost=" + totalCost + ']';
    }

    /**
     * rate: cost/time
     */
    public double costRate() {
        if (age == 0) return 0;
        return totalCost / age;
    }

    protected void evaluate(EGoal<I> goal, double cost) {
        this.cost.put(goal, cost);
        totalCost = this.cost.sum();
        setFitness(new DoubleFitness.Minimize(costRate()));
    }


    /**
     * returns true if still alive, false if dead
     */
    protected void age(double time) {
        //Thread.currentThread().setPriority(..);

        age += time;

    }

    public void onDeath() {
        System.out.println(this + " die @" + getAge());
        running = false;
    }


    @Override
    public void run() {

        Iterator<EGoal> gi = goalSequence.iterator();
        while (gi.hasNext() && running) {

            EGoal g = gi.next();

            try {

                double s = exe.submit(() -> {
                    //System.out.println(i + " evaluating " + g);
                    //System.out.println("SCORE=" + s);
                    return g.cost(Civilized.this);
                }).get();

                evaluate(g, s);

                age(1.0);

            } catch (Exception e) {
                e.printStackTrace();
                //evaluate(g, maxCycles)
                break;
            }
        }

        age(1.0);

        running = false;

    }

    /**
     * age of the organism; 0=birth, 1=retired (finished all goals)
     */
    public double getAge() {
        return age;
    }

    public boolean isRunning() {
        return running;
    }

}
