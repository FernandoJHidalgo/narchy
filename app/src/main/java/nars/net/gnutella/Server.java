package nars.net.gnutella;

import nars.net.gnutella.thread.DownloadThread;
import nars.net.gnutella.thread.PeerThread;
import nars.net.gnutella.thread.ServerThread;
import org.jetbrains.annotations.Nullable;

import java.io.*;
import java.math.BigInteger;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketException;

/**
 * Class that represents the Server part of Gnutella Servent
 *
 * @author Ismael Fernandez
 * @author Miguel Alonso Vilchis
 */
public class Server implements Runnable {

    public final ServerSocket socket;
    private final Peer peer;

    private final boolean listening;

    /**
     * Creates a Server that listen for upcoming connections on the specified
     * port.
     *
     * @param myPort       Port in which the server will wait for upcoming connections
     * @param historyQuery HashMap that contains de history of every QueryMessage
     *                     received from a neighbor Servent and every QueryMessage
     *                     generated by the Servent that owns this Server
     * @param downloads    HashMap that contains the connections to nodes which the
     *                     Servent owner of this Server has request for downloads and
     *                     connections to nodes that request for a download . Keys are in
     *                     format InetSocketAddress, those InetSocketAddress are bound
     *                     with each connection(ServentThread). Values are ServentThread.
     * @param myDirectory  DirectoryPath or file which, the Servent that owns this
     *                     Server, shares with the network
     * @throws IOException IO error when opening the socket in which this Server listens
     *                     for upcoming connections
     */
    public Server(Peer peer, int myPort) throws IOException {
        this.peer = peer;
        socket = new ServerSocket(myPort);
        listening = true;

    }

    @Override
    public void run() {
        while (listening && !Thread.currentThread().isInterrupted()) {
            try {

                onConnect(socket.accept());

            } catch (SocketException ef) {
                break;
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }


    /**
     * Verifies the if the servent received a connection request or download
     * request.
     *
     * @return An integer: 1 Connection Request, 2 Download Request, 3
     * Everything else
     */
    @Nullable
    public PeerThread connect(Socket socket) {

        try {
            InputStream in = socket.getInputStream();
            DataInputStream inStream = new DataInputStream(in);

            byte[] b = new byte[256];
            int bl = inStream.read(b);
            String request = (b[0] == 0 ? new String(b, 2, bl) : new String(b)); //DECODE a seeming -string or plain UTF if HTTP request


            // A servent
            // may reject an incoming connection request for a variety of
            // reasons - a serventâ€™s pool of incoming
            // connection slots may be exhausted
            //String request = inStream.readUTF();
            DataOutputStream outStream;
            OutputStream out;
            if (request.startsWith(GnutellaConstants.CONNECTION_REQUEST_PRE)) {
                out = socket.getOutputStream();
                outStream = new DataOutputStream(out);
                outStream.writeUTF(GnutellaConstants.CONNECTION_ACCEPTED);

                //logger.info("{} connected", socket);

                return new ServerThread(socket, peer );

            } else {

                try {
                    String[] requestDes = request.split("\r\n");
                    String[] get = requestDes[0].split("/");

                    String connection[] = requestDes[1].split(" ");

                    String range[] = requestDes[2].split(" ");
                    String bytes[] = range[1].split("=");

                    if (requestDes.length != 3
                            || !get[0].equals(GnutellaConstants.HTTP_GET)
                            || !get[1].equals(GnutellaConstants.HTTP_GETLC)

                            || !get[4].equals(GnutellaConstants.HTTP_STRING)
                            || !get[5].equals(GnutellaConstants.HTTP_VERSION)
                            || !connection[0]
                            .equals(GnutellaConstants.HTTP_CONNECTION)
                            || !range[0].equals(GnutellaConstants.HTTP_RANGE)
                            || !bytes[0].equals(GnutellaConstants.HTTP_BYTES)) {

                        return null;

                    }

                    BigInteger fileLength = new BigInteger(get[2]);
                    String fileName = get[3].trim();
                    //String typeConnection = connection[1];

                    BigInteger rangeByte = new BigInteger(bytes[1].substring(0,
                            bytes.length - 1));
                    if (rangeByte.longValue() > fileLength.longValue()) {
                        return null;
                    }

                    out = socket.getOutputStream();
                    outStream = new DataOutputStream(out);


                    File a = new File(fileName);
                    if (!a.isDirectory()) {

                        outStream.writeUTF(GnutellaConstants.HTTP_OK
                                + fileLength.toString() + "\r\n\r\n");

                        return new DownloadThread(socket, peer, true);

                    }


                    outStream.writeUTF(GnutellaConstants.HTTP_DENY);

                    return null;

                } catch (IOException e) {
                    e.printStackTrace();
                } catch (Exception e) {
                    e.printStackTrace();
                    return null;
                }

            }

        } catch (IOException e) {
            System.err.println(getClass() + ".connecxionRequest(): "
                    + e.getClass() + e.getMessage());
        }
        return null;

    }
    public void onConnect(Socket skt) {
        InetSocketAddress key = new InetSocketAddress(skt.getInetAddress(), skt.getPort());

        // Crea un nuevo thread para cada nueva conexion
        PeerThread thread = connect(skt);
        if (thread!=null)
            peer.exe.execute(thread);

    }

}
