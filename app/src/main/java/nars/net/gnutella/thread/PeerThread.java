package nars.net.gnutella.thread;

import nars.net.gnutella.GnutellaConstants;
import nars.net.gnutella.Peer;
import nars.net.gnutella.message.Message;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.DataInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;

/**
 * Class for managing the connections created by a Servent
 *
 * @author Ismael Fernandez
 * @author Miguel Vilchis
 */

abstract public class PeerThread implements Runnable  {

    public final Peer peer;


    /* Atributos siempre usados */
    protected InputStream in;
    protected DataInputStream inStream;
    protected OutputStream out;
    //protected DataOutputStream outStream;
    public final Socket socket;



    protected boolean working;
    protected boolean connected;


	/* Atributos del nodo cuando es para descarga */


    private static final Logger logger = LoggerFactory.getLogger(PeerThread.class);

    /**
     * Creates a ServentThread to manage the connection bound in the specified
     * socket
     *
     * @param socket          Socket bound to the connection that this object represents
     * @param historyQuery    HashMap that contains de history of every QueryMessage
     *                        received from a neighbor Servent and every QueryMessage
     *                        generated by the Servent that owns this Server
     * @param pendingMessages
     * @param inSkA           InetSocketAddress bound to this connection
     * @param pathName        Name directoryPath or file which, the Servent that owns this
     *                        Server, shares with the network
     */
    public PeerThread(Socket socket, Peer peer) throws IOException {

        this.peer = peer;
        this.socket = socket;

        working = true;
        connected = true;

        out = socket.getOutputStream();
        //outStream = new DataOutputStream(out);
        in = socket.getInputStream();
        inStream = new DataInputStream(in);


    }





    public boolean connected() {
        return connected;
    }

    // /////////////////////////////////////////////////////////////////////////////////////////////////
    /* METHODS USED ALWAYS */

    /**
     * Close this connection
     */
    public void stop() {

        //recvThread.interrupt();

        peer.neighbors.remove(socket.getRemoteSocketAddress());

        try {
            socket.close();
        } catch (IOException e) {
            //e.printStackTrace();
        }

        try {
            in.close();
        } catch (IOException e) {
            //e.printStackTrace();
        }

        try {
            inStream.close();
        } catch (IOException e) {
            //e.printStackTrace();
        }

        try {
            out.close();
        } catch (IOException e) {
            //e.printStackTrace();
        }


        try {
            socket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }


        connected = false;
        working = false;
    }

    /**
     * Send a Gnutella connection request string to the servent with which is
     * connected
     *
     * @return true if the servent responds accepting the connection request.
     * False other any other answer
     */
    public boolean connexionRequest() {
        try {


            out.write(GnutellaConstants.CONNECTION_REQUESTbytes);
            //outStream.writeUTF(GnutellaConstants.CONNECTION_REQUESTbytes);
            if (inStream.readUTF()
                    .equals(GnutellaConstants.CONNECTION_ACCEPTED)) {
                return true;
            }
            inStream.close();
            in.close();
            out.close();
            socket.close();

            return false;

        } catch (IOException e) {
            System.err.println(getClass() + ".establishConnexion():"
                    + e.getClass() + e.getMessage());
            e.printStackTrace();
            return false;

        }

    }



    public synchronized void _send(Message m) {

//        if (m.type == GnutellaConstants.PING) {
//            flag = false;
//            new java.util.Timer().schedule(
//                    new java.util.TimerTask() {
//                        @Override
//                        public void run() {
//                            if (!flag) {
//                                stop();
//                            }
//                        }
//                    }, PONG_TIMEOUT_MS);
//        }

        try {
            byte[] mb = m.asBytes();
            //logger.info("send message: {}", mb.length);
            out.write(mb);
        } catch (Exception e) {
            logger.error("send: {}\n{}", m, e );
        }

    }

    public final void pending(Message m) {
        peer.pending(m);
    }

}
