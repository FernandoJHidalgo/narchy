package nars.inter.gnutella;
import java.io.File;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Enumeration;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Class that represents the Server part of Gnutella Servent
 * 
 * @author Ismael Fernandez
 * @author Miguel Alonso Vilchis
 * 
 */
public class Server implements Runnable {

	public final ServerSocket socket;
	private final Client client;
	private final Peer peer;
	private ConcurrentHashMap<InetSocketAddress, PeerThread> neighbors;
	private ConcurrentHashMap<InetSocketAddress, PeerThread> downloads;
//	private ConcurrentHashMap<String, InetSocketAddress> historyPing;
//	private ConcurrentHashMap<String, ConcurrentHashMap<InetSocketAddress, Boolean>> firstPongsFromNeighbors;
	private boolean listening;
	private IdGenerator myIdGenerator;
	private File myDirectory;
	private int maxNodes;

	/**
	 * Creates a Server that listen for upcoming connections on the specified
	 * port.
	 * 
	 * @param myPort
	 *            Port in which the server will wait for upcoming connections
	 * @param neighbors
	 *            HashMap that contains the connections to its neighbors nodes.
	 *            Keys are in format InetSocketAddress, those InetSocketAddress
	 *            are bound with each connection(ServentThread).
	 * @param historyQuery
	 *            HashMap that contains de history of every QueryMessage
	 *            received from a neighbor Servent and every QueryMessage
	 *            generated by the Servent that owns this Server
	 * @param myIdGenerator
	 *            Object to generate id
	 * @param downloads
	 *            HashMap that contains the connections to nodes which the
	 *            Servent owner of this Server has request for downloads and
	 *            connections to nodes that request for a download . Keys are in
	 *            format InetSocketAddress, those InetSocketAddress are bound
	 *            with each connection(ServentThread). Values are ServentThread.
	 * @param myDirectory
	 *            DirectoryPath or file which, the Servent that owns this
	 *            Server, shares with the network
	 * @throws IOException
	 *             IO error when opening the socket in which this Server listens
	 *             for upcoming connections
	 */
	public Server(Peer peer, int myPort,
				  ConcurrentHashMap<InetSocketAddress, PeerThread> neighbors,
				  IdGenerator myIdGenerator,
				  ConcurrentHashMap<InetSocketAddress, PeerThread> downloads,
				  File myDirectory, int maxNodes, Client client) throws IOException {
		this.peer = peer;
		socket = new ServerSocket(myPort);
		this.neighbors = neighbors;
		this.downloads = downloads;
		listening = true;
		this.myIdGenerator = myIdGenerator;
		this.myDirectory = myDirectory;
		this.maxNodes = maxNodes;
		this.client = client;

	}

	@Override
	public void run() {
		while (listening) {
			try {
				Socket skt = socket.accept();
				InetSocketAddress key = new InetSocketAddress(skt.getInetAddress(), skt.getPort());

				// Crea un nuevo thread para cada nueva conexion
				PeerThread thread = new PeerThread(peer.messageCache, skt, client, key);

				// Decide que tipo de conexion es la entrante
				switch (thread.connect()) {

				case GnutellaConstants.DOWNLOAD_NODE:
					if (downloads.size() <= GnutellaConstants.MAX_DOWNLOADS) {

						downloads.putIfAbsent(key, thread);
						new Thread(thread).start();
					} else {
						thread.close();
					}
					break;
				case GnutellaConstants.SERVENT_NODE:
					if (neighbors.size() <= 10) {
						neighbors.putIfAbsent(key, thread);
						new Thread(thread).start();
					} else {
						thread.close();
					}

					break;
				default:
					thread.close();
					break;

				}

				removeCompleteDownload();

			} catch (IOException e) {

				e.printStackTrace();
			}
		}
	}

	public void setMaxNodes() {
		maxNodes++;
	}

	/**
	 * Delete connections with completed downloads.
	 */
	public void removeCompleteDownload() {
		Enumeration<InetSocketAddress> e = downloads.keys();
		while (e.hasMoreElements()) {
			InetSocketAddress iSA = e.nextElement();
			PeerThread sT = downloads.get(iSA);
			if (sT.getDownloadFinished()) {
				downloads.remove(iSA);
			}
		}

	}
}
