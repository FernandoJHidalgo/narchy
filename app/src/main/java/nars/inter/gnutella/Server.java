package nars.inter.gnutella;

import java.io.File;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Class that represents the Server part of Gnutella Servent
 *
 * @author Ismael Fernandez
 * @author Miguel Alonso Vilchis
 */
public class Server implements Runnable {

    public final ServerSocket socket;
    private final Client client;
    private final Peer peer;
    private final ConcurrentHashMap<InetSocketAddress, PeerThread> neighbors;

    private final boolean listening;
    private final IdGenerator myIdGenerator;
    private final File myDirectory;

    /**
     * Creates a Server that listen for upcoming connections on the specified
     * port.
     *
     * @param myPort        Port in which the server will wait for upcoming connections
     * @param neighbors     HashMap that contains the connections to its neighbors nodes.
     *                      Keys are in format InetSocketAddress, those InetSocketAddress
     *                      are bound with each connection(ServentThread).
     * @param historyQuery  HashMap that contains de history of every QueryMessage
     *                      received from a neighbor Servent and every QueryMessage
     *                      generated by the Servent that owns this Server
     * @param myIdGenerator Object to generate id
     * @param downloads     HashMap that contains the connections to nodes which the
     *                      Servent owner of this Server has request for downloads and
     *                      connections to nodes that request for a download . Keys are in
     *                      format InetSocketAddress, those InetSocketAddress are bound
     *                      with each connection(ServentThread). Values are ServentThread.
     * @param myDirectory   DirectoryPath or file which, the Servent that owns this
     *                      Server, shares with the network
     * @throws IOException IO error when opening the socket in which this Server listens
     *                     for upcoming connections
     */
    public Server(Peer peer, int myPort,
                  ConcurrentHashMap<InetSocketAddress, PeerThread> neighbors,
                  IdGenerator myIdGenerator,
                  File myDirectory, Client client) throws IOException {
        this.peer = peer;
        socket = new ServerSocket(myPort);
        this.neighbors = neighbors;
        listening = true;
        this.myIdGenerator = myIdGenerator;
        this.myDirectory = myDirectory;
        this.client = client;

    }

    @Override
    public void run() {
        while (listening) {
            try {
                Socket skt = socket.accept();
                InetSocketAddress key = new InetSocketAddress(skt.getInetAddress(), skt.getPort());

                // Crea un nuevo thread para cada nueva conexion
                PeerThread thread = new PeerThread(peer.messageCache, skt, client, key);

                // Decide que tipo de conexion es la entrante
                switch (thread.connect()) {

                    case GnutellaConstants.DOWNLOAD_NODE:
//					if (downloads.size() <= GnutellaConstants.MAX_DOWNLOADS) {
//
//						downloads.putIfAbsent(key, thread);
                        new Thread(thread).start();
//					} else {
//						thread.close();
//					}
                        break;
                    case GnutellaConstants.SERVENT_NODE:
                        if (neighbors.size() <= 10) {
                            neighbors.putIfAbsent(key, thread);
                            new Thread(thread).start();
                        } else {
                            thread.close();
                        }

                        break;
                    default:
                        thread.close();
                        break;

                }


            } catch (IOException e) {

                e.printStackTrace();
            }
        }
    }

}
