package nars.inter.gnutella.thread;

import nars.inter.gnutella.GnutellaConstants;
import nars.inter.gnutella.message.Message;
import nars.inter.gnutella.Peer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.*;
import java.net.Socket;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * Class for managing the connections created by a Servent
 *
 * @author Ismael Fernandez
 * @author Miguel Vilchis
 */

abstract public class PeerThread implements Runnable {
    public static final int PONG_TIMEOUT_MS = 10000;

    public final Peer peer;
    /* Atributos siempre usados */
    protected InputStream in;
    protected DataInputStream inStream;
    protected OutputStream out;
    protected DataOutputStream outStream;
    public final Socket socket;


    private final ExecutorService messagesToSend = Executors.newSingleThreadExecutor();
    protected boolean working;
    protected boolean connected;
    protected boolean flag;


	/* Atributos del nodo cuando es para descarga */


    private static final Logger logger = LoggerFactory.getLogger(PeerThread.class);

    /**
     * Creates a ServentThread to manage the connection bound in the specified
     * socket
     *
     * @param socket          Socket bound to the connection that this object represents
     * @param historyQuery    HashMap that contains de history of every QueryMessage
     *                        received from a neighbor Servent and every QueryMessage
     *                        generated by the Servent that owns this Server
     * @param pendingMessages
     * @param inSkA           InetSocketAddress bound to this connection
     * @param pathName        Name directoryPath or file which, the Servent that owns this
     *                        Server, shares with the network
     */
    public PeerThread(Socket socket, Peer peer) throws IOException {

        this.peer = peer;
        this.socket = socket;

        working = true;
        flag = true;
        connected = true;

        out = socket.getOutputStream();
        outStream = new DataOutputStream(out);
        in = socket.getInputStream();
        inStream = new DataInputStream(in);

    }


    // //////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /* METHODS USED IF NOT DOWNLOADTHREAD */

    /**
     * Adds the Message to the queue of pending messages to send
     *
     * @param m the Message
     */
    public void send(Message m) {
        //logger.trace("send {}", m);
        messagesToSend.execute(() -> _send(m));
    }

    public boolean connected() {
        return connected;
    }

    // /////////////////////////////////////////////////////////////////////////////////////////////////
    /* METHODS USED ALWAYS */

    /**
     * Close this connection
     */
    public void stop() {
        try {
            socket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

        try {
            in.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

        try {
            inStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

        messagesToSend.shutdownNow();
        connected = false;
        working = false;
    }

    /**
     * Send a Gnutella connection request string to the servent with which is
     * connected
     *
     * @return true if the servent responds accepting the connection request.
     * False other any other answer
     */
    public boolean connexionRequest() {
        try {


            outStream.writeUTF(GnutellaConstants.CONNECTION_REQUEST);
            if (inStream.readUTF()
                    .equals(GnutellaConstants.CONNECTION_ACCEPTED)) {
                return true;
            }
            inStream.close();
            in.close();
            outStream.close();
            out.close();
            socket.close();

            return false;

        } catch (IOException e) {
            System.err.println(getClass() + ".establishConnexion():"
                    + e.getClass() + e.getMessage());
            e.printStackTrace();
            return false;

        }

    }


    public boolean unseen(Message m) {
        return !peer.seen(m);
    }

    public void _send(Message m) {

        if (m.type == GnutellaConstants.PING) {
            flag = false;
            new java.util.Timer().schedule(
                    new java.util.TimerTask() {
                        @Override
                        public void run() {
                            if (!flag) {
                                stop();
                            }
                        }
                    }, PONG_TIMEOUT_MS);
        }

        m.out(outStream);
    }

    public final void pending(Message m) {
        peer.pending(m);
    }

}
