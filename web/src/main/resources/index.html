<!DOCTYPE html>
<html>
<head>

    <title></title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">

    <style type="text/css">

        @import url("spacegraph.dark.css");
        @import url("spacegraph.css");

    </style>

    <script src="lib/lodash/dist/lodash.min.js"></script>

    <script src="lib/jquery/dist/jquery.min.js"></script>
    <script src="lib/jquery-ui/jquery-ui.min.js"></script>

    <script src="lib/fastdom/fastdom.min.js"></script>

    <link rel="stylesheet" href="lib/golden-layout/src/css/goldenlayout-base.css"/>
    <link rel="stylesheet" href="index.layout.css"/>
    <script src="lib/golden-layout/dist/goldenlayout.min.js"></script>


    <script src="lib/cytoscape/dist/cytoscape.min.js"></script>
    <script src="cytoscape-spread/cytoscape-spread.js"></script>

    <script src="lib/ace-builds/src-min-noconflict/ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="lib/ace-builds/src-min-noconflict/theme-vibrant_ink.js" type="text/javascript"
            charset="utf-8"></script>
    <script src="lib/ace-builds/src-min-noconflict/mode-lisp.js" type="text/javascript" charset="utf-8"></script>

    <script src="event.js"></script>

    <script src="socketview.js"></script>

    <script src="spacegraph.js"></script>
    <!--<script src="spacegraph.frame.js"></script>-->

    <script src="narchy.js"></script>


    <style>
        html, input, textarea, keygen, select, button {
            font-family: monospace, monospace !important;
            font-size: 1em; /* see: http://code.stephenmorley.org/html-and-css/fixing-browsers-broken-monospace-font-handling/ */
        }



        body {
            position: fixed;
            margin: 0;
            padding: 0;
            border: 0;
            width: 100%;
            height: 100%;
        }

        #graph {
            width: 100%;
            height: 100%;
            opacity: 0.85;
        }

        .terminal {
            width: 100%;
            height: 90%;
            overflow-y: auto;
        }

        #input {
            position: fixed;
            width: 100%;

            opacity: 0.8;
            /*background-color: orange;*/
            border-top: 2px solid gray;
            bottom: 0;
            left: 0;
            padding: 0 !important;
            height: 2em !important;
        }

        #input div {
            padding: 2px;
        }

        .belief {
            color: #d4d4d4;
        }

        .command {
            color: greenyellow;
        }

        .question {
            color: #8e70ff;
        }

        .goal {
            color: orange;
        }

        /*.grid-stack-item {*/
            /*border: 2px solid green;*/
        /*}*/

        .max {
            width: 100%;
            height: 100%;
        }

        .MainMenuButton {
            opacity:0.75;
            display: inline-block;
            cursor: pointer;
        }

        .MainMenuButton:hover {
            color: orange;
            /* TODO scale grow transition */
        }



        .MenuLayer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            z-index: 3;
        }
        .MenuGraph {
            position: fixed;
        }

    </style>
</head>

<body class="max">

</body>

<script>


    function MainMenuButton() {
        return $('<div>[@]</div>').addClass('MainMenuButton').click(()=> setTimeout(Menu, 0) );
    }

    function Menu() {
        const menulayer = div('MenuLayer').attr('oncontextmenu', "return false;");
        const graphCanvas = div('MenuGraph max').appendTo(menulayer);

        var c;

        function close() {
            menulayer.fadeOut(250, ()=> {
                setTimeout(()=>{
                    if (c)
                        c.destroy();
                    menulayer.remove();
                }, 0);
            });
        }


        const menu = {
            nodes: [ ],
            edges: [ ],

            add: function(item, parent, options) {
                options = options || {};
                options.id = item;

                //disable label if widget is provided
                options.label = options.widget ? "" : item;

                this.nodes.push( { data: options } );
                if (parent)
                    this.edges.push( { data: { source: parent, target: item } } );
            }
        };

        const body = $('body');

        const _return = 'return';

        menu.add(_return, null, {
            widget: $('<button>[X]</button>').click(function(e) {
                console.log(e);
                close();

            })
        });
        menu.add('System', _return, {});
        menu.add('Network', 'System', {});
        menu.add('Memory', 'System', {});
        {
            menu.add('Concepts', 'Memory', {});
            menu.add('Goals', 'Memory', {});
        }
        menu.add('CPU', 'System', {});
        {
            menu.add('Restart', 'System', {});
            menu.add('Shutdown', 'System', {});
        }

        menu.add('Status', _return, {});
        {

            menu.add('Weather', 'Status', {});
            {
                menu.add('Temperature', 'Weather', {});
                menu.add('Precipitation', 'Weather', {});
                menu.add('Humidity', 'Weather', {});
                menu.add('Air Quality', 'Weather', {});
            }

            menu.add('Bio', 'Status', {});
            {
                menu.add('Food', 'Bio', {});
                menu.add('Medicine', 'Bio', {});
                menu.add('Shelter', 'Bio', {});
                menu.add('Defense', 'Bio', {});
            }

            menu.add('News', 'Status', {});
        }

        menu.add('Find', _return, {
            //widget: $('<div><input type="text" placeholder="?"></input></div>')
            widget: $('<textarea rows="4" cols="50">At w3schools.com you will learn how to make a website. We offer free tutorials in all web development technologies.</textarea>')
        });



        c = cytoscape({
            container: graphCanvas,

            layout: {
                name: 'concentric',
                concentric: function (node) { // returns numeric value for each node, placing higher nodes in levels towards the centre

                    var aStar = node.cy().elements().aStar({root: "#" + _return, goal: node});

                    return 100 - (aStar.distance);
                },

                levelWidth: function(n) { return 1; }, // the variation of concentric values in each level

                //equidistant: true,
                minNodeSpacing: 30,

                sweep: Math.PI*2.0
            },

//            layout:
//                //name: 'breadthfirst',
//                //name: 'cose',
//                fit: true
//            },

            ready: (a)=>{


                var cc = a.cy;

                var pr = cc.elements()
                    .closenessCentralityNormalized();
                    //.degreeCentralityNormalized();
                    //.pageRank();

                cc.nodes().each((i,n) => {

                    var v = //1 / Math.pow(pr.rank(n), 2);
                        pr.closeness(n);

                    n.style({
                        width:  v * 160,
                        height: v * 120
                    });

                });

            },

            style: [
                {
                    selector: 'node',
                    style: {
                        'background-color': '#888',
                        'label': 'data(label)',
                        'text-color': 'white',
                        'shape': 'hexagon',
                        //'width':
                          //  node => 48 * (1+Math.sqrt(node.outdegree())),
                        //'height': node => 30 * (1+Math.sqrt(node.outdegree())),
                        'text-valign': 'center',
                        'text-halign': 'center',
                        'color': '#fff',
                        'font-family': 'Monospace'

                    }
                }
            ],

            elements: menu,
        });

        const activeWidgets = new Map();

        function onAdd(node) {

            //console.log(node);

            const data = node._private.data;
            if (data.widget) {

                const widget = (data.widget.jquery) ? data.widget[0] : data.widget; //HACK un-querify

                var nid = node.id();
                widget.setAttribute('id', 'node_' + nid);

                var style = widget.style;
                //style.position = 'fixed';
                style.transformOrigin = '0 0';

                menulayer.append(widget);
                activeWidgets.set(nid, node);

                updateWidget(node);


            }
        }

        c.nodes().each((i,v)=>onAdd(v));
        c.on('add', /* select unselect  */ function (e) {
            onAdd(e.cyTarget);
        });

        c.on('remove', /* select unselect  */ function (e) {

            const node = e.cyTarget;
            const data = node._private.data;
            if (data.widget) {
                const widget = (data.widget[0]) ? data.widget[0] : data.widget; //HACK un-querify
                activeWidgets.remove(node.id());
                widget.detach();
            }

        });

        function updateAll() {

            fastdom.mutate(()=>{
                activeWidgets.forEach((node, nid) => {
                    updateWidget(node);
                });
            });
        }

        c.on('pan zoom ready', /* select unselect  */ function (e) {
            updateAll();
        });

        c.on('position style data', /* select unselect  */ function (e) {

            const node = e.cyTarget;
            const data = node._private.data;
            if (data && data.widget) {
                updateWidget(node);
                //console.log(this, that, target);
                //that.commit();
            }
        });


        function zoomTo(ele, zoomDuration) {
            // var pos;
            // if (!ele || !ele.position)
            //     pos = { x: 0, y: 0 };
            // else
            //     pos = ele.position();

            c.animate({
                fit: {
                    eles: ele,
                    padding: 120
                }
            }, {
                duration: zoomDuration
                /*step: function() {
                 }*/
            });
        }

        //--------------
        //right-click autozoom:
        c.on('cxttapstart', function(e) {
            var target = e.cyTarget;
            zoomTo(!target ? undefined : target, 128 /* ms */)
        });

//            const layout = c.makeLayout({
//                /* https://github.com/cytoscape/cytoscape.js-spread */
//                name: 'spread',
//                    minDist: 250,
//                    //padding: 100,
//
//                    speed: 0.06,
//                    animate: false,
//                    randomize: true, // uses random initial node positions on true
//                    fit: false,
//                    maxFruchtermanReingoldIterations: 1, // Maximum number of initial force-directed iterations
//                    maxExpandIterations: 2, // Maximum number of expanding iterations
//
//                    ready: function () {
//                    //console.log('starting spread', Date.now());
//                },
//                stop: function () {
//                    //console.log('stop spread', Date.now());
//                }
//            });
//            c.onRender(()=>{
//               layout.run();
//            });



        menulayer.hide();

        fastdom.mutate(()=>{
            menulayer.appendTo(body)
            menulayer.fadeIn();
        });


    }

    $(document).ready(() => {

        const io = NARTerminal();
        window.io = io;

        var layout = new GoldenLayout( {
            content: [{
                type: 'row',
                content:[{
                    type: 'component',
                    componentName: 'terminal',
                    componentState: { label: 'A' }
                },{
                    type: 'column',
                    content:[{
                        type: 'component',
                        componentName: 'graph',
                        componentState: { label: 'B' }
                    },{
                        type: 'component',
                        componentName: 'top',
                        componentState: { label: 'C' }
                    }]
                }]
            }]
        }, $('body') );

        layout.on( 'stackCreated', function( stack ) {

            /*
             * Accessing the DOM element that contains the popout, maximise and * close icon
             */
            stack.header.controlsContainer.append(MainMenuButton());
        });
        layout.registerComponent( 'terminal', function( tgt, state ){
            tgt.getElement().html( IO(io) );
        });
        layout.registerComponent( 'graph', function( tgt, state ){
            tgt.getElement().html( Graph(io) );
        });
        layout.registerComponent( 'top', function( tgt, state ){
            tgt.getElement().html( TopTable("active") );
        });

        layout.init();

    });


    function Graph(terminal) {


        const d = div('graph max');

        var opt = {


            //additional options and overrides for defaults
        };

        var c = spacegraph(d, opt);

        const colorFunc = function (r, g, b) {

            const R = parseInt(r * 255);
            const G = parseInt(g * 255);
            const B = parseInt(b * 255);

            return "rgb(" + R + "," + G + "," + B + ")";

        };

        var changed = true;

//        c.onRender(()=>{
//           console.log('render');
//           changed = false;
//        });

        const maxNodes = 20;
        const updatePeriodMS = 100;


        const layout = c.makeLayout({
            /* https://github.com/cytoscape/cytoscape.js-spread */
            name: 'spread',
            minDist: 250,
            //padding: 100,

            speed: 0.06,
            animate: false,
            randomize: false, // uses random initial node positions on true
            fit: false,
            maxFruchtermanReingoldIterations: 1, // Maximum number of initial force-directed iterations
            maxExpandIterations: 2, // Maximum number of expanding iterations

            ready: function () {
                //console.log('starting spread', Date.now());
            },
            stop: function () {
                //console.log('stop spread', Date.now());
            }
        });


        setInterval(() => {

            layout.run();

            if (!changed)
                return;

            c.batch(() => {

                const nodes = c.nodes();
                const toRemove = (nodes.size()) - maxNodes;
                if (toRemove > 0) {
                    //console.log(nodes.size(), 'oversize');
                    var sorted = nodes.sort((a, b) => {
                        //increasing priority
                        return a._private.data.pri - b._private.data.pri;
                    });

                    for (var i = 0; i < toRemove; i++) {
                        //console.log(sorted[i], 'removed');
                        sorted[i].remove();
                    }
                    //console.log(nodes.size(), 'current size');
                }


                nodes.each((i, n) => {
                    var x = n._private.data; //HACK
                    if (x) {

                        const p1 = 1 + x.pri; // * d(x, 'belief');
                        const r = parseInt(24 + 48 * (p1 * p1));
                        n.style({
                            //                       sg.spacegraph.style().selector('node')
                            //                       .style('background-color', function(x) {
                            //                           const belief = 0.25 + 0.75 * d(x, 'belief');
                            //                           const aBelief = 0.25 + 0.75 * Math.abs(belief);
                            //                           const pri = 0.25 + 0.75 * d(x, 'pri');
                            width: r,
                            height: r,
                            shape: 'hexagon',
                            backgroundColor: colorFunc(0.25 + 0.75 * x.pri, x.dur, x.qua)


                        });
                    }
                });
            });

            changed = false;

        }, updatePeriodMS);

        terminal.on('message', function (x) {
            var id = x.term + x.punc + x.freq + ';' + x.conf; //HACK for Task's
            x.label = x.term; //HACK

            var existing = c.get(id);

            if (!existing) {

                //add
                c.add({group: "nodes", data: x});

            } else {
                //replace / merge
                existing.data = x;
            }

            changed = true;
        });


        return d;
    }

//    function gridCell(contents) {
//        return div('grid-stack-item').append(div('grid-stack-item-content').append(contents));
//    }

    function IO(term) {

        var c = new NARConsole(term, (x) => {


                const label = x.term + x.punc + truthString(x.freq, x.conf);

                //const fontSize = 2 * (1 + parseInt(x.pri * 99.0)) + '%';
                const fontSize = (75 + 8 * Math.sqrt(1 + 10 * parseInt(x.pri * 9.0))) + '%';


                var d = document.createElement('div');
                switch (x.punc) {
                    case '.':
                        d.className = 'belief';
                        break;
                    case '?':
                        d.className = 'question';
                        break;
                    case '!':
                        d.className = 'goal';
                        break;
                    case ';':
                        d.className = 'command';
                        break;
                }
                d.style.opacity = 0.5 + 0.5 * x.dur;
                d.style.fontSize = fontSize;
                d.innerText = label;
                return d;


            }).addClass('terminal');

        c.append(
            NALEditor(term).attr('id', 'input')
        );
//
//        ).attr('id', 'console');

        return c;
    }


    function truthComponentStr(x) {

        const i = parseInt(Math.round(100 * x));
        if (i == 100)
            return '1.0';
        else if (i == 0)
            return '0.0';
        else
            return i / 100.0;
    }

    function truthString(f, c) {
        return c ?
            ("%" + truthComponentStr(f) +
            ";" + truthComponentStr(c) + "%") :
            "";
    }

    function div(cssklass) {
        const d = document.createElement('div');
        if (cssklass) {
            d.className = cssklass;
        }
        return $(d);
    }


    //            div('max grid-stack').append(
    //
    //                gridCell([


    //                ]),
    //
    //                //gridCell(div().html('<h1>ABC</h1>')),
    //                //gridCell( NALTimeline(term).attr('id', 'graph') ),
    //
    //                gridCell( TopTable("active") )

    //            ).gridstack({
    //                cellHeight: 160,
    //                cellWidth: 160,
    //                verticalMargin: 20,
    //                horizontalMargin: 20
    //            })


</script>

</html>