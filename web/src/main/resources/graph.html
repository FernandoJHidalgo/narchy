<!DOCTYPE html>

<!--<div id="info">-->
<!--<a href="http://threejs.org" target="_blank">three.js</a> webgl - buffergeometry drawcalls - by <a-->
<!--href="https://twitter.com/fernandojsg">fernandojsg</a>-->
<!--</div>-->

<html lang="en">
<head>
    <title>three.js webgl - buffergeometry - lines drawcalls</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

    <style>
        html, body, #view, #blocker {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: absolute;
            top: 0px;
            left: 0px;
        }

        body {
            color: #cccccc;
            font-family: Monospace;
            background-color: #000000;
            margin: 0px;
        }

        a {
            color: #0080ff;
        }

    </style>
</head>
<body>


<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.5/dat.gui.min.js"></script>
<script src="http://threejs.org/build/three.min.js"></script>

<!--
    http://jeromeetienne.github.io/threex.htmlmixer/examples/basic.html
    http://jeromeetienne.github.io/threex.domevents/examples/demo.html
-->
<script src="http://jeromeetienne.github.io/threex.domevents/threex.domevents.js"></script>
<script src="http://jeromeetienne.github.io/threex.htmlmixer/threex.htmlmixer.js"></script>


<script src="https://threejs.org/examples/js/controls/TrackballControls.js"></script>
<!--<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>-->
<script src="https://threejs.org/examples/js/controls/DragControls.js"></script>


<!--<script src="js/libs/stats.min.js"></script>-->


<script>
    /**
     * Based on http://www.emagix.net/academic/mscs-project/item/camera-sync-with-css3-and-webgl-threejs
     * @author mrdoob / http://mrdoob.com/
     */

    THREE.CSS3DObject = function (element) {

        THREE.Object3D.call(this);

        this.element = element;
        this.element.style.position = 'absolute';

        this.addEventListener('removed', function () {

            if (this.element.parentNode !== null) {

                this.element.parentNode.removeChild(this.element);

            }

        });

    };

    THREE.CSS3DObject.prototype = Object.create(THREE.Object3D.prototype);
    THREE.CSS3DObject.prototype.constructor = THREE.CSS3DObject;

    THREE.CSS3DSprite = function (element) {

        THREE.CSS3DObject.call(this, element);

    };

    THREE.CSS3DSprite.prototype = Object.create(THREE.CSS3DObject.prototype);
    THREE.CSS3DSprite.prototype.constructor = THREE.CSS3DSprite;

    //

    THREE.CSS3DRenderer = function () {

        console.log('THREE.CSS3DRenderer', THREE.REVISION);

        var _width, _height;
        var _widthHalf, _heightHalf;

        var matrix = new THREE.Matrix4();

        var cache = {
            camera: {fov: 0, style: ''},
            objects: {}
        };

        var domElement = document.createElement('div');
        domElement.style.overflow = 'hidden';

        this.domElement = domElement;

        var cameraElement = document.createElement('div');

        cameraElement.style.WebkitTransformStyle = 'preserve-3d';
        cameraElement.style.MozTransformStyle = 'preserve-3d';
        cameraElement.style.transformStyle = 'preserve-3d';

        domElement.appendChild(cameraElement);

        var isIE = /Trident/i.test(navigator.userAgent);

        this.setClearColor = function () {
        };

        this.getSize = function () {

            return {
                width: _width,
                height: _height
            };

        };

        this.setSize = function (width, height) {

            _width = width;
            _height = height;
            _widthHalf = _width / 2;
            _heightHalf = _height / 2;

            domElement.style.width = width + 'px';
            domElement.style.height = height + 'px';

            cameraElement.style.width = width + 'px';
            cameraElement.style.height = height + 'px';

        };

        function epsilon(value) {

            return Math.abs(value) < 1e-10 ? 0 : value;

        }

        function getCameraCSSMatrix(matrix) {

            var elements = matrix.elements;

            return 'matrix3d(' +
                epsilon(elements[0]) + ',' +
                epsilon(-elements[1]) + ',' +
                epsilon(elements[2]) + ',' +
                epsilon(elements[3]) + ',' +
                epsilon(elements[4]) + ',' +
                epsilon(-elements[5]) + ',' +
                epsilon(elements[6]) + ',' +
                epsilon(elements[7]) + ',' +
                epsilon(elements[8]) + ',' +
                epsilon(-elements[9]) + ',' +
                epsilon(elements[10]) + ',' +
                epsilon(elements[11]) + ',' +
                epsilon(elements[12]) + ',' +
                epsilon(-elements[13]) + ',' +
                epsilon(elements[14]) + ',' +
                epsilon(elements[15]) +
                ')';

        }

        function getObjectCSSMatrix(matrix, cameraCSSMatrix) {

            var elements = matrix.elements;
            var matrix3d = 'matrix3d(' +
                epsilon(elements[0]) + ',' +
                epsilon(elements[1]) + ',' +
                epsilon(elements[2]) + ',' +
                epsilon(elements[3]) + ',' +
                epsilon(-elements[4]) + ',' +
                epsilon(-elements[5]) + ',' +
                epsilon(-elements[6]) + ',' +
                epsilon(-elements[7]) + ',' +
                epsilon(elements[8]) + ',' +
                epsilon(elements[9]) + ',' +
                epsilon(elements[10]) + ',' +
                epsilon(elements[11]) + ',' +
                epsilon(elements[12]) + ',' +
                epsilon(elements[13]) + ',' +
                epsilon(elements[14]) + ',' +
                epsilon(elements[15]) +
                ')';

            if (isIE) {

                return 'translate(-50%,-50%)' +
                    'translate(' + _widthHalf + 'px,' + _heightHalf + 'px)' +
                    cameraCSSMatrix +
                    matrix3d;

            }

            return 'translate(-50%,-50%)' + matrix3d;

        }

        function renderObject(object, camera, cameraCSSMatrix) {

            if (object instanceof THREE.CSS3DObject) {

                var style;

                if (object instanceof THREE.CSS3DSprite) {

                    // http://swiftcoder.wordpress.com/2008/11/25/constructing-a-billboard-matrix/

                    matrix.copy(camera.matrixWorldInverse);
                    matrix.transpose();
                    matrix.copyPosition(object.matrixWorld);
                    matrix.scale(object.scale);

                    matrix.elements[3] = 0;
                    matrix.elements[7] = 0;
                    matrix.elements[11] = 0;
                    matrix.elements[15] = 1;

                    style = getObjectCSSMatrix(matrix, cameraCSSMatrix);

                } else {

                    style = getObjectCSSMatrix(object.matrixWorld, cameraCSSMatrix);

                }

                var element = object.element;
                var cachedStyle = cache.objects[object.id] && cache.objects[object.id].style;

                if (cachedStyle === undefined || cachedStyle !== style) {

                    element.style.WebkitTransform = style;
                    element.style.MozTransform = style;
                    element.style.transform = style;

                    cache.objects[object.id] = {style: style};

                    if (isIE) {

                        cache.objects[object.id].distanceToCameraSquared = getDistanceToSquared(camera, object);

                    }

                }

                if (element.parentNode !== cameraElement) {

                    cameraElement.appendChild(element);

                }

            }

            for (var i = 0, l = object.children.length; i < l; i++) {

                renderObject(object.children[i], camera, cameraCSSMatrix);

            }

        }

        var getDistanceToSquared = function () {

            var a = new THREE.Vector3();
            var b = new THREE.Vector3();

            return function (object1, object2) {

                a.setFromMatrixPosition(object1.matrixWorld);
                b.setFromMatrixPosition(object2.matrixWorld);

                return a.distanceToSquared(b);

            };

        }();

        function zOrder(scene) {

            var order = Object.keys(cache.objects).sort(function (a, b) {

                return cache.objects[a].distanceToCameraSquared - cache.objects[b].distanceToCameraSquared;

            });
            var zMax = order.length;

            scene.traverse(function (object) {

                var index = order.indexOf(object.id + '');

                if (index !== -1) {

                    object.element.style.zIndex = zMax - index;

                }

            });

        }

        this.render = function (scene, camera) {

            var fov = 0.5 / Math.tan(THREE.Math.degToRad(camera.getEffectiveFOV() * 0.5)) * _height;

            if (cache.camera.fov !== fov) {

                domElement.style.WebkitPerspective = fov + 'px';
                domElement.style.MozPerspective = fov + 'px';
                domElement.style.perspective = fov + 'px';

                cache.camera.fov = fov;

            }

            scene.updateMatrixWorld();

            if (camera.parent === null) camera.updateMatrixWorld();

            camera.matrixWorldInverse.getInverse(camera.matrixWorld);

            var cameraCSSMatrix = 'translateZ(' + fov + 'px)' +
                getCameraCSSMatrix(camera.matrixWorldInverse);

            var style = cameraCSSMatrix +
                'translate(' + _widthHalf + 'px,' + _heightHalf + 'px)';

            if (cache.camera.style !== style && !isIE) {

                cameraElement.style.WebkitTransform = style;
                cameraElement.style.MozTransform = style;
                cameraElement.style.transform = style;

                cache.camera.style = style;

            }

            renderObject(scene, camera, cameraCSSMatrix);

            if (isIE) {

                // IE10 and 11 does not support 'preserve-3d'.
                // Thus, z-order in 3D will not work.
                // We have to calc z-order manually and set CSS z-index for IE.
                // FYI: z-index can't handle object intersection
                zOrder(scene);

            }

        };

    };


</script>


<script>

    "use strict";

    class GraJS {

        constructor(targetElement) {
            const view = this.view = targetElement;

            const options = {alpha: true, antialias: false};

            const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 4000);
            camera.position.z = 1750;

            //const controls = new THREE.OrbitControls(camera, view);

            const controls = this.controls = new THREE.TrackballControls(camera);
            controls.rotateSpeed = 1.0;
            controls.zoomSpeed = 1.2;
            controls.panSpeed = 0.8;
            controls.noZoom = false;
            controls.noPan = false;
            controls.staticMoving = true;
            controls.dynamicDampingFactor = 0.3;

            const scene = this.scene = new THREE.Scene();
            { //LIGHTING
                scene.add(new THREE.AmbientLight(0x505050));

                var light = new THREE.SpotLight(0xffffff, 1.5);
                light.position.set(0, 500, 2000);
                light.castShadow = false;
                scene.add(light);
                //        light.castShadow = true;
                //        light.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 50, 1, 200, 10000 ) );
                //        light.shadow.bias = - 0.00022;
                //        light.shadow.mapSize.width = 2048;
                //        light.shadow.mapSize.height = 2048;
            }


            //    var helper = new THREE.BoxHelper(new THREE.Mesh(new THREE.BoxGeometry(r, r, r)));
            //    helper.material.color.setHex(0x080808);
            //    helper.material.blending = THREE.AdditiveBlending;
            //    helper.material.transparent = true;
            //    group.add(helper);


            const renderer = this.renderer = new THREE.WebGLRenderer(options);
            renderer.autoClear = false;
            renderer.setClearColor(0x000000, 0.0);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.gammaInput = true;
            renderer.gammaOutput = true;
            renderer.sortObjects = true;
            const elementGL = this.elementGL = renderer.domElement;


            const dragControls = this.dragControls = new THREE.DragControls(this.draggable = [], camera, elementGL);
            dragControls.addEventListener('dragstart', event => controls.enabled = false);
            dragControls.addEventListener('dragend', event => controls.enabled = true);


            this.EVENTS = new THREEx.DomEvents(camera, window);



//    THREEx.DomEvents.eventNames.forEach(function(eventName){
//        if( eventName === 'mousemove' )	return;
//
//        EVENTS.addEventListener(group, eventName, function(event){
//            console.log(event);
//        }, false);
//    });

            //init CSS3D
            const DOMs = this.DOMs = new THREEx.HtmlMixer.Context(renderer, scene, camera);
            const rendererCSS = DOMs.rendererCss;
            {
                elementGL.style.position = 'absolute';
                elementGL.style.top = '0px';
                elementGL.style.width = '100%';
                elementGL.style.height = '100%';

                //elementGL.style.pointerEvents = 'none';


                /** view-source:http://jeromeetienne.github.io/threex.htmlmixer/examples/basic.html */

                rendererCSS.autoClear = false;
                rendererCSS.setClearColor(0x000000, 0.0);
                rendererCSS.gammaInput = true;
                rendererCSS.gammaOutput = true;


                var elementCSS = rendererCSS.domElement;
                elementCSS.style.position = 'absolute';
                elementCSS.style.top = '0px';
                elementCSS.style.width = '100%';
                elementCSS.style.height = '100%';
                view.appendChild(elementCSS);


                elementCSS.appendChild(elementGL);
            }


            const resizer = () => {
                const ww = window.innerWidth;
                const hh = window.innerHeight;
                camera.aspect = ww / hh;
                camera.updateProjectionMatrix();

                renderer.setSize(ww, hh);
                rendererCSS.setSize(ww, hh);
            };


            var lastTimeMsec = null;

            function animate(nowMsec) {
                // keep looping

                // measure time
                lastTimeMsec = lastTimeMsec || nowMsec - 1000 / 60.0;
                const deltaMsec = Math.min(200.0, nowMsec - lastTimeMsec);
                lastTimeMsec = nowMsec;
                // call each update function

                const delta = (deltaMsec / 1000);
                const now = nowMsec / 1000;

                update(delta, now);

                DOMs.update(delta, now)
                renderer.render(scene, camera);

                requestAnimationFrame(animate);
            }


            function update(delta, now) {
                controls.update();
            }

            resizer();
            window.addEventListener('resize', resizer, false);
            requestAnimationFrame(animate); //START
        }


        focusSteal(obj, enable) {

            const that = this;
            const eve = that.EVENTS;

            if (enable && !obj.focusSteal) {
                eve.bind(obj, 'mouseover', () => {
                    //console.info('mouseover', elementGL.style.pointerEvents);
                    that.controls.enabled = false;
                    that.dragControls.enabled = false;
                    that.elementGL.style.pointerEvents = 'none';
                    return true;
                });

                eve.bind(obj, 'mouseout', () => {
                    that.controls.enabled = true;
                    that.dragControls.enabled = true;
                    that.elementGL.style.pointerEvents = 'inherit';
                    //console.info('mouseout', elementGL.style.pointerEvents);
                    return true;
                });
                obj.focusSteal = true;
            } else if (!enable && obj.focusSteal) {
                eve.unbind(obj, 'mouseover');
                eve.unbind(obj, 'mouseout');

                obj.focusSteal = false;
            }
        }

        add(object, opt = {draggable: true}) {

            const that = this;

            object.delete = function () {
                if (object.draggable) {
                    that.draggable.remove(object);
                    delete object.draggable;
                }
                if (object.focusSteal) {
                    that.focusSteal(object, false);
                    delete object.focusSteal;
                }
                scene.remove(object);
            };

            this.scene.add(object);
            if (opt.draggable) {
                object.draggable = true;
                that.draggable.push(object);
            }

            return object;
        }

        addIcon() {
            var geometry = new THREE.BoxGeometry(40, 40, 40);
            var object = new THREE.Mesh(geometry,
                new THREE.MeshLambertMaterial({color: Math.random() * 0xffffff})
            );
            object.position.x = Math.random() * 1000 - 500;
            object.position.y = Math.random() * 600 - 300;
            object.position.z = Math.random() * 800 - 400;
            object.rotation.x = Math.random() * 2 * Math.PI;
            object.rotation.y = Math.random() * 2 * Math.PI;
            object.rotation.z = Math.random() * 2 * Math.PI;
            object.scale.x = Math.random() * 2 + 1;
            object.scale.y = Math.random() * 2 + 1;
            object.scale.z = Math.random() * 2 + 1;
            object.castShadow = false;
            object.receiveShadow = false;

            return this.add(object);
        }

        /** https://github.com/mrdoob/three.js/blob/master/examples/css3d_youtube.html  */
        addIFrame(url) {
            var ele = document.createElement('div');
            ele.style.width = '480px';
            ele.style.height = '360px';
            ele.style.backgroundColor = '#000';
            var iframe = document.createElement('iframe');
            iframe.style.width = '480px';
            iframe.style.height = '360px';
            iframe.style.border = '0px';
            iframe.src = url;
            ele.appendChild(iframe);
            return this.addDOM(ele);
        }

        addDOM(ele) {


            //mrdoob.com/lab/javascript/threejs/css3d/
            //groupCSS.add( DomSurface( 'http://fsf.org', 0, 0, - 240, Math.PI ) );
            //groupCSS.add(DomSurface('http://narchy.xyz', -240, 32, 0, -Math.PI / 2));


            // create the plane
            const mixerPlane = new THREEx.HtmlMixer.Plane(this.DOMs, ele);
            const obj = mixerPlane.object3d;
            obj.scale.multiplyScalar(700);

            this.focusSteal(obj, true);

            return this.add(obj);
        }

        stop() {

        }
    }

    const g = new GraJS(document.body);
    g.addIcon();
    g.addIFrame('/index.html');

    const b = document.createElement('button');
    b.innerHTML = ('wtf');
    g.addDOM(b);


    /*
     {
     const group = new THREE.Group();
     scene.add(group);

     var segments = maxParticleCount * maxParticleCount;

     var POS = new Float32Array(segments * 3);
     var COLOR = new Float32Array(segments * 3);

     //        var pMaterial = new THREE.PointsMaterial({
     //            color: 0xFFFFFF,
     //            size: 3,
     //            blending: THREE.AdditiveBlending,
     //            transparent: true,
     //            sizeAttenuation: false
     //        });
     var material = new THREE.LineBasicMaterial({
     vertexColors: THREE.VertexColors,
     blending: THREE.AdditiveBlending,
     transparent: true
     });

     nodes = new THREE.BufferGeometry();
     nodePos = new Float32Array(maxParticleCount * 3);
     for (var i = 0; i < maxParticleCount; i++) {
     var x = Math.random() * r - r / 2;
     var y = Math.random() * r - r / 2;
     var z = Math.random() * r - r / 2;
     nodePos[i * 3] = x;
     nodePos[i * 3 + 1] = y;
     nodePos[i * 3 + 2] = z;
     // add it to the geometry
     nodeData.push({
     vel: new THREE.Vector3(-1 + Math.random() * 2, -1 + Math.random() * 2, -1 + Math.random() * 2),
     arity: 0
     });
     }
     nodes.setDrawRange(0, particleCount);
     nodes.addAttribute('position', new THREE.BufferAttribute(nodePos, 3).setDynamic(true));


     //groupGL.add(pointCloud = new THREE.Points(nodes, pMaterial));


     var geometry = new THREE.BufferGeometry();
     geometry.addAttribute('position', new THREE.BufferAttribute(POS, 3).setDynamic(true));
     geometry.addAttribute('color', new THREE.BufferAttribute(COLOR, 3).setDynamic(true));
     geometry.computeBoundingSphere();
     geometry.setDrawRange(0, 0);

     edgeMesh = new THREE.LineSegments(geometry, material);
     group.add(edgeMesh);

     }

     //    {
     //        var gui = new dat.GUI();
     //        gui.add(effectController, "showLines").onChange(function (value) {
     //            edgeMesh.visible = value;
     //        });
     //        gui.add(effectController, "minDistance", 10, 300);
     //        gui.add(effectController, "limitConnections");
     //        gui.add(effectController, "maxConnections", 0, 30, 1);
     //        gui.add(effectController, "particleCount", 0, maxParticleCount, 1).onChange(function (value) {
     //            particleCount = parseInt(value);
     //            nodes.setDrawRange(0, particleCount);
     //        });
     //    }


     //---------------------


     if (nodeData.length > 0) {
     var vertexpos = 0;
     var colorpos = 0;
     var numEdges = 0;

     for (var i = 0; i < particleCount; i++)
     nodeData[i].arity = 0;

     for (var i = 0; i < particleCount; i++) {

     // get the particle
     var A = nodeData[i];

     const iii = i * 3;

     nodePos[iii] += A.vel.x;
     nodePos[iii + 1] += A.vel.y;
     nodePos[iii + 2] += A.vel.z;

     if (nodePos[iii + 1] < -rHalf || nodePos[iii + 1] > rHalf)
     A.vel.y = -A.vel.y;

     if (nodePos[iii] < -rHalf || nodePos[iii] > rHalf)
     A.vel.x = -A.vel.x;

     if (nodePos[iii + 2] < -rHalf || nodePos[iii + 2] > rHalf)
     A.vel.z = -A.vel.z;

     if (effectController.limitConnections && A.arity >= effectController.maxConnections)
     continue;

     const minDistanceSq = effectController.minDistance * effectController.minDistance;

     // Check collision
     for (var j = i + 1; j < particleCount; j++) {

     var B = nodeData[j];
     if (effectController.limitConnections && B.arity >= effectController.maxConnections)
     continue;

     const jjj = j * 3;


     var distSq = 0;
     var dx = nodePos[iii] - nodePos[jjj];
     distSq += dx * dx;
     if (distSq > minDistanceSq) continue;
     var dy = nodePos[iii + 1] - nodePos[jjj + 1];
     distSq += dy * dy;
     if (distSq > minDistanceSq) continue;
     var dz = nodePos[iii + 2] - nodePos[jjj + 2];
     distSq += dz * dz;
     if (distSq > minDistanceSq) continue;


     A.arity++;
     B.arity++;

     var alpha = 1.0 - Math.sqrt(distSq) / effectController.minDistance;

     POS[vertexpos++] = nodePos[iii];
     POS[vertexpos++] = nodePos[iii + 1];
     POS[vertexpos++] = nodePos[iii + 2];

     POS[vertexpos++] = nodePos[jjj];
     POS[vertexpos++] = nodePos[jjj + 1];
     POS[vertexpos++] = nodePos[jjj + 2];

     COLOR[colorpos++] = alpha;
     COLOR[colorpos++] = alpha;
     COLOR[colorpos++] = alpha;

     COLOR[colorpos++] = alpha;
     COLOR[colorpos++] = alpha;
     COLOR[colorpos++] = alpha;

     numEdges++;

     }
     }


     edgeMesh.geometry.setDrawRange(0, numEdges * 2);
     edgeMesh.geometry.attributes.position.needsUpdate = true;
     edgeMesh.geometry.attributes.color.needsUpdate = true;

     //pointCloud.geometry.attributes.position.needsUpdate = true;
     }


     */
</script>

</body>
</html>