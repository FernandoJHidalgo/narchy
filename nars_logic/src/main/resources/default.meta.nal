// Pei Wang's "Non-Axiomatic Logic" specified with a math. notation inspired DSL with given intiutive explainations:

//The rules of NAL, can be interpreted by considering the intiution behind the following two relations:
// Statement:                 (A --> B):               A can stand for B
// Statement about Statement: (A --> B) ==> (X --> Y): If A is true, so is/will be B
// --> is a relation in meaning of terms, while ==> is a relation of truth between statements.

//// Revision ////////////////////////////////////////////////////////////////////////////////////
// When a given belief is challenged by new experience, a new belief2 with same content (and disjoint evidental base),
// a new revised task, which sums up the evidence of both belief and belief2 is derived:

//   A, A |- A, (Belief:Revision) (Commented out because it is already handled by belief management in java)

//Similarity to Inheritance

    (S --> P), (S <-> P), task("?") |- (S --> P), (Belief:StructuralIntersection, Punctuation:Judgment)

//Inheritance to Similarity

    (S <-> P), (S --> P), task("?") |- (S <-> P), (Belief:StructuralAbduction, Punctuation:Judgment)

//Set Definition Similarity to Inheritance

    ({S} <-> {P}), {S} |- ({S} --> {P}), (Belief:Identity, Desire:Identity, Derive:AllowBackward)
    ({S} <-> {P}), {P} |- ({S} --> {P}), (Belief:Identity, Desire:Identity, Derive:AllowBackward)
    ([S] <-> [P]), [S] |- ([S] --> [P]), (Belief:Identity, Desire:Identity, Derive:AllowBackward)
    ([S] <-> [P]), [P] |- ([S] --> [P]), (Belief:Identity, Desire:Identity, Derive:AllowBackward)

    ({S} <-> {P}), {S} |- ({P} --> {S}), (Belief:Identity, Desire:Identity, Derive:AllowBackward)
    ({S} <-> {P}), {P} |- ({P} --> {S}), (Belief:Identity, Desire:Identity, Derive:AllowBackward)
    ([S] <-> [P]), [S] |- ([P] --> [S]), (Belief:Identity, Desire:Identity, Derive:AllowBackward)
    ([S] <-> [P]), [P] |- ([P] --> [S]), (Belief:Identity, Desire:Identity, Derive:AllowBackward)

//Set Definition Unwrap

    ({S} <-> {P}), {S} |- (S <-> P), (Belief:Identity, Desire:Identity, Derive:AllowBackward)
    ({S} <-> {P}), {P} |- (S <-> P), (Belief:Identity, Desire:Identity, Derive:AllowBackward)
    ([S] <-> [P]), [S] |- (S <-> P), (Belief:Identity, Desire:Identity, Derive:AllowBackward)
    ([S] <-> [P]), [P] |- (S <-> P), (Belief:Identity, Desire:Identity, Derive:AllowBackward)

//Nothing is more specific than a instance, so its similar

    (S --> {P}),  S  |- (S <-> {P}), (Belief:Identity, Desire:Identity, Derive:AllowBackward)
    (S --> {P}), {P} |- (S <-> {P}), (Belief:Identity, Desire:Identity, Derive:AllowBackward)

//nothing is more general than a property, so its similar

    ([S] --> P), [S] |- ([S] <-> P), (Belief:Identity, Desire:Identity, Derive:AllowBackward)
    ([S] --> P),  P  |- ([S] <-> P), (Belief:Identity, Desire:Identity, Derive:AllowBackward)

////// Truth-value functions: see TruthFunctions.java

//// Immediate Inference ////////////////////////////////////////////////////////////////////////////////////

  --A,   A, task("?") |- --A, (Belief:BeliefNegation, Punctuation:Judgment)
    A, --A, task("?") |-   A, (Belief:BeliefNegation, Punctuation:Judgment)

//A belief b <f,c> is equal to --b <1-f,c>, which is the negation rule:

    (A --> B), A, task(negative) |- --(A --> B), (Belief:Negation, Desire:Negation, Derive:AllowBackward)
    (A --> B), A, task(negative) |- --(A --> B), (Belief:Negation, Desire:Negation, Derive:AllowBackward)
  --(A --> B), A                 |-   (A --> B), (Belief:Negation, Desire:Negation, Derive:AllowBackward)
  --(A --> B), B                 |-   (A --> B), (Belief:Negation, Desire:Negation, Derive:AllowBackward)


    (A <-> B), A, task(negative) |- --(A <-> B), (Belief:Negation, Desire:Negation, Derive:AllowBackward)
  --(A <-> B), A                 |-   (A <-> B), (Belief:Negation, Desire:Negation, Derive:AllowBackward)


//If S can stand for P, P can to a certain low degree also represent the class S
//If after S usually P happens, then it might be a good guess that usually before P happens, S happens.

    (P --> S), (S --> P), task("?") |- (P --> S), (Belief:Conversion, Punctuation:Judgment)
    (P ==> S), (S ==> P), task("?") |- (P ==> S), (Belief:Conversion, Punctuation:Judgment)

// "If not smoking lets you be healthy, being not healthy may be the result of smoking"

    ( --S ==> P),   P |- ( --P ==> S), (Belief:Contraposition, Derive:AllowBackward)
    ( --S ==> P), --S |- ( --P ==> S), (Belief:Contraposition, Derive:AllowBackward)



//// inheritance-based syllogism ////////////////////////////////////////////////////////////////////////////////////
//       (A --> B) ------- (B --> C)
//            \               /
//             \             /
//              \           /
//               \         /
//                (A --> C)
//If A is a special case of B, and B is a special case of C, so is A a special case of C (strong), the other variations are hypotheses (weak)

(A --> B), (B --> C), neq(A,C) |- (A --> C), (Belief:Deduction, Desire:Strong, Derive:AllowBackward)
(A --> B), (A --> C), neq(B,C) |- (C --> B), (Belief:Abduction, Desire:Weak, Derive:AllowBackward)
(A --> C), (B --> C), neq(A,B) |- (B --> A), (Belief:Induction, Desire:Weak, Derive:AllowBackward)
(A --> B), (B --> C), neq(C,A) |- (C --> A), (Belief:Exemplification, Desire:Weak, Derive:AllowBackward)

//// similarity from inheritance ////////////////////////////////////////////////////////////////////////////////////
//If S is a special case of P, and P is a special case of S, then S and P are similar

    (S --> P), (P --> S) |- (S <-> P), (Belief:Intersection, Desire:Strong, Derive:AllowBackward)

//// inheritance from similarty <- TODO check why this one was missing ////////////////////////////////////////////////////////////////////////////////////

    (S <-> P), (P --> S) |- (S --> P), (Belief:ReduceConjunction, Desire:Strong, Derive:AllowBackward)

//// similarity-based syllogism ////////////////////////////////////////////////////////////////////////////////////
//If P and S are a special case of M, then they might be similar (weak),
//also if P and S are a general case of M

    (P --> M), (S --> M), neq(S,P) |- (S <-> P), (Belief:Comparison, Desire:Weak, Derive:AllowBackward)
    (M --> P), (M --> S), neq(S,P) |- (S <-> P), (Belief:Comparison, Desire:Weak, Derive:AllowBackward)

//If M is a special case of P and S and M are similar, then S is also a special case of P (strong)

    (M --> P), (S <-> M), neq(S,P) |- (S --> P), (Belief:Analogy, Desire:Strong, Derive:AllowBackward)
    (P --> M), (S <-> M), neq(S,P) |- (P --> S), (Belief:Analogy, Desire:Strong, Derive:AllowBackward)
    (M <-> P), (S <-> M), neq(S,P) |- (S <-> P), (Belief:Resemblance, Desire:Strong, Derive:AllowBackward)

//// inheritance-based composition ////////////////////////////////////////////////////////////////////////////////////
//If P and S are in the intension/extension of M, then union/difference and intersection can be built:

    (P --> M), (S --> M), notSet(S), notSet(P), neq(S,P), no_common_subterm(S,P) |- ((S | P) --> M), (Belief:Intersection),
                                                                                    ((S & P) --> M), (Belief:Union),
                                                                                    ((P ~ S) --> M), (Belief:Difference)

    (M --> P), (M --> S), notSet(S), notSet(P), neq(S,P), no_common_subterm(S,P) |- (M --> (P & S)), (Belief:Intersection),
                                                                                    (M --> (P | S)), (Belief:Union),
                                                                                    (M --> (P - S)), (Belief:Difference)

//// inheritance-based decomposition ////////////////////////////////////////////////////////////////////////////////////
//if (S --> M) is the case, and ((|,S,A..+) --> M) is not the case, then ((|,A..+) --> M) is not the case, hence Belief:DecomposePositiveNegativeNegative

    (S --> M), ((|,S,A..+) --> M) |- ((|,A..+) --> M), (Belief:DecomposePositiveNegativeNegative)
    (S --> M), ((&,S,A..+) --> M) |- ((&,A..+) --> M), (Belief:DecomposeNegativePositivePositive)
    (S --> M), ((S ~ P) --> M) |- (P --> M), (Belief:DecomposePositiveNegativePositive)
    (S --> M), ((P ~ S) --> M) |- (P --> M), (Belief:DecomposeNegativeNegativeNegative)

    (M --> S), (M --> (&,S,A..+)) |- (M --> (&,A..+)), (Belief:DecomposePositiveNegativeNegative)
    (M --> S), (M --> (|,S,A..+)) |- (M --> (|,A..+)), (Belief:DecomposeNegativePositivePositive)
    (M --> S), (M --> (S - P)) |- (M --> P), (Belief:DecomposePositiveNegativePositive)
    (M --> S), (M --> (P - S)) |- (M --> P), (Belief:DecomposeNegativeNegativeNegative)

//Set comprehension:

    (C --> {A..+}), (C --> {B..+}) |- (C --> {A..+,B..+}), (Belief:Union),
                                      (C --> intersect({A..+},{B..+})), (Belief:Intersection),
                                      (C --> differ({A..+},{B..+})), (Belief:Difference)

    (C --> [A..+]), (C --> [B..+]) |- (C --> [A..+,B..+]), (Belief:Intersection),
                                      (C --> intersect([A..+],[B..+])), (Belief:Union),
                                      (C --> differ([A..+],[B..+])), (Belief:Difference)

    ({A..+} --> C), ({B..+} --> C) |- ({A..+,B..+} --> C), (Belief:Intersection),
                                      (intersect({A..+},{B..+}) --> C), (Belief:Union),
                                      (differ({A..+},{B..+}) --> C), (Belief:Difference)

    ([A..+] --> C), ([B..+] --> C) |- ([A..+,B..+] --> C), (Belief:Union),
                                      (intersect([A..+],[B..+]) --> C), (Belief:Intersection),
                                      (differ([A..+],[B..+]) --> C), (Belief:Difference)

//Set element takeout:

//    (C --> {X,A..+}), C |- (C --> {X}), (Belief:StructuralDeduction)
//    (C --> [X,A..+]), C |- (C --> [X]), (Belief:StructuralDeduction)
//    ({X,A..+} --> C), C |- ({X} --> C), (Belief:StructuralDeduction)
//    ([X,A..+] --> C), C |- ([X] --> C), (Belief:StructuralDeduction)
    (C --> {X,A..+}), {X,A..+} |- (C --> {X}), (Belief:StructuralDeduction)
    (C --> [X,A..+]), [X,A..+] |- (C --> [X]), (Belief:StructuralDeduction)
    ({X,A..+} --> C), {X,A..+} |- ({X} --> C), (Belief:StructuralDeduction)
    ([X,A..+] --> C), [X,A..+] |- ([X] --> C), (Belief:StructuralDeduction)

//NAL3 single premise inference: (switched the belief term to the compound one so that less useful termlinks to atoms arent relied upon)

//    ((|,X,A..+) --> M), M |- (X --> M), (Belief:StructuralDeduction)
    ((|,X,A..+) --> M), (|,X,A..+) |- (X --> M), (Belief:StructuralDeduction)
//    (M --> (&,X,A..+)), M |- (M --> X), (Belief:StructuralDeduction)
    (M --> (&,X,A..+)), (&,X,A..+) |- (M --> X), (Belief:StructuralDeduction)

//    ((B ~ G) --> S), S |- (B --> S), (Belief:StructuralDeduction)
    ((B ~ G) --> S), (B ~ G) |- (B --> S), (Belief:StructuralDeduction)
//    (R --> (B - S)), R |- (R --> B), (Belief:StructuralDeduction)
    (R --> (B - S)), (B - S) |- (R --> B), (Belief:StructuralDeduction)

//// implication-based syllogism ////////////////////////////////////////////////////////////////////////////////////
//       (A ==> B) ------- (B ==> C)
//            \               /
//             \             /
//              \           /
//               \         /
//                (A ==> C)
//If after S M happens, and after M P happens, so P happens after S

    (M ==> P), (S ==> M), neq(S,P) |- (S ==> P), (Belief:Deduction, Order:ForAllSame, Derive:AllowBackward)

//"Please note that the temporal order in the conclusion of a weak rule is
//not necessarily the same as the order in the premises, given the hypothetical
//nature of such a rule."

    (P ==> M), (S ==> M), neq(S,P) |- (S ==> P), (Belief:Induction, Derive:AllowBackward)

    (M ==> P), (M ==> S), neq(S,P) |- (S ==> P), (Belief:Abduction, Derive:AllowBackward)

    (P ==> M), (M ==> S), neq(S,P) |- (S ==> P), (Belief:Exemplification, Derive:AllowBackward)

//// implication to equivalence ////////////////////////////////////////////////////////////////////////////////////
//If when S happens, P happens, and before P happens, S has happened, then they are truth-related equivalent

    (S ==> P), (P ==> S), neq(S,P) |- (S <=> P), (Belief:Intersection, Derive:AllowBackward)

//// equivalence-based syllogism ////////////////////////////////////////////////////////////////////////////////////
//Same as for inheritance again

    (P ==> M), (S ==> M), neq(S,P) |- (S <=> P), (Belief:Comparison, Derive:AllowBackward)

    (M ==> P), (M ==> S), neq(S,P) |- (S <=> P), (Belief:Comparison, Derive:AllowBackward)


    (M ==> P), (S <=> M), neq(S,P) |- (S ==> P), (Belief:Analogy, Derive:AllowBackward)

    (P ==> M), (S <=> M), neq(S,P) |- (P ==> S), (Belief:Analogy, Derive:AllowBackward)

    (M <=> P), (S <=> M), neq(S,P) |- (S <=> P), (Belief:Resemblance, Order:ForAllSame, Derive:AllowBackward)

//// implication-based composition ////////////////////////////////////////////////////////////////////////////////////
//Same as for inheritance again

    (P ==> M), (S ==> M), neq(S,P) |- ((P || S) ==> M), (Belief:Intersection),
                                      ((P && S) ==> M), (Belief:Union)

    (M ==> P), (M ==> S), neq(S,P) |- (M ==> (P && S)), (Belief:Intersection),
                                      (M ==> (P || S)), (Belief:Union)

//    (D =/> R), (D =\> K), neq(R,K) |- (K =/> R), (Belief:Abduction),
//                                      (R =\> K), (Belief:Induction),
//                                      (K </> R), (Belief:Comparison)

//// implication-based decomposition ////////////////////////////////////////////////////////////////////////////////////
//Same as for inheritance again

    (S ==> M), ((||,S,A..+) ==> M) |- ((||,A..+) ==> M), (Belief:DecomposePositiveNegativeNegative, Order:ForAllSame)
    (S ==> M), ((&&,S,A..+) ==> M) |- ((&&,A..+) ==> M), (Belief:DecomposeNegativePositivePositive, Order:ForAllSame)
    (M ==> S), (M ==> (&&,S,A..+)) |- (M ==> (&&,A..+)), (Belief:DecomposePositiveNegativeNegative, Order:ForAllSame)
    (M ==> S), (M ==> (||,S,A..+)) |- (M ==> (||,A..+)), (Belief:DecomposeNegativePositivePositive, Order:ForAllSame)

//// conditional syllogism ////////////////////////////////////////////////////////////////////////////////////
//If after M, P usually happens, and M happens, it means P is expected to happen

    B, (A ==> C) |- substituteIfUnifies(C,"$",A,B), (Belief:Deduction, Desire:Induction, Order:ForAllSame, Event:Anticipate)
    B, (C ==> A) |- substituteIfUnifies(C,"$",A,B), (Belief:Abduction, Desire:Deduction, Order:ForAllSame)

    B, (A <=> C) |- substituteIfUnifies(C,"$",A,B), (Belief:Deduction, Desire:Induction, Order:ForAllSame)

    (A ==> C), B |-  substituteIfUnifies( C, "$",A,B), (Belief:BeliefStructuralDeduction, Desire:Induction, Order:ForAllSame, Event:Anticipate)
    (C ==> A), B |-  substituteIfUnifies( C, "$",A,B), (Belief:StructuralAbduction, Desire:Deduction, Order:ForAllSame)


// the following two are probably dangerous and dont seem helpful:
//    (A ==> B), B |- A, (Belief:StructuralDeduction, Desire:Deduction, Order:ForAllSame, Event:Anticipate)
//    (A ==> B), A |- B, (Belief:StructuralDeduction, Desire:Induction, Order:ForAllSame)

////NAL7 specific inference ////////////////////////////////////////////////////////////////////////////////////
//Reasoning about temporal statements. those are using the ==> relation because relation in time is a relation of the truth between statements.

////    X, (XI ==> B) |- occurrsForward( substituteIfUnifies( B, "$", XI, (&/,X,/1)), XI, "==>"), (Belief:Deduction, Desire:Induction, Order:ForAllSame, Event:Anticipate)
//    X, (BI ==> Y) |- occurrsBackward( substituteIfUnifies( BI, "$", Y, X), BI, "==>"), (Belief:Abduction, Desire:Deduction, Order:ForAllSame)
//    C, (A ==> B) |- substituteIfUnifies( B, "$", A, C), (Belief:Deduction, Desire:Induction, Order:ForAllSame, Event:Anticipate),
//                    substituteIfUnifies( A, "$", B, C), (Belief:Abduction, Desire:Deduction, Order:ForAllSame)



//// conditional composition: ////////////////////////////////////////////////////////////////////////////////////
//They are let out for AGI purpose, don't let the system generate conjunctions or useless <=> and ==> statements
//For this there needs to be a semantic dependence between both, either by the predicate or by the subject,
//or a temporal dependence which acts as special case of semantic dependence
//These cases are handled by "Variable Introduction" and "Temporal Induction"

//   P, S, no_common_subterm(S,P) |- (S ==> P), (Belief:Induction)
//   P, S, no_common_subterm(S,P) |- (S <=> P), (Belief:Comparison)
//   P, S, no_common_subterm(S,P) |- (P && S), (Belief:Intersection)
//   P, S, no_common_subterm(S,P) |- (P || S), (Belief:Union)

//// conjunction decompose
     (&&,X,A..+), X  |- (&&,A..+), (Belief:StructuralDeduction, Desire:StructuralStrong),
                        X, (Belief:StructuralDeduction, Desire:StructuralStrong)

//     X, (&&,X,A..+)  |- (&&,A..+), (Belief:Deduction, Desire:Induction),
//                        X, (Belief:Deduction, Desire:Induction)



//// dependent variable elimination - decomposition with elimination of a variable
//TODO add a precondition that only allows this if B is not a subterm of the conjunction, which is the case above and produces different truth
     (&&,X,A..+), B  |- substituteIfUnifies((&&,A..+),"#",X,B), (Belief:AnonymousAnalogy, Desire:Strong, Order:ForAllSame)


//    (&/,B,A..+), B, task("!") |- (&/,A..+), (Desire:Strong)
//     (&&,A,B), A |- A, (Belief:StructuralDeduction, Desire:StructuralStrong),
//                    B, (Belief:StructuralDeduction, Desire:StructuralStrong)

//// propositional decomposition ////////////////////////////////////////////////////////////////////////////////////
//If S is the case, and (&&,S,A..+) is not the case, it can't be that (&&,A..+) is the case

    S, (&&,S,A..+) |- (&&,A..+), (Belief:DecomposePositiveNegativeNegative, Order:ForAllSame)
    S, (||,S,A..+) |- (||,A..+), (Belief:DecomposeNegativePositivePositive)

//Additional for negation: https://groups.google.com/forum/#!topic/open-nars/g-7r0jjq2Vc

    S, (&&,(--,S),A..+) |- (&&,A..+), (Belief:DecomposeNegativeNegativeNegative, Order:ForAllSame)
    S, (||,(--,S),A..+) |- (||,A..+), (Belief:DecomposePositivePositivePositive)

//// multi-conditional syllogism ////////////////////////////////////////////////////////////////////////////////////
//Inference about the pre/postconditions

    Y, ((&&,X,A..+) ==> B) |- substituteIfUnifies(((&&,A..+) ==> B),"$",X,Y), (Belief:Deduction, Order:ForAllSame)

//conditional abduction
    ((&&,M,A..+) ==> C), ((&&,A..+) ==> C) |- M, (Belief:Abduction, Order:ForAllSame)
//not sure why this also appears necessary
    ((&&,M,N) ==> C), (N ==> C) |- M, (Belief:Abduction, Order:ForAllSame)


//Can be derived by NAL7 rules so this won't be necessary there (Order:ForAllSame left out here)

//the first rule does not have Order:ForAllSame because it would be invalid, see: https://groups.google.com/forum/#!topic/open-nars/r5UJo64Qhrk
    ((&&,A..+) ==> C), M, notImplicationOrEquivalence(M) |- ((&&,M,A..+) ==> C), (Belief:Induction)

    ((&&,M,A..+) ==> C), (B ==> M) |- ((&&,B,A..+) ==> C), (Belief:Deduction, Order:ForAllSame)
    ((&&,M,A..+) ==> C), ((&&,B,A..+) ==> C) |- (B ==> M), (Belief:Induction, Order:ForAllSame)
    ((&&,B,A..+) ==> C), (B ==> M) |- ((&&,M,A..+) ==> C), (Belief:Abduction, Order:ForAllSame)

//// variable introduction ////////////////////////////////////////////////////////////////////////////////////
//Introduce variables by common subject or predicate

    (S --> M), (P --> M), neq(S,P), time(dtIfEvent) |- ((P --> $X) ==> (S --> $X)), (Belief:Abduction),
                                      ((S --> $X) ==> (P --> $X)), (Belief:Induction),
                                      ((P --> $X) <=> (S --> $X)), (Belief:Comparison),
                                      (&&,(S --> #Y),(P --> #Y)), (Belief:Intersection)



    (M --> S), (M --> P), neq(S,P), time(dtIfEvent) |- (($X --> S) ==> ($X --> P)), (Belief:Induction),
                                      (($X --> P) ==> ($X --> S)), (Belief:Abduction),
                                      (($X --> S) <=> ($X --> P)), (Belief:Comparison),
                                      (&&,(#Y --> S),(#Y --> P)), (Belief:Intersection)


//// 2nd variable introduction ////////////////////////////////////////////////////////////////////////////////////

    (A ==> (M --> P)), (M --> S), not_equal(A, (M --> S)) |- ((&&,A,($X --> S)) ==> ($X --> P)), (Belief:Induction),
                                                             (&&,(A ==> (#Y --> P)), (#Y --> S)), (Belief:Intersection)

    (&&,(M --> P), A..+), (M --> S), neq(S,P) |- (($Y --> S) ==> (&&,($Y --> P), A..+)), (Belief:Induction),
                                                 (&&,(#Y --> S), (#Y --> P), A..+), (Belief:Intersection)

    (A ==> (P --> M)), (S --> M), neq(S,P), not_equal(A, (S --> M)) |- ((&&,A,(P --> $X)) ==> (S --> $X)), (Belief:Abduction),
                                                                       (&&,(A ==> (P --> #Y)), (S --> #Y)), (Belief:Intersection)

    (&&,(P --> M), A..+), (S --> M), neq(S,P) |- ((S --> $Y) ==> (&&,(P --> $Y), A..+)), (Belief:Abduction),
                                                 (&&, (S --> #Y), (P --> #Y), A..+), (Belief:Intersection)


//conditional abduction by dependent variable

    ((X --> R) ==> Z), ((&&,(#Y --> B),(#Y --> R),A..*) ==> Z) |- (X --> B), (Belief:Abduction)

// conditional deduction "An inverse inference has been implemented as a form of deduction" https://code.google.com/p/open-nars/issues/detail?id=40&can=1

    (U --> L), ((&&,A..*,(#X --> L),(#X --> R)) ==> Z) |- substitute(((&&,A..*,(U --> R)) ==> Z),#X,U), (Belief:Deduction)



//// second level variable handling rules ////////////////////////////////////////////////////////////////////////////////////
//second level variable elimination (termlink level2 growth needed in order for these rules to work)

    (B --> K), (&&,(#X --> L),(($Y --> K) ==> A)) |- substitute((&&, (#X --> L), A), $Y,B), (Belief:Deduction)
    (B --> K), (&&,(#X --> L),(($Y --> K) ==> (&&,A..+))) |- substitute((&&,(#X --> L),A..+),$Y,B), (Belief:Deduction)

    (B --> K), (($X --> L) ==> (&&,(#Y --> K),A..+)) |- substitute((($X --> L) ==> (&&,A..+)),#Y,B), (Belief:AnonymousAnalogy)
    (B --> K), (($X --> L) ==> (&&,(#Y --> K),A)) |- substitute((($X --> L) ==> A),#Y,B), (Belief:AnonymousAnalogy)



//precondition combiner inference rule (variable_unification6):

    ((&&,C,A..+) ==> Z), ((&&,C,B..+) ==> Z) |- ((&&,A..+) ==> (&&,B..+)), (Belief:Induction, Desire:Induction),
                                                ((&&,B..+) ==> (&&,A..+)), (Belief:Induction, Desire:Induction)
    (Z ==> (&&,C,A..+)), (Z ==> (&&,C,B..+)) |- ((&&,A..+) ==> (&&,B..+)), (Belief:Abduction),
                                                ((&&,B..+) ==> (&&,A..+)), (Belief:Abduction)


//second level variable introduction

    (Y --> L), ((Y --> S) ==> R), neq(L,S) |- substitute(((&&,(#X --> L),(#X --> S)) ==> R),Y,#X), (Belief:Induction, Desire:Induction)
    (Y --> L), ((&&,(Y --> S),A..+) ==> R), neq(L,S) |- substitute(((&&,(#X --> L),(#X --> S),A..+) ==> R),Y,#X), (Belief:Intersection)




////Temporal induction: ////////////////////////////////////////////////////////////////////////////////////
//When P and then S happened according to an observation, by induction (weak) it may be that alyways after P, usually S happens.

    A, B, time(dtAfter), neq(A,B), notImplicationOrEquivalence(A), notImplicationOrEquivalence(B) |- (A ==> B), (Belief:Induction, Eternalize:Immediate)

    A, B, time(dtAfter), neq(A,B), notImplicationOrEquivalence(A), notImplicationOrEquivalence(B) |- (A <=> B), (Belief:Comparison)

    A, B, time(dtReverseAfter), neq(A,B), notImplicationOrEquivalence(A), notImplicationOrEquivalence(B) |- (B ==> A), (Belief:Abduction)

    A, B, time(dtAfterOrEternal), neq(A,B), notImplicationEquivalenceOrConjunction(A), notImplicationEquivalenceOrConjunction(B) |- (A && B), (Belief:Intersection, Desire:Intersection)




//    A, B, after(_), neq(A,B), notConjunction(A), notConjunction(B),  notImplicationOrEquivalence(A), notImplicationOrEquivalence(B) |- (B && A), (Belief:Intersection)


//    P, S, after(Task,Belief), measure_time(I), notImplicationOrEquivalence(P), notImplicationOrEquivalence(S) |- ((&/,S,I) =/> P), (Belief:Induction, Eternalize:Immediate),
//                                                                                                                       (P =\> (&/,S,I)), (Belief:Abduction),
//                                                                                                                       ((&/,S,I) </> P), (Belief:Comparison)

//    P, S, after(Task,Belief), notConjunction(P), notConjunction(S),  measure_time(I), notImplicationOrEquivalence(P), notImplicationOrEquivalence(S) |- (&/,S,I,P), (Belief:Intersection)

//    P, S, concurrent(Task,Belief), notImplicationOrEquivalence(P), notImplicationOrEquivalence(S) |- (S =|> P), (Belief:Induction, Eternalize:Immediate),
//                                                                                                          (P =|> S), (Belief:Induction),
//                                                                                                           (S <|> P), (Belief:Comparison)

//    P, S, concurrent(Task,Belief), notConjunction(P), notConjunction(S), notImplicationOrEquivalence(P), notImplicationOrEquivalence(S) |- (&|,S,P), (Belief:Intersection)

////backward inference is mostly handled by the rule transformation:

//    T, B |- C, [post] =>
//          C, B, task("?") |- T, [post]
//          C, T, task("?") |- B, [post]

//here now are the backward inference rules which should really only work on backward inference:

    (A --> S), (B --> S), neq(A,B), task("?") |- (A --> B), (Punctuation:Question),
                                                 (B --> A), (Punctuation:Question)

//and the backward inference driven forward inference:

//NAL2:

    ([A] <-> [B]), (A <-> B), task("?") |- ([A] <-> [B]), (Belief:BeliefIdentity, Punctuation:Judgment)
    ({A} <-> {B}), (A <-> B), task("?") |- ({A} <-> {B}), (Belief:BeliefIdentity, Punctuation:Judgment)

    ([A] --> [B]), (A <-> B), task("?") |- ([A] --> [B]), (Belief:BeliefIdentity, Punctuation:Judgment)
    ({A} --> {B}), (A <-> B), task("?") |- ({A} --> {B}), (Belief:BeliefIdentity, Punctuation:Judgment)

//experimental:
//    ([A] <-> {B}), (A <-> B), task("?") |- ([A] <-> {B}), (Belief:BeliefIdentity, Punctuation:Judgment)
//    ({A} <-> [B]), (A <-> B), task("?") |- ({A} <-> [B]), (Belief:BeliefIdentity, Punctuation:Judgment)
//    ([A] --> {B}), (A <-> B), task("?") |- ([A] --> {B}), (Belief:BeliefIdentity, Punctuation:Judgment)
//    ({A} --> [B]), (A <-> B), task("?") |- ({A} --> [B]), (Belief:BeliefIdentity, Punctuation:Judgment)


//NAL3:

////composition on both sides of a statement:


    ((&,B,A..+) --> (&,X,A..+)), (B --> X), task("?") |- ((&,B,A..+) --> (&,X,A..+)), (Belief:BeliefStructuralDeduction, Punctuation:Judgment)
    ((|,B,A..+) --> (|,X,A..+)), (B --> X), task("?") |- ((|,B,A..+) --> (|,X,A..+)), (Belief:BeliefStructuralDeduction, Punctuation:Judgment)

    ((-,S,A) --> (-,S,B)), (B --> A), task("?") |- ((-,S,A) --> (-,S,B)), (Belief:BeliefStructuralDeduction, Punctuation:Judgment)
    ((~,S,A) --> (~,S,B)), (B --> A), task("?") |- ((~,S,A) --> (~,S,B)), (Belief:BeliefStructuralDeduction, Punctuation:Judgment)

////composition on one side of aay w statement:

    (W --> (|,B,A..+)), (W --> B), task("?") |- (W --> (|,B,A..+)), (Belief:BeliefStructuralDeduction, Punctuation:Judgment)
    ((&,B,A..+) --> W), (B --> W), task("?") |- ((&,B,A..+) --> W), (Belief:BeliefStructuralDeduction, Punctuation:Judgment)

    (W --> (-,S,B)), (W --> B), task("?") |- (W --> (-,S,B)), (Belief:BeliefStructuralDifference, Punctuation:Judgment)
    ((~,S,B) --> W), (B --> W), task("?") |- ((~,S,B) --> W), (Belief:BeliefStructuralDifference, Punctuation:Judgment)

////// NAL4 - Transformations between products and images: ////////////////////////////////////////////////////////////////////////////////////
//Relations and transforming them into different representations so that arguments and the relation itself can become the subject or predicate
////composition on both sides of a statement:

    ((B,P) <-> Z) ,(B <-> A), task("?") |- ((B,P) <-> (A,P)), (Belief:BeliefStructuralDeduction, Punctuation:Judgment)
    ((P,B) <-> Z) ,(B <-> A), task("?") |- ((P,B) <-> (P,A)), (Belief:BeliefStructuralDeduction, Punctuation:Judgment)

    ((B,P) --> Z) ,(B --> A), task("?") |- ((B,P) --> (A,P)), (Belief:BeliefStructuralDeduction, Punctuation:Judgment)
    ((P,B) --> Z) ,(B --> A), task("?") |- ((P,B) --> (P,A)), (Belief:BeliefStructuralDeduction, Punctuation:Judgment)

    ((/,N,_,A) --> Z), (B --> A), task("?") |- ((/,N,_,A) --> (/,N,_,B)), (Belief:BeliefStructuralDeduction, Punctuation:Judgment)
    ((\,N,A,_) --> Z), (N --> R), task("?") |- ((\,N,A,_) --> (\,R,A,_)), (Belief:BeliefStructuralDeduction, Punctuation:Judgment)

//experimental reversal
//    ((P,B) --> Z) ,(A --> B), task("?") |- ((P,A) --> (P,B)), (Belief:BeliefStructuralDeduction, Punctuation:Judgment)
//    ((B,P) --> Z) ,(A --> B), task("?") |- ((A,P) --> (B,P)), (Belief:BeliefStructuralDeduction, Punctuation:Judgment)
//    ((P,B) <-> Z) ,(A <-> B), task("?") |- ((P,A) <-> (P,B)), (Belief:BeliefStructuralDeduction, Punctuation:Judgment)
//    ((B,P) <-> Z) ,(A <-> B), task("?") |- ((A,P) <-> (B,P)), (Belief:BeliefStructuralDeduction, Punctuation:Judgment)

//experimental 2-arity extension
//    ((/,_,A) --> Z), (B --> A), task("?") |- ((/,_,A) --> (/,_,B)), (Belief:BeliefStructuralDeduction, Punctuation:Judgment)



    ((A..B=_..+) --> M), B |- (B --> (/, M, A..B=_..+, _ )), (Belief:Identity, Desire:Identity)
    ((A..+) --> M), M |- (M --> (/,_, A..+)), (Belief:Identity, Desire:Identity)

    (M --> (A..B=_..+)), B |- ((\, M, A..B=_..+, _ ) --> B), (Belief:Identity, Desire:Identity)
    (M --> (A..+)), M |- ((\,_, A..+) --> M), (Belief:Identity, Desire:Identity)

    (B --> (/,M, A.._=B..+, _)), M |- ((A.._=B..+) --> M), (Belief:Identity, Desire:Identity)
    (M --> (/, _, A..+ )), M |- ((A..+) --> M), (Belief:Identity, Desire:Identity)

    ((\, M, A.._=B..+, _ ) --> B), M |- (M --> (A.._=B..+)), (Belief:Identity, Desire:Identity)
    ((\, _, A..+ ) --> M), M |- (M --> (A..+)), (Belief:Identity, Desire:Identity)





//compound composition one premise

    (||,B,A..+), B, task("?") |- (||,B,A..+), (Belief:BeliefStructuralDeduction, Punctuation:Judgment)
